<!DOCTYPE html>
<html lang="zh-cn">
<head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, shrink-to-fit=no">
    <meta name="referrer" content="origin">
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8">
    <meta http-equiv="Cache-Control" content="no-transform">
    <meta http-equiv="Cache-Control" content="no-siteapp">
    <title>
        
            进程间通信
        
    </title>
    <link rel="shortcut icon" href="#"/>

    <link type="text/css" rel="stylesheet" href="/font/LongCang.css">
    <link type="text/css" rel="stylesheet" href="/font/Monda.css">
    <link type="text/css" rel="stylesheet" href="/font/NotoSansSC.css">
    <link type="text/css" rel="stylesheet" href="/font/NotoSerifSC.css">
    <link type="text/css" rel="stylesheet" href="/font/Playball.css">
    <link type="text/css" rel="stylesheet" href="/font/PTMono.css">
    <link type="text/css" rel="stylesheet" href="/font/Roboto.css">
    <link type="text/css" rel="stylesheet" href="/font/RobotoSlab.css">
    <link type="text/css" rel="stylesheet" href="/font/Rosario.css">
    <link type="text/css" rel="stylesheet" href="/font/UbuntuMono.css">

    <link type="text/css" rel="stylesheet" href="/css/base.css">
    <link type="text/css" rel="stylesheet" href="/css/code.css">

    <script type="text/javascript" src="/js/jquery-3.4.1.min.js"></script>
<meta name="generator" content="Hexo 8.1.1"></head>
<body>
    <a id="cover"></a>
    <link type="text/css" rel="stylesheet" href="/css/post.css">
<div id="header" class="header">
    <div class="vertical">
        <div class="inner">
            
                <h1 class="header-subtitle">进程间通信</h1>
                <div class="header-subinfo">
                    <p class="article-info-text">
                        <span>
                            <i class="iconfont icon-time"></i> 发表时间：2025-11-24
                        </span>
                        
                            
                                <span id="/2025/11/24/进程间通信/" class="leancloud_visitors" data-flag-title="进程间通信">
                                    <i class="iconfont icon-browse"></i> 阅读：<sapn class="leancloud-visitors-count"></span>
                                </span>
                            
                            
                                <span>
                                    <i class="iconfont icon-interactive"></i> 评论：<span class="valine-comment-count" data-xid="/2025/11/24/进程间通信/"></span>
                                </span>
                              
                        
                    </p>
                    
                    
                </div>
            
        </div>
    </div>
    
</div>
<div id="container">
    
        <!-- 文章页面 -->
        <div id="article">
            <div class="toc"></div>
            <div class="article-body">
                <meta name="referrer" content="no-referrer"/>

<h2 id="进程间通信"><a href="#进程间通信" class="headerlink" title="进程间通信"></a>进程间通信</h2><h3 id="1-进程间通信介绍"><a href="#1-进程间通信介绍" class="headerlink" title="1. 进程间通信介绍"></a>1. 进程间通信介绍</h3><h4 id="1-1-进程间通信目的"><a href="#1-1-进程间通信目的" class="headerlink" title="1.1 进程间通信目的"></a>1.1 进程间通信目的</h4><ul>
<li>数据传输：一个进程需要将它的数据发送给另一个进程</li>
<li>资源共享：多个进程之间共享同样的资源</li>
<li>通知事件：一个进程需要向另一个或一组进程发送消息，通知它(们)发生了某种事件，比如进程终止时要通知父进程</li>
<li>进程控制：有些进程希望完全控制另一个进程的执行(如 <code>Debug</code> 进程)，此时控制进程希望能够拦截另一个进程的所有陷入和异常，并能够及时知道它的状态改变</li>
</ul>
<h4 id="1-2-进程间通信的发展"><a href="#1-2-进程间通信的发展" class="headerlink" title="1.2 进程间通信的发展"></a>1.2 进程间通信的发展</h4><table>
<thead>
<tr>
<th align="left"><strong>发展阶段</strong></th>
<th align="left"><strong>核心范畴</strong></th>
<th align="left"><strong>代表性技术&#x2F;协议</strong></th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>单机协作奠基</strong></td>
<td align="left"><strong>Unix单机IPC</strong></td>
<td align="left"><strong>管道 (Pipe, FIFO)</strong></td>
</tr>
<tr>
<td align="left"></td>
<td align="left"></td>
<td align="left"><strong>信号 (Signal)</strong></td>
</tr>
<tr>
<td align="left"><strong>单机IPC标准化</strong></td>
<td align="left"><strong>Unix单机IPC</strong></td>
<td align="left"><strong>System V IPC</strong> (消息队列, 信号量, 共享内存)</td>
</tr>
<tr>
<td align="left"><strong>通信范式统一</strong></td>
<td align="left"><strong>单机 &amp; 网络</strong></td>
<td align="left"><strong>BSD Sockets (Socket API)</strong></td>
</tr>
<tr>
<td align="left"><strong>单机IPC现代化</strong></td>
<td align="left"><strong>Unix单机IPC</strong></td>
<td align="left"><strong>POSIX IPC</strong> (消息队列, 信号量, 共享内存)</td>
</tr>
<tr>
<td align="left"><strong>分布式抽象崛起</strong></td>
<td align="left"><strong>网络&#x2F;分布式IPC</strong></td>
<td align="left"><strong>RPC (Sun RPC, DCE RPC)</strong></td>
</tr>
<tr>
<td align="left"><strong>企业集成解耦</strong></td>
<td align="left"><strong>网络&#x2F;分布式IPC</strong></td>
<td align="left"><strong>消息中间件 (JMS, AMQP &#x2F; RabbitMQ, IBM MQ)</strong></td>
</tr>
<tr>
<td align="left"><strong>Web通信标准化</strong></td>
<td align="left"><strong>网络&#x2F;分布式IPC</strong></td>
<td align="left"><strong>RESTful API over HTTP(S) &#x2F; JSON&#x2F;XML</strong></td>
</tr>
<tr>
<td align="left"><strong>高性能微服务</strong></td>
<td align="left"><strong>网络&#x2F;分布式IPC</strong></td>
<td align="left"><strong>gRPC, Apache Thrift</strong></td>
</tr>
<tr>
<td align="left"><strong>流式数据平台</strong></td>
<td align="left"><strong>网络&#x2F;分布式IPC</strong></td>
<td align="left"><strong>Apache Kafka, Pulsar</strong></td>
</tr>
<tr>
<td align="left"><strong>云原生通信治理</strong></td>
<td align="left"><strong>网络&#x2F;分布式IPC</strong></td>
<td align="left"><strong>服务网格 (Istio, Linkerd)</strong></td>
</tr>
</tbody></table>
<p>以 <code>Linux</code>&#x2F;<code>Unix</code> 操作系统为主线，可以是这样的主线：<code>管道 → System V → POSIX</code>，下面的学习以此路线展开</p>
<h4 id="1-3-进程间通信分类"><a href="#1-3-进程间通信分类" class="headerlink" title="1.3 进程间通信分类"></a>1.3 进程间通信分类</h4><p><strong>管道</strong></p>
<ul>
<li>匿名管道</li>
<li>命名管道<br><strong>System V IPC</strong></li>
<li><code>System V</code> 消息队列</li>
<li><code>System V</code> 共享内存</li>
<li><code>System V</code> 信号量<br><strong>POSIX IPC</strong></li>
<li>消息队列</li>
<li>共享内存</li>
<li>信号量</li>
<li>互斥量</li>
<li>条件变量</li>
<li>读写锁</li>
</ul>
<h3 id="2-管道"><a href="#2-管道" class="headerlink" title="2. 管道"></a>2. 管道</h3><h4 id="2-1-什么是管道"><a href="#2-1-什么是管道" class="headerlink" title="2.1 什么是管道"></a>2.1 什么是管道</h4><p>管道(<code>Pipe</code>)是 <code>Unix</code>&#x2F;<code>Linux</code> 系统中最古老、最基础的进程间通信(<code>IPC</code>)机制，由 <code>Douglas McIlroy</code> 提出，并于 <code>1973</code> 年在 <code>Unix V4</code> 中首次实现，把从一个进程连接到另一个进程的一个数据流称为一个”管道”</p>
<!-- ![1748838521889](image/进程间通信/1748838521889.png) -->
<img src="/2025/11/24/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/1748838521889.png" class="">

<h3 id="3-匿名管道-pipe"><a href="#3-匿名管道-pipe" class="headerlink" title="3. 匿名管道 pipe"></a>3. 匿名管道 pipe</h3><p>是的，创建匿名管道的系统调用确实是 <code>pipe</code>。它是 <code>Unix</code>&#x2F;<code>Linux</code> 系统中实现<strong>进程间通信</strong>的一种基础机制</p>
<p><strong>功能：</strong></p>
<ul>
<li><code>pipe</code> 创建一个新的<strong>匿名管道</strong></li>
<li>管道提供<strong>单向</strong>的数据通道</li>
<li>它返回<strong>两个文件描述符</strong>：<ul>
<li><code>fd[0]</code>: <strong>读端</strong>。用于从管道中读取数据</li>
<li><code>fd[1]</code>: <strong>写端</strong>。用于向管道中写入数据</li>
</ul>
</li>
<li>写入 <code>fd[1]</code> 的数据可以被从 <code>fd[0]</code> 读取出来</li>
</ul>
<p><strong>原型</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">pipe</span><span class="params">(<span class="type">int</span> pipefd[<span class="number">2</span>])</span>;</span><br></pre></td></tr></table></figure>
<ul>
<li><strong>参数：</strong> <code>pipefd</code> 是一个包含两个整数的数组。调用成功后：<ul>
<li><code>pipefd[0]</code> 会被设置为管道的<strong>读端</strong>文件描述符</li>
<li><code>pipefd[1]</code> 会被设置为管道的<strong>写端</strong>文件描述符</li>
</ul>
</li>
<li><strong>返回值：</strong><ul>
<li>成功时返回 <code>0</code></li>
<li>失败时返回 <code>-1</code>，并设置 <code>errno</code> 来指示错误类型（如 <code>EMFILE</code> 进程文件描述符表满，<code>ENFILE</code> 系统文件表满）</li>
</ul>
</li>
</ul>
<h4 id="3-1-使用-pipe"><a href="#3-1-使用-pipe" class="headerlink" title="3.1 使用 pipe"></a>3.1 使用 pipe</h4><p>建立一个简单的管道，实现父子进程之间的通信，用 <code>fork</code> 共享管道</p>
<!-- ![1748846980382](image/进程间通信/1748846980382.png) -->
<img src="/2025/11/24/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/1748846980382.png" class="">

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Write</span><span class="params">(<span class="type">int</span> wfd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="type">int</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (cnt &lt; <span class="number">10</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> buffer[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="built_in">snprintf</span>(buffer, <span class="built_in">sizeof</span>(buffer),</span><br><span class="line">                 <span class="string">&quot;Hey,I&#x27;am child process,my pid is %d---cnt: %d&quot;</span>,</span><br><span class="line">                 <span class="built_in">getpid</span>(), cnt++);</span><br><span class="line">        <span class="type">ssize_t</span> w = <span class="built_in">write</span>(wfd, buffer, <span class="built_in">strlen</span>(buffer));</span><br><span class="line">        <span class="keyword">if</span> (w &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            std::cerr &lt;&lt; <span class="string">&quot;Read error&quot;</span> &lt;&lt; <span class="built_in">strerror</span>(errno) &lt;&lt; std::endl;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// break;</span></span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Read</span><span class="params">(<span class="type">int</span> rfd)</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">char</span> buffer[<span class="number">1024</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="type">ssize_t</span> r = <span class="built_in">read</span>(rfd, buffer, <span class="built_in">sizeof</span>(buffer) - <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (r &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            std::cerr &lt;&lt; <span class="string">&quot;Read error&quot;</span> &lt;&lt; <span class="built_in">strerror</span>(errno) &lt;&lt; std::endl;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (r == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Read from child process: \n&quot;</span></span><br><span class="line">                  &lt;&lt; buffer &lt;&lt; std::endl;</span><br><span class="line">        <span class="comment">// sleep(5);</span></span><br><span class="line">        <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 1. 创建管道</span></span><br><span class="line">    <span class="type">int</span> pipefd[<span class="number">2</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">    <span class="type">int</span> pipe_id = <span class="built_in">pipe</span>(pipefd);</span><br><span class="line">    <span class="keyword">if</span> (pipe_id &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;pipe error&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 2. 创建子进程</span></span><br><span class="line">    <span class="type">pid_t</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cerr &lt;&lt; <span class="built_in">strerror</span>(errno) &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 3. 关闭不需要的文件描述符</span></span><br><span class="line">        <span class="comment">// child process-&gt;write,close 0</span></span><br><span class="line">        <span class="built_in">close</span>(pipefd[<span class="number">0</span>]);</span><br><span class="line">        <span class="built_in">Write</span>(pipefd[<span class="number">1</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">close</span>(pipefd[<span class="number">1</span>]);</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 3. 关闭不需要的文件描述符</span></span><br><span class="line">        <span class="comment">// parent process-&gt;read,close 1</span></span><br><span class="line">        <span class="built_in">close</span>(pipefd[<span class="number">1</span>]);</span><br><span class="line">        <span class="built_in">Read</span>(pipefd[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line">        <span class="built_in">close</span>(pipefd[<span class="number">0</span>]);</span><br><span class="line">        <span class="type">int</span> status = <span class="number">0</span>;</span><br><span class="line">        <span class="built_in">waitpid</span>(pid, &amp;status, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">if</span>(<span class="built_in">WIFEXITED</span>(status))</span><br><span class="line">        &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Child process exited normally,status: &quot;</span> &lt;&lt;  <span class="built_in">WEXITSTATUS</span>(status) &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(<span class="built_in">WIFSIGNALED</span>(status))</span><br><span class="line">        &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Child process killed by signal: &quot;</span> &lt;&lt; <span class="built_in">WTERMSIG</span>(status) &lt;&lt; </span><br><span class="line">            <span class="string">&quot;(&quot;</span> &lt;&lt; <span class="built_in">strsignal</span>(<span class="built_in">WTERMSIG</span>(status)) &lt;&lt; <span class="string">&quot;)&quot;</span> &lt;&lt;std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>站在不同视角理解管道</strong></p>
<ul>
<li><p>文件：</p>
  <!-- ![1748847203304](image/进程间通信/1748847203304.png) -->
  <img src="/2025/11/24/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/1748847203304.png" class="">
  <!-- ![1748847215106](image/进程间通信/1748847215106.png) -->
  <img src="/2025/11/24/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/1748847215106.png" class="">
  <!-- ![1748847224575](image/进程间通信/1748847224575.png) -->
  <img src="/2025/11/24/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/1748847224575.png" class="">

</li>
<li><p>内核：</p>
  <!-- ![1748847244910](image/进程间通信/1748847244910.png) -->
  <img src="/2025/11/24/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/1748847244910.png" class=""></li>
</ul>
<p>看待管道，就像看待文件一样！管道的使用和文件一致，符合 <code>&quot;Linux一切皆文件的思想&quot;</code></p>
<h4 id="3-2-管道的特性和通信情况"><a href="#3-2-管道的特性和通信情况" class="headerlink" title="3.2 管道的特性和通信情况"></a>3.2 管道的特性和通信情况</h4><h5 id="3-2-1-管道的特性"><a href="#3-2-1-管道的特性" class="headerlink" title="3.2.1 管道的特性"></a>3.2.1 管道的特性</h5><ol>
<li><p><strong>文件描述符访问：</strong> 管道在创建时（通常通过 <code>pipe()</code> 系统调用）会返回两个文件描述符：一个用于读取（<code>fd[0]</code>），一个用于写入（<code>fd[1]</code>）。进程像操作普通文件一样使用 <code>read()</code> 和 <code>write()</code> 系统调用通过这些描述符与管道交互</p>
</li>
<li><p><strong>单向性：</strong> 这是管道的<strong>核心特性</strong>。数据在管道中只能<strong>单向流动</strong>。一端（<code>fd[1]</code>）只能写入数据，另一端（<code>fd[0]</code>）只能读取数据。如果需要双向通信，必须创建两个管道</p>
</li>
<li><p><strong>先进先出：</strong> 管道保证数据的传输顺序是<strong>先进先出</strong>的。写入管道的数据字节流，其被读取出来的顺序与写入的顺序严格一致</p>
</li>
<li><p><strong>有限容量与阻塞：</strong></p>
<ul>
<li>管道在内存中有一个<strong>固定大小的缓冲区</strong>（大小通常是几 <code>KB</code> 到几十 <code>KB</code>，可通过系统调用查询或设置）</li>
<li><strong>写满阻塞：</strong> 当写入进程试图向一个<strong>已满</strong>的管道写入数据时，该进程会被<strong>阻塞</strong>（暂停执行），直到管道中有足够的空间容纳要写入的数据</li>
<li><strong>读空阻塞：</strong> 当读取进程试图从一个<strong>空</strong>的管道中读取数据时，该进程会被<strong>阻塞</strong>，直到有数据被写入管道</li>
<li><strong>读端关闭后写：</strong> 如果所有读取端的文件描述符都已关闭，此时再向管道写入数据会触发 <code>SIGPIPE</code> 信号（默认行为是终止进程），并且 <code>write()</code> 调用会失败并设置 <code>errno</code> 为 <code>EPIPE</code></li>
<li><strong>写端关闭后读：</strong> 如果所有写入端的文件描述符都已关闭，此时从管道读取数据，<code>read()</code> 会返回 <code>0</code>（表示文件结束）</li>
</ul>
</li>
<li><p><strong>亲缘关系限制：</strong> 管道通常只能用于具有<strong>共同祖先</strong>的进程间通信，最常见的是父子进程或兄弟进程。这是因为管道是通过 <code>fork()</code> 操作继承文件描述符来实现进程间共享的。匿名管道本身无法直接在任意两个无关进程间建立连接（命名管道可以解决这个问题，但命名管道是另一种IPC机制）</p>
</li>
<li><p><strong>面向字节流（Byte-Oriented）</strong> 管道传输的是<strong>无结构的字节流</strong>（类似于普通文件），而非结构化消息（如消息队列中的数据包） </p>
<ul>
<li>写入端多次写入的数据（例如分两次写入 <code>&quot;Hello&quot;</code> 和 <code>&quot;World&quot;</code>），在读取端可能被<strong>一次性读出</strong>（如 <code>&quot;HelloWorld&quot;</code>），或<strong>分多次读出</strong>（如先读 <code>&quot;Hel&quot;</code> 再读 <code>&quot;loWorld&quot;</code>）</li>
<li>可以按任意字节数读取（如每次读 1 字节或 4096 字节），不受写入块大小的限制</li>
</ul>
</li>
<li><p><strong>生命周期随进程（Process-Bound Lifetime）</strong> 匿名管道的<strong>存在依赖于进程</strong>：当所有关联进程都关闭管道描述符后，管道资源会被操作系统自动回收</p>
<ol>
<li><strong>创建即存在：</strong><br>通过 <code>pipe()</code> 系统调用创建后，内核分配缓冲区并返回两个文件描述符</li>
<li><strong>进程关闭描述符即解除关联：</strong><br>进程调用 <code>close(fd[0])</code> 或 <code>close(fd[1])</code> 后，便不再与该管道交互</li>
<li><strong>资源回收条件：</strong><br>当<strong>所有进程</strong>（包括通过 <code>fork()</code> 继承的子进程）都关闭了<strong>管道的所有描述符</strong>（读端和写端）时，内核才会销毁该管道并释放缓冲区资源</li>
</ol>
</li>
</ol>
<table>
<thead>
<tr>
<th><strong>特性</strong></th>
<th><strong>说明</strong></th>
</tr>
</thead>
<tbody><tr>
<td>文件描述符访问</td>
<td>通过 <code>fd[0]</code>（读端）和 <code>fd[1]</code>（写端）操作</td>
</tr>
<tr>
<td><strong>单向性</strong></td>
<td>数据只能单向流动（写端→读端）</td>
</tr>
<tr>
<td>先进先出 (FIFO)</td>
<td>保证数据顺序与写入顺序一致</td>
</tr>
<tr>
<td>有限容量与阻塞</td>
<td>缓冲区满时写阻塞，空时读阻塞；读端关闭后写触发 <code>SIGPIPE</code>，写端关闭后读返回 <code>0</code></td>
</tr>
<tr>
<td>亲缘关系限制</td>
<td>仅适用于通过 <code>fork()</code> 共享描述符的进程（父子&#x2F;兄弟进程）</td>
</tr>
<tr>
<td>面向字节流</td>
<td>传输无结构的字节流，无消息边界，需应用层协议解析</td>
</tr>
<tr>
<td>生命周期随进程</td>
<td>当所有进程关闭所有描述符后，内核自动销毁管道</td>
</tr>
</tbody></table>
<h5 id="3-2-2-管道的通信情况"><a href="#3-2-2-管道的通信情况" class="headerlink" title="3.2.2 管道的通信情况"></a>3.2.2 管道的通信情况</h5><table>
<thead>
<tr>
<th align="left">速率&#x2F;状态</th>
<th align="left">关键</th>
<th align="left">主要行为</th>
<th align="left">结果&#x2F;意义</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>读快写慢</strong></td>
<td align="left">读端尝试读<strong>空</strong>管道</td>
<td align="left"><strong>读进程阻塞</strong></td>
<td align="left">等待数据到来 (缓冲区饥饿)</td>
</tr>
<tr>
<td align="left"><strong>写快读慢</strong></td>
<td align="left">写端尝试写<strong>满</strong>管道</td>
<td align="left"><strong>写进程阻塞</strong></td>
<td align="left">等待空间释放 (缓冲区满)</td>
</tr>
<tr>
<td align="left"><strong>写关闭，读继续</strong></td>
<td align="left">所有写端描述符关闭后读</td>
<td align="left"><code>read()</code> <strong>返回 <code>0</code> (EOF)</strong></td>
<td align="left">正常结束信号，数据发送方已关闭</td>
</tr>
<tr>
<td align="left"><strong>读关闭，写继续</strong></td>
<td align="left">所有读端描述符关闭后写</td>
<td align="left"><strong>发送 <code>SIGPIPE</code> (默认终止进程)</strong> 或 <code>write()</code> <strong>失败 (EPIPE)</strong></td>
<td align="left">错误状态，数据接收方已消失，强制处理无效写入</td>
</tr>
</tbody></table>
<h4 id="3-3-基于管道实现进程池"><a href="#3-3-基于管道实现进程池" class="headerlink" title="3.3 基于管道实现进程池"></a>3.3 基于管道实现进程池</h4><p>学习完管道，可以基于管道 + 进程的方式实现一个简易的进程池，模型如下图</p>
<!-- ![1750074140967](image/进程间通信/1750074140967.png) -->
<img src="/2025/11/24/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/1750074140967.png" class="">
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ProcessPool.hpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifndef</span> _PROCESS_POOL</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _PROCESS_POOL</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _PROCESS_NUM 6</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _ERROE(msg) \</span></span><br><span class="line"><span class="meta">    std::cerr <span class="string">&lt;&lt; &quot;ERROR&lt;&quot; &lt;&lt; msg &lt;&lt; &quot;&gt;</span>:<span class="string">&quot; &lt;&lt; strerror(errno) &lt;&lt; &quot;</span>(<span class="string">&quot; &lt;&lt; errno &lt;&lt; &quot;</span>)<span class="string">&quot; &lt;&lt; std::endl;</span></span></span><br><span class="line"><span class="string"><span class="meta"></span></span></span><br><span class="line"><span class="string"><span class="meta">#include &lt;iostream&gt;</span></span></span><br><span class="line"><span class="string"><span class="meta">#include &lt;cstring&gt;</span></span></span><br><span class="line"><span class="string"><span class="meta">#include &lt;string&gt;</span></span></span><br><span class="line"><span class="string"><span class="meta">#include &lt;vector&gt;</span></span></span><br><span class="line"><span class="string"><span class="meta">#include &lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="string"><span class="meta">#include &lt;cerrno&gt;</span></span></span><br><span class="line"><span class="string"><span class="meta">#include &lt;sys/wait.h&gt;</span></span></span><br><span class="line"><span class="string"><span class="meta">#include &quot;</span>task.hpp<span class="string">&quot;</span></span></span><br><span class="line"><span class="string"><span class="meta"></span></span></span><br><span class="line"><span class="string"><span class="meta">class Channel</span></span></span><br><span class="line"><span class="string"><span class="meta">&#123;</span></span></span><br><span class="line"><span class="string"><span class="meta">public:</span></span></span><br><span class="line"><span class="string"><span class="meta">    Channel(pid_t sub_id, pid_t par_id, int r_fd)</span></span></span><br><span class="line"><span class="string"><span class="meta">        : _sub_id(sub_id), _par_id(par_id), _w_fd(r_fd)</span></span></span><br><span class="line"><span class="string"><span class="meta">    &#123;</span></span></span><br><span class="line"><span class="string"><span class="meta">        _name = &quot;</span>Channel<span class="string">&lt;&quot; + std::to_string(_w_fd) + &quot;&gt;</span>[<span class="string">&quot; + std::to_string(_sub_id) + &quot;</span>]<span class="string">&quot;;</span></span></span><br><span class="line"><span class="string"><span class="meta">    &#125;</span></span></span><br><span class="line"><span class="string"><span class="meta">    void Close()</span></span></span><br><span class="line"><span class="string"><span class="meta">    &#123;</span></span></span><br><span class="line"><span class="string"><span class="meta">        close(_w_fd);</span></span></span><br><span class="line"><span class="string"><span class="meta">    &#125;</span></span></span><br><span class="line"><span class="string"><span class="meta">    void ParentWait()</span></span></span><br><span class="line"><span class="string"><span class="meta">    &#123;</span></span></span><br><span class="line"><span class="string"><span class="meta">        int status = 0;</span></span></span><br><span class="line"><span class="string"><span class="meta">        pid_t ret = waitpid(_sub_id, &amp;status, 0);</span></span></span><br><span class="line"><span class="string"><span class="meta">        if (ret &lt; 0)</span></span></span><br><span class="line"><span class="string"><span class="meta">        &#123;</span></span></span><br><span class="line"><span class="string"><span class="meta">            _ERROE(&quot;</span>Wait <span class="keyword">error</span><span class="string">&quot;)</span></span></span><br><span class="line"><span class="string"><span class="meta">        &#125;</span></span></span><br><span class="line"><span class="string"><span class="meta">        else if (ret == _sub_id)</span></span></span><br><span class="line"><span class="string"><span class="meta">        &#123;</span></span></span><br><span class="line"><span class="string"><span class="meta">            return;</span></span></span><br><span class="line"><span class="string"><span class="meta">        &#125;</span></span></span><br><span class="line"><span class="string"><span class="meta">    &#125;</span></span></span><br><span class="line"><span class="string"><span class="meta">    void SendTaskCode(int task_code)</span></span></span><br><span class="line"><span class="string"><span class="meta">    &#123;</span></span></span><br><span class="line"><span class="string"><span class="meta">        ssize_t n = write(_w_fd, &amp;task_code, sizeof(task_code));</span></span></span><br><span class="line"><span class="string"><span class="meta">        if (n &lt; 0)</span></span></span><br><span class="line"><span class="string"><span class="meta">        &#123;</span></span></span><br><span class="line"><span class="string"><span class="meta">            _ERROE(&quot;</span>Write <span class="keyword">error</span><span class="string">&quot;)</span></span></span><br><span class="line"><span class="string"><span class="meta">        &#125;</span></span></span><br><span class="line"><span class="string"><span class="meta">        return;</span></span></span><br><span class="line"><span class="string"><span class="meta">    &#125;</span></span></span><br><span class="line"><span class="string"><span class="meta">    pid_t GetPid() &#123; return _sub_id; &#125;</span></span></span><br><span class="line"><span class="string"><span class="meta">    std::string GetName() &#123; return _name; &#125;</span></span></span><br><span class="line"><span class="string"><span class="meta">    int GetFd() &#123; return _w_fd; &#125;</span></span></span><br><span class="line"><span class="string"><span class="meta">    ~Channel() &#123;&#125;</span></span></span><br><span class="line"><span class="string"><span class="meta">private:</span></span></span><br><span class="line"><span class="string"><span class="meta">    pid_t _sub_id;</span></span></span><br><span class="line"><span class="string"><span class="meta">    pid_t _par_id;</span></span></span><br><span class="line"><span class="string"><span class="meta">    int _w_fd;</span></span></span><br><span class="line"><span class="string"><span class="meta">    std::string _name;</span></span></span><br><span class="line"><span class="string"><span class="meta">&#125;;</span></span></span><br><span class="line"><span class="string"><span class="meta"></span></span></span><br><span class="line"><span class="string"><span class="meta">class ChannelManager</span></span></span><br><span class="line"><span class="string"><span class="meta">&#123;</span></span></span><br><span class="line"><span class="string"><span class="meta">public:</span></span></span><br><span class="line"><span class="string"><span class="meta">    ChannelManager(int index = 0) : _index(0) &#123;&#125;</span></span></span><br><span class="line"><span class="string"><span class="meta">    void CloseAll()</span></span></span><br><span class="line"><span class="string"><span class="meta">    &#123;</span></span></span><br><span class="line"><span class="string"><span class="meta">        for (auto &amp;c : _channel)</span></span></span><br><span class="line"><span class="string"><span class="meta">        &#123;</span></span></span><br><span class="line"><span class="string"><span class="meta">            c.Close();</span></span></span><br><span class="line"><span class="string"><span class="meta">        &#125;</span></span></span><br><span class="line"><span class="string"><span class="meta">    &#125;</span></span></span><br><span class="line"><span class="string"><span class="meta">    void WaitAll()</span></span></span><br><span class="line"><span class="string"><span class="meta">    &#123;</span></span></span><br><span class="line"><span class="string"><span class="meta">        for (auto &amp;c : _channel)</span></span></span><br><span class="line"><span class="string"><span class="meta">        &#123;</span></span></span><br><span class="line"><span class="string"><span class="meta">            c.ParentWait();</span></span></span><br><span class="line"><span class="string"><span class="meta">        &#125;</span></span></span><br><span class="line"><span class="string"><span class="meta">    &#125;</span></span></span><br><span class="line"><span class="string"><span class="meta">    void ShowFd()</span></span></span><br><span class="line"><span class="string"><span class="meta">    &#123;</span></span></span><br><span class="line"><span class="string"><span class="meta">        for (auto c : _channel)</span></span></span><br><span class="line"><span class="string"><span class="meta">        &#123;</span></span></span><br><span class="line"><span class="string"><span class="meta">            std::cout &lt;&lt; c.GetFd() &lt;&lt; &quot;</span>  <span class="string">&quot;;</span></span></span><br><span class="line"><span class="string"><span class="meta">        &#125;</span></span></span><br><span class="line"><span class="string"><span class="meta">        std::cout &lt;&lt; &quot;</span>\n<span class="string">&quot;;</span></span></span><br><span class="line"><span class="string"><span class="meta">    &#125;</span></span></span><br><span class="line"><span class="string"><span class="meta">    void ShowName()</span></span></span><br><span class="line"><span class="string"><span class="meta">    &#123;</span></span></span><br><span class="line"><span class="string"><span class="meta">        for (auto c : _channel)</span></span></span><br><span class="line"><span class="string"><span class="meta">        &#123;</span></span></span><br><span class="line"><span class="string"><span class="meta">            std::cout &lt;&lt; c.GetName() &lt;&lt; &quot;</span>  <span class="string">&quot;;</span></span></span><br><span class="line"><span class="string"><span class="meta">        &#125;</span></span></span><br><span class="line"><span class="string"><span class="meta">        std::cout &lt;&lt; &quot;</span>\n<span class="string">&quot;;</span></span></span><br><span class="line"><span class="string"><span class="meta">    &#125;</span></span></span><br><span class="line"><span class="string"><span class="meta">    void InsertChannel(pid_t pid, pid_t ppid, int r_fd)</span></span></span><br><span class="line"><span class="string"><span class="meta">    &#123;</span></span></span><br><span class="line"><span class="string"><span class="meta">        _channel.emplace_back(pid, ppid, r_fd);</span></span></span><br><span class="line"><span class="string"><span class="meta">        _index++;</span></span></span><br><span class="line"><span class="string"><span class="meta">    &#125;</span></span></span><br><span class="line"><span class="string"><span class="meta">    void PrintChannel()</span></span></span><br><span class="line"><span class="string"><span class="meta">    &#123;</span></span></span><br><span class="line"><span class="string"><span class="meta">        for (auto channel : _channel)</span></span></span><br><span class="line"><span class="string"><span class="meta">        &#123;</span></span></span><br><span class="line"><span class="string"><span class="meta">            std::cout &lt;&lt; channel.GetName() &lt;&lt; std::endl;</span></span></span><br><span class="line"><span class="string"><span class="meta">        &#125;</span></span></span><br><span class="line"><span class="string"><span class="meta">    &#125;</span></span></span><br><span class="line"><span class="string"><span class="meta">    Channel &amp;SelectChannel()</span></span></span><br><span class="line"><span class="string"><span class="meta">    &#123;</span></span></span><br><span class="line"><span class="string"><span class="meta">        // 轮询选择</span></span></span><br><span class="line"><span class="string"><span class="meta">        _index %= GetSize();</span></span></span><br><span class="line"><span class="string"><span class="meta">        Channel &amp;ch = _channel[_index++];</span></span></span><br><span class="line"><span class="string"><span class="meta">        return ch;</span></span></span><br><span class="line"><span class="string"><span class="meta">    &#125;</span></span></span><br><span class="line"><span class="string"><span class="meta">    int GetSize() &#123; return _channel.size(); &#125;</span></span></span><br><span class="line"><span class="string"><span class="meta">    ~ChannelManager() &#123;&#125;</span></span></span><br><span class="line"><span class="string"><span class="meta">private:</span></span></span><br><span class="line"><span class="string"><span class="meta">    std::vector&lt;Channel&gt; _channel;</span></span></span><br><span class="line"><span class="string"><span class="meta">    int _index;</span></span></span><br><span class="line"><span class="string"><span class="meta">&#125;;</span></span></span><br><span class="line"><span class="string"><span class="meta"></span></span></span><br><span class="line"><span class="string"><span class="meta">class ProcessPool</span></span></span><br><span class="line"><span class="string"><span class="meta">&#123;</span></span></span><br><span class="line"><span class="string"><span class="meta">public:</span></span></span><br><span class="line"><span class="string"><span class="meta">    ProcessPool(int num = _PROCESS_NUM) : _num(num) &#123;&#125;</span></span></span><br><span class="line"><span class="string"><span class="meta">    void Initial()</span></span></span><br><span class="line"><span class="string"><span class="meta">    &#123;</span></span></span><br><span class="line"><span class="string"><span class="meta">        for (int i = 0; i &lt; _num; i++)</span></span></span><br><span class="line"><span class="string"><span class="meta">        &#123;</span></span></span><br><span class="line"><span class="string"><span class="meta">            int pipe_fd[2] = &#123;0&#125;;</span></span></span><br><span class="line"><span class="string"><span class="meta">            int pipe_ret = pipe(pipe_fd);</span></span></span><br><span class="line"><span class="string"><span class="meta">            if (pipe_ret &lt; 0)</span></span></span><br><span class="line"><span class="string"><span class="meta">            &#123;</span></span></span><br><span class="line"><span class="string"><span class="meta">                _ERROE(&quot;</span>Pipe <span class="keyword">error</span><span class="string">&quot;)</span></span></span><br><span class="line"><span class="string"><span class="meta">            &#125;</span></span></span><br><span class="line"><span class="string"><span class="meta">            // 创建子进程</span></span></span><br><span class="line"><span class="string"><span class="meta">            pid_t pid = fork();</span></span></span><br><span class="line"><span class="string"><span class="meta">            if (pid &lt; 0)</span></span></span><br><span class="line"><span class="string"><span class="meta">            &#123;</span></span></span><br><span class="line"><span class="string"><span class="meta">                _ERROE(&quot;</span>Fork <span class="keyword">error</span><span class="string">&quot;);</span></span></span><br><span class="line"><span class="string"><span class="meta">                continue;</span></span></span><br><span class="line"><span class="string"><span class="meta">            &#125;</span></span></span><br><span class="line"><span class="string"><span class="meta">            else if (pid == 0)</span></span></span><br><span class="line"><span class="string"><span class="meta">            &#123;</span></span></span><br><span class="line"><span class="string"><span class="meta">                // child-&gt;read</span></span></span><br><span class="line"><span class="string"><span class="meta">                close(pipe_fd[1]);</span></span></span><br><span class="line"><span class="string"><span class="meta">                // 持续监听父进程是否写入</span></span></span><br><span class="line"><span class="string"><span class="meta">                ChildWork(pipe_fd[0]);</span></span></span><br><span class="line"><span class="string"><span class="meta">                exit(0);</span></span></span><br><span class="line"><span class="string"><span class="meta">            &#125;</span></span></span><br><span class="line"><span class="string"><span class="meta">            // parent-&gt;write</span></span></span><br><span class="line"><span class="string"><span class="meta">            else</span></span></span><br><span class="line"><span class="string"><span class="meta">            &#123;</span></span></span><br><span class="line"><span class="string"><span class="meta">                close(pipe_fd[0]);</span></span></span><br><span class="line"><span class="string"><span class="meta">                _cm.InsertChannel(pid, getpid(), pipe_fd[1]);</span></span></span><br><span class="line"><span class="string"><span class="meta">            &#125;</span></span></span><br><span class="line"><span class="string"><span class="meta">        &#125;</span></span></span><br><span class="line"><span class="string"><span class="meta">        return;</span></span></span><br><span class="line"><span class="string"><span class="meta">    &#125;</span></span></span><br><span class="line"><span class="string"><span class="meta">    void AssignTask(int task_code)</span></span></span><br><span class="line"><span class="string"><span class="meta">    &#123;</span></span></span><br><span class="line"><span class="string"><span class="meta">        if (task_code &lt; 0)</span></span></span><br><span class="line"><span class="string"><span class="meta">        &#123;</span></span></span><br><span class="line"><span class="string"><span class="meta">            std::cout &lt;&lt; &quot;</span>Invalid task code<span class="string">&quot; &lt;&lt; std::endl;</span></span></span><br><span class="line"><span class="string"><span class="meta">            return;</span></span></span><br><span class="line"><span class="string"><span class="meta">        &#125;</span></span></span><br><span class="line"><span class="string"><span class="meta">        else</span></span></span><br><span class="line"><span class="string"><span class="meta">        &#123;</span></span></span><br><span class="line"><span class="string"><span class="meta">            auto ch = _cm.SelectChannel();</span></span></span><br><span class="line"><span class="string"><span class="meta">            ch.SendTaskCode(task_code);</span></span></span><br><span class="line"><span class="string"><span class="meta">        &#125;</span></span></span><br><span class="line"><span class="string"><span class="meta">    &#125;</span></span></span><br><span class="line"><span class="string"><span class="meta">    void Stop()</span></span></span><br><span class="line"><span class="string"><span class="meta">    &#123;</span></span></span><br><span class="line"><span class="string"><span class="meta">        _cm.CloseAll();</span></span></span><br><span class="line"><span class="string"><span class="meta">        _cm.WaitAll();</span></span></span><br><span class="line"><span class="string"><span class="meta">    &#125;</span></span></span><br><span class="line"><span class="string"><span class="meta">    void DeBug()</span></span></span><br><span class="line"><span class="string"><span class="meta">    &#123;</span></span></span><br><span class="line"><span class="string"><span class="meta">        _cm.PrintChannel();</span></span></span><br><span class="line"><span class="string"><span class="meta">    &#125;</span></span></span><br><span class="line"><span class="string"><span class="meta">    ~ProcessPool() &#123;&#125;</span></span></span><br><span class="line"><span class="string"><span class="meta">private:</span></span></span><br><span class="line"><span class="string"><span class="meta">    void ExecuteTask(int task_code)</span></span></span><br><span class="line"><span class="string"><span class="meta">    &#123;</span></span></span><br><span class="line"><span class="string"><span class="meta">        _tm.Execute(task_code);</span></span></span><br><span class="line"><span class="string"><span class="meta">    &#125;</span></span></span><br><span class="line"><span class="string"><span class="meta">    void ChildWork(int fd)</span></span></span><br><span class="line"><span class="string"><span class="meta">    &#123;</span></span></span><br><span class="line"><span class="string"><span class="meta">        while (true)</span></span></span><br><span class="line"><span class="string"><span class="meta">        &#123;</span></span></span><br><span class="line"><span class="string"><span class="meta">            int task_code = 0;</span></span></span><br><span class="line"><span class="string"><span class="meta">            ssize_t r = read(fd, &amp;task_code, sizeof(task_code));</span></span></span><br><span class="line"><span class="string"><span class="meta">            if (r &gt; 0)</span></span></span><br><span class="line"><span class="string"><span class="meta">            &#123;</span></span></span><br><span class="line"><span class="string"><span class="meta">                std::cout &lt;&lt; &quot;</span>Child[<span class="string">&quot; &lt;&lt; getpid() &lt;&lt; &quot;</span>]<span class="string">&lt;&quot; &lt;&lt; fd &lt;&lt; &quot;&gt;</span><span class="string">&quot; &lt;&lt; &quot;</span>get a task <span class="string">&quot; &lt;&lt; task_code &lt;&lt; std::endl;</span></span></span><br><span class="line"><span class="string"><span class="meta">                ExecuteTask(task_code);</span></span></span><br><span class="line"><span class="string"><span class="meta">            &#125;</span></span></span><br><span class="line"><span class="string"><span class="meta">            else if (r == 0)</span></span></span><br><span class="line"><span class="string"><span class="meta">            &#123;</span></span></span><br><span class="line"><span class="string"><span class="meta">                std::cout &lt;&lt; &quot;</span>Child exited <span class="string">&lt;&quot; &lt;&lt; getpid() &lt;&lt; &quot;&gt;</span><span class="string">&quot; &lt;&lt; std::endl;</span></span></span><br><span class="line"><span class="string"><span class="meta">                break;</span></span></span><br><span class="line"><span class="string"><span class="meta">            &#125;</span></span></span><br><span class="line"><span class="string"><span class="meta">            else</span></span></span><br><span class="line"><span class="string"><span class="meta">            &#123;</span></span></span><br><span class="line"><span class="string"><span class="meta">                _ERROE(&quot;</span>Read <span class="keyword">error</span><span class="string">&quot;);</span></span></span><br><span class="line"><span class="string"><span class="meta">                break;</span></span></span><br><span class="line"><span class="string"><span class="meta">            &#125;</span></span></span><br><span class="line"><span class="string"><span class="meta">        &#125;</span></span></span><br><span class="line"><span class="string"><span class="meta">    &#125;</span></span></span><br><span class="line"><span class="string"><span class="meta">    ChannelManager _cm;</span></span></span><br><span class="line"><span class="string"><span class="meta">    TaskManger _tm;</span></span></span><br><span class="line"><span class="string"><span class="meta">    int _num;</span></span></span><br><span class="line"><span class="string"><span class="meta">&#125;;</span></span></span><br><span class="line"><span class="string"><span class="meta"></span></span></span><br><span class="line"><span class="string"><span class="meta">#endif</span></span></span><br></pre></td></tr></table></figure>
<p>通过下面的任务模拟子进程的工作</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Task.hpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;vector&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">Task</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">Task</span>(std::string str)</span><br><span class="line">    &#123;</span><br><span class="line">        _name = str;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Work</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;This is a &quot;</span> &lt;&lt; _name &lt;&lt; <span class="string">&quot; task&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Start working\n&quot;</span></span><br><span class="line">                  &lt;&lt; <span class="string">&quot;……&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Finish work!\n&quot;</span></span><br><span class="line">                  &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">Task</span>() &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string _name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">TaskManger</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">TaskManger</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">auto</span> str : _task_list)</span><br><span class="line">        &#123;</span><br><span class="line">            _tasks.<span class="built_in">emplace_back</span>(str);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">srand</span>(<span class="built_in">time</span>(<span class="literal">nullptr</span>));</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Execute</span><span class="params">(<span class="type">int</span> task_code)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        _tasks[task_code % _tasks.<span class="built_in">size</span>()].<span class="built_in">Work</span>();</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::vector&lt;std::string&gt; _task_list = &#123;<span class="string">&quot;Print&quot;</span>, <span class="string">&quot;UpLoad&quot;</span>, <span class="string">&quot;DownLoad&quot;</span>, <span class="string">&quot;Log&quot;</span>, <span class="string">&quot;Error&quot;</span>&#125;;</span><br><span class="line">    std::vector&lt;Task&gt; _tasks;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;ProcessPool.hpp&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    ProcessPool pool;</span><br><span class="line">    pool.<span class="built_in">Initial</span>();</span><br><span class="line">    <span class="comment">// pool.DeBug();</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="number">4</span>; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        pool.<span class="built_in">AssignTask</span>(i);</span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">2</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    pool.<span class="built_in">Stop</span>();</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>运行一下发现，进程池可以正常运行，也能够执行分配的工作</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">$ ./prcess_pool </span><br><span class="line">Child[290317]&lt;3&gt;get a task 0</span><br><span class="line">This is a Print task</span><br><span class="line">Start working</span><br><span class="line">……</span><br><span class="line">Finish work!</span><br><span class="line"></span><br><span class="line">Child[290318]&lt;3&gt;get a task 1</span><br><span class="line">This is a UpLoad task</span><br><span class="line">Start working</span><br><span class="line">……</span><br><span class="line">Finish work!</span><br><span class="line"></span><br><span class="line">Child[290319]&lt;3&gt;get a task 2</span><br><span class="line">This is a DownLoad task</span><br><span class="line">Start working</span><br><span class="line">……</span><br><span class="line">Finish work!</span><br><span class="line"></span><br><span class="line">Child[290320]&lt;3&gt;get a task 3</span><br><span class="line">This is a Log task</span><br><span class="line">Start working</span><br><span class="line">……</span><br><span class="line">Finish work!</span><br><span class="line"></span><br><span class="line">Child exited &lt;290322&gt;</span><br><span class="line">Child exited &lt;290321&gt;</span><br><span class="line">Child exited &lt;290320&gt;</span><br><span class="line">Child exited &lt;290319&gt;</span><br><span class="line">Child exited &lt;290318&gt;</span><br><span class="line">Child exited &lt;290317&gt;</span><br></pre></td></tr></table></figure>
<p>我们的 <code>Stop()</code> 函数中分别调用 <code>CloseAll</code> 和 <code>WaitAll</code>，何不尝试把两个函数写在一起</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//……</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">CloseAndWait</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">auto</span> &amp;c : _channel)</span><br><span class="line">    &#123;</span><br><span class="line">        c.<span class="built_in">Close</span>();</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Close &quot;</span> &lt;&lt; c.<span class="built_in">GetName</span>() &lt;&lt; std::endl;</span><br><span class="line">        c.<span class="built_in">ParentWait</span>();</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Wait success &quot;</span> &lt;&lt; c.<span class="built_in">GetName</span>() &lt;&lt; std::endl</span><br><span class="line">                    &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//……</span></span><br><span class="line"><span class="function"><span class="type">void</span> <span class="title">Stop</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    _cm.<span class="built_in">CloseAndWait</span>();</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">//……</span></span><br></pre></td></tr></table></figure>
<p>这样看起来就整洁和舒服多了，但是再次运行发现进程会阻塞住，无法正常退出</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">$ ./prcess_pool </span><br><span class="line">Child[291404]&lt;3&gt;get a task 0</span><br><span class="line">This is a Print task</span><br><span class="line">Start working</span><br><span class="line">……</span><br><span class="line">Finish work!</span><br><span class="line"></span><br><span class="line">Child[291405]&lt;3&gt;get a task 1</span><br><span class="line">This is a UpLoad task</span><br><span class="line">Start working</span><br><span class="line">……</span><br><span class="line">Finish work!</span><br><span class="line"></span><br><span class="line">Child[291406]&lt;3&gt;get a task 2</span><br><span class="line">This is a DownLoad task</span><br><span class="line">Start working</span><br><span class="line">……</span><br><span class="line">Finish work!</span><br><span class="line"></span><br><span class="line">Child[291407]&lt;3&gt;get a task 3</span><br><span class="line">This is a Log task</span><br><span class="line">Start working</span><br><span class="line">……</span><br><span class="line">Finish work!</span><br><span class="line"></span><br><span class="line">Close Channel&lt;4&gt;[291404]</span><br><span class="line"></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<blockquote>
<p>在使用 fork + pipe 创建多进程任务池时，文件描述符管理若不谨慎，容易出现隐藏的阻塞 bug</p>
</blockquote>
<blockquote>
<p>解决方法是：<strong>在子进程中关闭所有不属于自己的文件描述符</strong> —— 这正是我们后文将探讨的重点</p>
</blockquote>
<p>这是为什么呢？下面用一张图说明问题所在</p>
<!-- ![1750076522045](image/进程间通信/1750076522045.png) -->
<img src="/2025/11/24/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/1750076522045.png" class="">
<p>在 <code>fork</code> 的时候，子进程拷贝自父进程，<code>pipe</code> 本质也是打开文件，通过输出型参数控制文件描述符读和写</p>
<ul>
<li>第一次 <code>pipe</code> 创建的读写文件描述符是 <code>pipe_fd[0]=3</code>, <code>pipe_fd[1]=4</code>，父进程关闭 <code>3</code>，子进程关闭 <code>4</code>，一切正常</li>
<li>但第二次 <code>fork</code> 时，父进程中已经打开了上一个子进程的 <code>pipe_fd[1]=4</code>，再创建一组新的 <code>pipe_fd[0]=5, pipe_fd[1]=6</code><ul>
<li>此时，子进程继承了 fd <code>4</code>, <code>5</code>, <code>6</code></li>
<li>它虽然关闭了 <code>6</code>，但却无意中持有了 <strong>不属于自己的 <code>fd = 4</code>（上一轮写端）</strong></li>
</ul>
</li>
<li>随着子进程增多，这种“额外持有的 FD”越来越多</li>
<li>问题出现在管道读端的 <strong><code>EOF</code> 检测机制</strong> 上：<ul>
<li>当某个子进程尝试关闭自己使用的 <code>read fd</code> 时，理论上应当触发 <code>read() == 0</code></li>
<li>但实际上，由于<strong>其他子进程还持有这个管道的写端 <code>fd</code></strong>，内核认为管道仍“活着”，所以 <code>read()</code> 永远不会返回 <code>EOF</code></li>
</ul>
</li>
<li>这就会导致：<ul>
<li>子进程 <strong>卡死在 <code>read()</code></strong></li>
<li>父进程 <strong>卡死在 <code>waitpid()</code></strong><blockquote>
<p>问题的根源是：<strong>子进程继承了不属于它的文件描述符，且未关闭</strong></p>
</blockquote>
</li>
</ul>
</li>
</ul>
<p>最简单的方法就是通过逆序释放并退出的方法回收子进程</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">CloseAndWait</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="comment">// 逆序关闭打开的进程</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = _channel.<span class="built_in">size</span>() - <span class="number">1</span>; i &gt;= <span class="number">0</span>; i--)</span><br><span class="line">    &#123;</span><br><span class="line">        _channel[i].<span class="built_in">Close</span>();</span><br><span class="line">        _channel[i].<span class="built_in">ParentWait</span>();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>此时子进程就可以正常退出了</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">$ ./prcess_pool </span><br><span class="line">Child[293641]&lt;3&gt;get a task 0</span><br><span class="line">This is a Print task</span><br><span class="line">Start working</span><br><span class="line">……</span><br><span class="line">Finish work!</span><br><span class="line"></span><br><span class="line">Child[293642]&lt;3&gt;get a task 1</span><br><span class="line">This is a UpLoad task</span><br><span class="line">Start working</span><br><span class="line">……</span><br><span class="line">Finish work!</span><br><span class="line"></span><br><span class="line">Child[293643]&lt;3&gt;get a task 2</span><br><span class="line">This is a DownLoad task</span><br><span class="line">Start working</span><br><span class="line">……</span><br><span class="line">Finish work!</span><br><span class="line"></span><br><span class="line">Child[293644]&lt;3&gt;get a task 3</span><br><span class="line">This is a Log task</span><br><span class="line">Start working</span><br><span class="line">……</span><br><span class="line">Finish work!</span><br><span class="line"></span><br><span class="line">Close Channel&lt;9&gt;[293646]</span><br><span class="line">Child exited &lt;293646&gt;</span><br><span class="line">Wait success Channel&lt;9&gt;[293646]</span><br><span class="line">Close Channel&lt;8&gt;[293645]</span><br><span class="line">Child exited &lt;293645&gt;</span><br><span class="line">Wait success Channel&lt;8&gt;[293645]</span><br><span class="line">Child exited &lt;293644&gt;</span><br><span class="line">Close Channel&lt;7&gt;[293644]</span><br><span class="line">Wait success Channel&lt;7&gt;[293644]</span><br><span class="line">Close Channel&lt;6&gt;[293643]</span><br><span class="line">Child exited &lt;293643&gt;</span><br><span class="line">Wait success Channel&lt;6&gt;[293643]</span><br><span class="line">Close Channel&lt;5&gt;[293642]</span><br><span class="line">Child exited &lt;293642&gt;</span><br><span class="line">Wait success Channel&lt;5&gt;[293642]</span><br><span class="line">Child exited &lt;293641&gt;</span><br><span class="line">Close Channel&lt;4&gt;[293641]</span><br><span class="line">Wait success Channel&lt;4&gt;[293641]</span><br></pre></td></tr></table></figure>
<p>但是这样并没有从根本上解决问题，除了第一个子进程外，<strong>其余子进程仍然继承了不属于它的文件描述符</strong></p>
<!-- ![1750079469897](image/进程间通信/1750079469897.png) -->
<img src="/2025/11/24/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/1750079469897.png" class="">
<p>可不可以直接<strong>让每个子进程只拥有自己需要的文件描述符</strong>呢？答案是当然可以只需要在创建子进程的时候关闭所有的文件描述符即可</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="type">void</span> <span class="title">Initial</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; _num; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> pipe_fd[<span class="number">2</span>] = &#123;<span class="number">0</span>&#125;;</span><br><span class="line">        <span class="type">int</span> pipe_ret = <span class="built_in">pipe</span>(pipe_fd);</span><br><span class="line">        <span class="keyword">if</span> (pipe_ret &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            _ERROE(<span class="string">&quot;Pipe error&quot;</span>)</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 创建子进程</span></span><br><span class="line">        <span class="type">pid_t</span> pid = fork();</span><br><span class="line">        <span class="keyword">if</span> (pid &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            _ERROE(<span class="string">&quot;Fork error&quot;</span>);</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="comment">// 关闭多余的文件描述符</span></span><br><span class="line">            _cm.<span class="built_in">CloseAll</span>();</span><br><span class="line">            <span class="comment">// child-&gt;read</span></span><br><span class="line">            <span class="built_in">close</span>(pipe_fd[<span class="number">1</span>]);</span><br><span class="line">            <span class="comment">// 持续监听父进程是否写入</span></span><br><span class="line">            <span class="built_in">ChildWork</span>(pipe_fd[<span class="number">0</span>]);</span><br><span class="line">            <span class="built_in">exit</span>(<span class="number">0</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// parent-&gt;write</span></span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">close</span>(pipe_fd[<span class="number">0</span>]);</span><br><span class="line">            _cm.<span class="built_in">InsertChannel</span>(pid, <span class="built_in">getpid</span>(), pipe_fd[<span class="number">1</span>]);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>同样的可以正常退出</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">$ ./prcess_pool </span><br><span class="line">Child[293835]&lt;3&gt;get a task 0</span><br><span class="line">This is a Print task</span><br><span class="line">Start working</span><br><span class="line">……</span><br><span class="line">Finish work!</span><br><span class="line"></span><br><span class="line">Child[293836]&lt;3&gt;get a task 1</span><br><span class="line">This is a UpLoad task</span><br><span class="line">Start working</span><br><span class="line">……</span><br><span class="line">Finish work!</span><br><span class="line"></span><br><span class="line">Child[293837]&lt;3&gt;get a task 2</span><br><span class="line">This is a DownLoad task</span><br><span class="line">Start working</span><br><span class="line">……</span><br><span class="line">Finish work!</span><br><span class="line"></span><br><span class="line">Child[293838]&lt;3&gt;get a task 3</span><br><span class="line">This is a Log task</span><br><span class="line">Start working</span><br><span class="line">……</span><br><span class="line">Finish work!</span><br><span class="line"></span><br><span class="line">Close Channel&lt;4&gt;[293835]</span><br><span class="line">Child exited &lt;293835&gt;</span><br><span class="line">Wait success Channel&lt;4&gt;[293835]</span><br><span class="line">Close Channel&lt;5&gt;[293836]</span><br><span class="line">Child exited &lt;293836&gt;</span><br><span class="line">Wait success Channel&lt;5&gt;[293836]</span><br><span class="line">Child exited &lt;293837&gt;</span><br><span class="line">Close Channel&lt;6&gt;[293837]</span><br><span class="line">Wait success Channel&lt;6&gt;[293837]</span><br><span class="line">Child exited &lt;293838&gt;</span><br><span class="line">Close Channel&lt;7&gt;[293838]</span><br><span class="line">Wait success Channel&lt;7&gt;[293838]</span><br><span class="line">Close Channel&lt;8&gt;[293839]</span><br><span class="line">Child exited &lt;293839&gt;</span><br><span class="line">Wait success Channel&lt;8&gt;[293839]</span><br><span class="line">Close Channel&lt;9&gt;[293840]</span><br><span class="line">Child exited &lt;293840&gt;</span><br><span class="line">Wait success Channel&lt;9&gt;[293840]</span><br></pre></td></tr></table></figure>
<p>其实在这里在处理 <code>fork</code> 多个子进程、并通过管道通信的场景中，可以总结出一个典型的问题：<strong>子进程为什么可以安全地关闭不需要的文件描述符，而不会误关自己真正需要的那一端？</strong></p>
<p>💡 <strong>一个关键的理解视角是：</strong><br><strong>将继承下来的文件描述符从用途上分为两类：</strong></p>
<ul>
<li><strong>写端</strong>：通常是父进程用于向子进程发送数据的端口。子进程不需要这部分，因此在 <code>fork</code> 后立刻关闭</li>
<li><strong>读端</strong>：这是子进程用于接收数据的端口，父进程不会再使用，<code>fork</code> 后立即关闭</li>
</ul>
<p><strong>那么为什么子进程执行 <code>CloseAll()</code> 时不会错误关闭自己真正需要的 <code>FD</code> 呢？</strong><br>关键在于两个机制的<strong>协同作用</strong>：</p>
<ol>
<li><strong>结构设计：</strong></li>
</ol>
<ul>
<li>父进程维护一个 <code>std::vector&lt;Channel&gt;</code>（简称 <code>_cm</code>），存储的是<strong>所有子进程的写端 <code>FD</code></strong></li>
<li>子进程继承了这个 <code>vector</code>，但它并不需要这些写端 <code>FD</code></li>
</ul>
<p>于是子进程在 <code>CloseAll()</code> 中关闭 <code>vector</code> 里的全部 <code>FD</code>，<strong>正好是它不需要的那一部分</strong></p>
<ol start="2">
<li><strong>写时拷贝机制（COW）在其中的作用：</strong></li>
</ol>
<ul>
<li>子进程调用 <code>CloseAll()</code> 时，会修改 <code>_cm</code>（比如 <code>clear()</code> 或 <code>erase()</code>）</li>
<li>这个写操作触发 <code>COW</code>，<strong>让子进程获得 <code>_cm</code> 的独立副本</strong></li>
<li>后续父进程再对 <code>_cm</code> 进行 <code>InsertChannel()</code> 等操作时，<strong>不会影响子进程已分离的副本</strong></li>
<li>反之也成立：子进程在关闭和清空时，<strong>不会破坏父进程中保留的写端 <code>FD</code></strong></li>
</ul>
<p>所以，<strong>COW 起到的作用不是保留子进程的读端，而是保护父进程的写端不受干扰</strong></p>
<p>⚠️需要注意的是，<code>fork</code> 后父子进程的执行是并发的，所以理论上存在一个<strong>竞争窗口</strong>：</p>
<ul>
<li>如果子进程执行得太快，在父进程还未完成 <code>InsertChannel()</code> 操作之前就执行了 <code>CloseAll()</code>，可能会造成一些 <code>FD</code> 被遗漏</li>
</ul>
<p>但这属于调度与同步层面的问题，可通过额外同步机制（如 <code>pipe</code>&#x2F;信号&#x2F;锁）解决，本文不展开</p>
<p><strong>总结</strong><br>首先，在子进程继承自父进程的时候，以这样的视角看待将继承下来的文件描述符分为写端和读端，写端是父进程需要的，所以子进程不需要，关闭即可(且是单独关闭的)，读端是子进程需要的，父进程关闭即可(同样是单独关闭的)。<br>子进程继承的所有写端文件描述符都放在父进程管理子进程的 <code>vector</code> 中，所以子进程在关闭所有的 <code>vector</code> 中的文件描述符的时候，不会关闭到自己需要的写端文件描述符<br>同时 <code>COW</code> 起到了分流的作用，但是这个作用是保护父进程需要的写端文件描述符不受子进程 <code>CloseAll</code> 的影响，在 <code>InsertChannel</code> 的时候，父进程对 <code>_cm</code> 进行修改操作，此时触发 <code>COW</code>，父子进程就属于不同的执行流，子进程在 <code>CloseAll</code> 的时候就不会影响到父进程</p>
<h3 id="4-命名管道"><a href="#4-命名管道" class="headerlink" title="4. 命名管道"></a>4. 命名管道</h3><h4 id="4-1-基本概念"><a href="#4-1-基本概念" class="headerlink" title="4.1 基本概念"></a>4.1 基本概念</h4><p>在不同的进程之间交换数据，可以使用 <code>FIFO</code> 文件来做这项工作，其也经常被称为命名管道</p>
<ul>
<li>命名管道是一种特殊类型的文件</li>
</ul>
<h4 id="4-2-创建命名管道"><a href="#4-2-创建命名管道" class="headerlink" title="4.2 创建命名管道"></a>4.2 创建命名管道</h4><ul>
<li>命名管道可以在命令行上创建，如下<br>  <code>mkfifo filename</code></li>
<li>命名管道也可以从程序里创建，如下<br>  <code>int mkfifo(const char *pathname, mode_t mode);</code></li>
</ul>
<h4 id="4-3-匿名管道-VS-命名管道"><a href="#4-3-匿名管道-VS-命名管道" class="headerlink" title="4.3 匿名管道 VS 命名管道"></a>4.3 匿名管道 VS 命名管道</h4><table>
<thead>
<tr>
<th align="left">特性</th>
<th align="left">命名管道 (Named Pipe &#x2F; FIFO)</th>
<th align="left">匿名管道 (Anonymous Pipe)</th>
</tr>
</thead>
<tbody><tr>
<td align="left"><strong>可见性</strong></td>
<td align="left">文件系统中有路径名</td>
<td align="left">仅存在于内核，无文件系统路径</td>
</tr>
<tr>
<td align="left"><strong>进程关系</strong></td>
<td align="left">任意进程（只要知道名称且有权限）</td>
<td align="left">必须有父子&#x2F;兄弟关系（通过 <code>fork</code> 继承）</td>
</tr>
<tr>
<td align="left"><strong>持久性</strong></td>
<td align="left">名称在进程结束后可保留（直到显式删除）</td>
<td align="left">随创建它的进程结束而销毁</td>
</tr>
<tr>
<td align="left"><strong>创建方式</strong></td>
<td align="left"><code>mkfifo()</code> &#x2F; <code>mknod()</code> (<code>Unix</code>), <code>CreateNamedPipe()</code> (<code>Win</code>)</td>
<td align="left"><code>pipe()</code> 系统调用</td>
</tr>
</tbody></table>
<h4 id="4-4-命名管道打开规则"><a href="#4-4-命名管道打开规则" class="headerlink" title="4.4 命名管道打开规则"></a>4.4 命名管道打开规则</h4><ul>
<li>如果当前打开操作是为读而打开 <code>FIFO</code> 时<ul>
<li><code>O_NONBLOCK disable</code>：阻塞直到有相应进程为写而打开该 <code>FIFO</code></li>
<li><code>O_NONBLOCK enable</code>：立刻返回成功</li>
</ul>
</li>
<li>如果当前操作是为写而打开该 <code>FIFO</code><ul>
<li><code>O_NONBLOCK disable</code>：阻塞直到有相应进程为读而打开该 <code>FIFO</code></li>
<li><code>O_NONBLOCK enable</code>：立刻返回失败，错误码为 <code>ENXIO</code></li>
</ul>
</li>
</ul>
<h4 id="4-5-命名管道实现文件拷贝"><a href="#4-5-命名管道实现文件拷贝" class="headerlink" title="4.5 命名管道实现文件拷贝"></a>4.5 命名管道实现文件拷贝</h4><p><code>writer</code> 负责创建命名管道并打开，并将源文件写入命名管道</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// writer.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cerrno&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _ERROR(msg)                                                                                   \</span></span><br><span class="line"><span class="meta">    do                                                                                                \</span></span><br><span class="line"><span class="meta">    &#123;                                                                                                 \</span></span><br><span class="line"><span class="meta">        std::cerr <span class="string">&lt;&lt; &quot;ERROR:&lt;&quot; &lt;&lt; msg &lt;&lt; &quot;&gt;</span>:<span class="string">&quot; &lt;&lt; strerror(errno) &lt;&lt; &quot;</span>(<span class="string">&quot; &lt;&lt; errno &lt;&lt; &quot;</span>)<span class="string">&quot; &lt;&lt; std::endl; \</span></span></span><br><span class="line"><span class="string"><span class="meta">        exit(1);                                                                                      \</span></span></span><br><span class="line"><span class="string"><span class="meta">    &#125; while (0)</span></span></span><br><span class="line"><span class="string"><span class="meta"></span></span></span><br><span class="line"><span class="string"><span class="meta">int main()</span></span></span><br><span class="line"><span class="string"><span class="meta">&#123;</span></span></span><br><span class="line"><span class="string"><span class="meta">    umask(0);</span></span></span><br><span class="line"><span class="string"><span class="meta">    // 创建命名管道文件</span></span></span><br><span class="line"><span class="string"><span class="meta">    int n_mkfifo = mkfifo(&quot;</span>tmp<span class="string">&quot;, 0666);</span></span></span><br><span class="line"><span class="string"><span class="meta">    if (n_mkfifo &lt; 0)</span></span></span><br><span class="line"><span class="string"><span class="meta">    &#123;</span></span></span><br><span class="line"><span class="string"><span class="meta">        _ERROR(&quot;</span>mkfifo<span class="string">&quot;);</span></span></span><br><span class="line"><span class="string"><span class="meta">    &#125;</span></span></span><br><span class="line"><span class="string"><span class="meta">    std::cout &lt;&lt; &quot;</span>mkfifo success!<span class="string">&quot; &lt;&lt; std::endl;</span></span></span><br><span class="line"><span class="string"><span class="meta">    // 打开管道文件</span></span></span><br><span class="line"><span class="string"><span class="meta">    std::cout &lt;&lt; &quot;</span>Reader connecting……<span class="string">&quot; &lt;&lt; std::endl;</span></span></span><br><span class="line"><span class="string"><span class="meta">    int output = open(&quot;</span>tmp<span class="string">&quot;, O_WRONLY);</span></span></span><br><span class="line"><span class="string"><span class="meta">    std::cout &lt;&lt; &quot;</span>Connected!<span class="string">&quot; &lt;&lt; std::endl;</span></span></span><br><span class="line"><span class="string"><span class="meta">    // 读取源文件</span></span></span><br><span class="line"><span class="string"><span class="meta">    int input = open(&quot;</span>source.txt<span class="string">&quot;, O_RDONLY);</span></span></span><br><span class="line"><span class="string"><span class="meta">    if (input &lt; 0 || output &lt; 0)</span></span></span><br><span class="line"><span class="string"><span class="meta">    &#123;</span></span></span><br><span class="line"><span class="string"><span class="meta">        _ERROR(&quot;</span>open<span class="string">&quot;);</span></span></span><br><span class="line"><span class="string"><span class="meta">    &#125;</span></span></span><br><span class="line"><span class="string"><span class="meta">    char buffer[1024] = &#123;&quot;</span>0<span class="string">&quot;&#125;;</span></span></span><br><span class="line"><span class="string"><span class="meta">    ssize_t bytes_read = 0;</span></span></span><br><span class="line"><span class="string"><span class="meta">    while ((bytes_read = read(input, buffer, sizeof(buffer))))</span></span></span><br><span class="line"><span class="string"><span class="meta">    &#123;</span></span></span><br><span class="line"><span class="string"><span class="meta">        if (bytes_read &lt; 0)</span></span></span><br><span class="line"><span class="string"><span class="meta">        &#123;</span></span></span><br><span class="line"><span class="string"><span class="meta">            _ERROR(&quot;</span>read<span class="string">&quot;);</span></span></span><br><span class="line"><span class="string"><span class="meta">            break;</span></span></span><br><span class="line"><span class="string"><span class="meta">        &#125;</span></span></span><br><span class="line"><span class="string"><span class="meta">        ssize_t n_write = write(output, buffer, bytes_read);</span></span></span><br><span class="line"><span class="string"><span class="meta">        if (n_write &lt; 0)</span></span></span><br><span class="line"><span class="string"><span class="meta">        &#123;</span></span></span><br><span class="line"><span class="string"><span class="meta">            _ERROR(&quot;</span>write<span class="string">&quot;);</span></span></span><br><span class="line"><span class="string"><span class="meta">            break;</span></span></span><br><span class="line"><span class="string"><span class="meta">        &#125;</span></span></span><br><span class="line"><span class="string"><span class="meta">        buffer[sizeof(buffer) - 1] = 0;</span></span></span><br><span class="line"><span class="string"><span class="meta">    &#125;</span></span></span><br><span class="line"><span class="string"><span class="meta">    std::cout &lt;&lt; &quot;</span>over!<span class="string">&quot; &lt;&lt; std::endl;</span></span></span><br><span class="line"><span class="string"><span class="meta">    close(input);</span></span></span><br><span class="line"><span class="string"><span class="meta">    close(output);</span></span></span><br><span class="line"><span class="string"><span class="meta">    return 0;</span></span></span><br><span class="line"><span class="string"><span class="meta">&#125;</span></span></span><br></pre></td></tr></table></figure>
<p><code>reader</code> 负责打开备份文件，并将管道中的内容写入备份文件中</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// reder.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdlib&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cerrno&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _ERROR(msg)                                                                                   \</span></span><br><span class="line"><span class="meta">    do                                                                                                \</span></span><br><span class="line"><span class="meta">    &#123;                                                                                                 \</span></span><br><span class="line"><span class="meta">        std::cerr <span class="string">&lt;&lt; &quot;ERROR:&lt;&quot; &lt;&lt; msg &lt;&lt; &quot;&gt;</span>:<span class="string">&quot; &lt;&lt; strerror(errno) &lt;&lt; &quot;</span>(<span class="string">&quot; &lt;&lt; errno &lt;&lt; &quot;</span>)<span class="string">&quot; &lt;&lt; std::endl; \</span></span></span><br><span class="line"><span class="string"><span class="meta">        exit(1);                                                                                      \</span></span></span><br><span class="line"><span class="string"><span class="meta">    &#125; while (0)</span></span></span><br><span class="line"><span class="string"><span class="meta"></span></span></span><br><span class="line"><span class="string"><span class="meta">int main()</span></span></span><br><span class="line"><span class="string"><span class="meta">&#123;</span></span></span><br><span class="line"><span class="string"><span class="meta">    sleep(5);</span></span></span><br><span class="line"><span class="string"><span class="meta">    umask(0);</span></span></span><br><span class="line"><span class="string"><span class="meta">    // 打开备份文件</span></span></span><br><span class="line"><span class="string"><span class="meta">    int output = open(&quot;</span>backup.bak<span class="string">&quot;, O_WRONLY | O_CREAT | O_TRUNC, 0666);</span></span></span><br><span class="line"><span class="string"><span class="meta">    // 打开管道</span></span></span><br><span class="line"><span class="string"><span class="meta">    int input = open(&quot;</span>tmp<span class="string">&quot;, O_RDONLY);</span></span></span><br><span class="line"><span class="string"><span class="meta">    if (input &lt; 0 || output &lt; 0)</span></span></span><br><span class="line"><span class="string"><span class="meta">    &#123;</span></span></span><br><span class="line"><span class="string"><span class="meta">        _ERROR(&quot;</span>open<span class="string">&quot;);</span></span></span><br><span class="line"><span class="string"><span class="meta">    &#125;</span></span></span><br><span class="line"><span class="string"><span class="meta">    char buffer[1024] = &#123;&quot;</span>0<span class="string">&quot;&#125;;</span></span></span><br><span class="line"><span class="string"><span class="meta">    ssize_t bytes_read = 0;</span></span></span><br><span class="line"><span class="string"><span class="meta">    while ((bytes_read = read(input, buffer, sizeof(buffer))))</span></span></span><br><span class="line"><span class="string"><span class="meta">    &#123;</span></span></span><br><span class="line"><span class="string"><span class="meta">        if (bytes_read &lt; 0)</span></span></span><br><span class="line"><span class="string"><span class="meta">        &#123;</span></span></span><br><span class="line"><span class="string"><span class="meta">            _ERROR(&quot;</span>read<span class="string">&quot;);</span></span></span><br><span class="line"><span class="string"><span class="meta">            break;</span></span></span><br><span class="line"><span class="string"><span class="meta">        &#125;</span></span></span><br><span class="line"><span class="string"><span class="meta">        ssize_t n_write = write(output, buffer, bytes_read);</span></span></span><br><span class="line"><span class="string"><span class="meta">        if (n_write &lt; 0)</span></span></span><br><span class="line"><span class="string"><span class="meta">        &#123;</span></span></span><br><span class="line"><span class="string"><span class="meta">            _ERROR(&quot;</span>write<span class="string">&quot;);</span></span></span><br><span class="line"><span class="string"><span class="meta">            break;</span></span></span><br><span class="line"><span class="string"><span class="meta">        &#125;</span></span></span><br><span class="line"><span class="string"><span class="meta">        buffer[sizeof(buffer) - 1] = 0;</span></span></span><br><span class="line"><span class="string"><span class="meta">    &#125;</span></span></span><br><span class="line"><span class="string"><span class="meta">    std::cout &lt;&lt; &quot;</span>over!<span class="string">&quot; &lt;&lt; std::endl;</span></span></span><br><span class="line"><span class="string"><span class="meta">    unlink(&quot;</span>tmp<span class="string">&quot;);</span></span></span><br><span class="line"><span class="string"><span class="meta">    close(input);</span></span></span><br><span class="line"><span class="string"><span class="meta">    close(output);</span></span></span><br><span class="line"><span class="string"><span class="meta">    return 0;</span></span></span><br><span class="line"><span class="string"><span class="meta">&#125;</span></span></span><br></pre></td></tr></table></figure>
<p><strong>运行时</strong>(在不同终端同时运行 <code>reader</code> 和 <code>writer</code>)</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">ls</span></span><br><span class="line">reader.cpp  source.txt  writer.cpp</span><br><span class="line">$ <span class="built_in">cat</span> source.txt </span><br><span class="line">This is <span class="keyword">for</span> <span class="built_in">test</span> data</span><br><span class="line">……</span><br><span class="line">End</span><br><span class="line">$ ./writer </span><br><span class="line"><span class="built_in">mkfifo</span> success!</span><br><span class="line">Reader connecting……</span><br><span class="line">Connected!</span><br><span class="line">over!</span><br><span class="line">$ <span class="built_in">ls</span> -l</span><br><span class="line">total 60</span><br><span class="line">-rw-rw-rw- 1 wyf wyf    33 Jun 21 20:23 backup.bak</span><br><span class="line">-rwxrwxr-x 1 wyf wyf 16904 Jun 21 20:23 reader</span><br><span class="line">-rw-rw-r-- 1 wyf wyf  1499 Jun 21 20:22 reader.cpp</span><br><span class="line">-rw-rw-r-- 1 wyf wyf    33 Jun 21 20:21 source.txt</span><br><span class="line">-rwxrwxr-x 1 wyf wyf 16864 Jun 21 20:23 writer</span><br><span class="line">-rw-rw-r-- 1 wyf wyf  1726 Jun 21 20:21 writer.cpp</span><br><span class="line">$ <span class="built_in">cat</span> backup.bak </span><br><span class="line">This is <span class="keyword">for</span> <span class="built_in">test</span> data</span><br><span class="line">……</span><br><span class="line">End</span><br><span class="line">$ </span><br><span class="line"><span class="comment"># 另一台终端</span></span><br><span class="line">$ ./reader </span><br><span class="line">over!</span><br><span class="line">$ </span><br></pre></td></tr></table></figure>
<blockquote>
<p>注：虽然实现了文件的备份，但是使用起来不是很舒服(用起来比较复杂，需要同时运行两个程序和协调启动顺序等问题)，此处仅是为了熟悉命名管道的用法，一般文件备份最简单高效的方法是：<strong>直接采用文件复制</strong></p>
</blockquote>
<h4 id="4-6-用命名管道实现-Server-Client-通信"><a href="#4-6-用命名管道实现-Server-Client-通信" class="headerlink" title="4.6 用命名管道实现 Server&#x2F;Client 通信"></a>4.6 用命名管道实现 Server&#x2F;Client 通信</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NamedPipe.hpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cerrno&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _FIFO_NAME <span class="string">&quot;fifo&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> _ERROR(msg)                                                                                  \</span></span><br><span class="line"><span class="meta">    do                                                                                               \</span></span><br><span class="line"><span class="meta">    &#123;                                                                                                \</span></span><br><span class="line"><span class="meta">        std::cerr <span class="string">&lt;&lt; &quot;ERROR&lt;&quot; &lt;&lt; msg &lt;&lt; &quot;&gt;</span>:<span class="string">&quot; &lt;&lt; strerror(errno) &lt;&lt; &quot;</span>(<span class="string">&quot; &lt;&lt; errno &lt;&lt; &quot;</span>)<span class="string">&quot; &lt;&lt; std::endl; \</span></span></span><br><span class="line"><span class="string"><span class="meta">        exit(1);                                                                                     \</span></span></span><br><span class="line"><span class="string"><span class="meta">    &#125; while (0)</span></span></span><br><span class="line"><span class="string"><span class="meta"></span></span></span><br><span class="line"><span class="string"><span class="meta">#define READ_SIZE 1024</span></span></span><br><span class="line"><span class="string"><span class="meta"></span></span></span><br><span class="line"><span class="string"><span class="meta">class NamedPipe</span></span></span><br><span class="line"><span class="string"><span class="meta">&#123;</span></span></span><br><span class="line"><span class="string"><span class="meta">public:</span></span></span><br><span class="line"><span class="string"><span class="meta">    NamedPipe(std::string name = _FIFO_NAME)</span></span></span><br><span class="line"><span class="string"><span class="meta">        : _name(name), _fd(-1)</span></span></span><br><span class="line"><span class="string"><span class="meta">    &#123;</span></span></span><br><span class="line"><span class="string"><span class="meta">        umask(0);</span></span></span><br><span class="line"><span class="string"><span class="meta">        // 创建命名管道文件</span></span></span><br><span class="line"><span class="string"><span class="meta">        int n_mkfifo = mkfifo(_FIFO_NAME, 0666);</span></span></span><br><span class="line"><span class="string"><span class="meta">        if (n_mkfifo &lt; 0)</span></span></span><br><span class="line"><span class="string"><span class="meta">        &#123;</span></span></span><br><span class="line"><span class="string"><span class="meta">            _ERROR(&quot;</span>mkfifo <span class="keyword">error</span><span class="string">&quot;);</span></span></span><br><span class="line"><span class="string"><span class="meta">        &#125;</span></span></span><br><span class="line"><span class="string"><span class="meta">        std::cerr &lt;&lt; &quot;</span>mkfifo success!<span class="string">&quot; &lt;&lt; std::endl;</span></span></span><br><span class="line"><span class="string"><span class="meta">    &#125;</span></span></span><br><span class="line"><span class="string"><span class="meta">    ~NamedPipe()</span></span></span><br><span class="line"><span class="string"><span class="meta">    &#123;</span></span></span><br><span class="line"><span class="string"><span class="meta">        // 关闭命名管道文件</span></span></span><br><span class="line"><span class="string"><span class="meta">        close(_fd);</span></span></span><br><span class="line"><span class="string"><span class="meta">        // 删除命名管道文件</span></span></span><br><span class="line"><span class="string"><span class="meta">        int n_link = unlink(_FIFO_NAME);</span></span></span><br><span class="line"><span class="string"><span class="meta">        if (n_link &lt; 0)</span></span></span><br><span class="line"><span class="string"><span class="meta">        &#123;</span></span></span><br><span class="line"><span class="string"><span class="meta">            _ERROR(&quot;</span>unlink <span class="keyword">error</span><span class="string">&quot;);</span></span></span><br><span class="line"><span class="string"><span class="meta">        &#125;</span></span></span><br><span class="line"><span class="string"><span class="meta">        else</span></span></span><br><span class="line"><span class="string"><span class="meta">        &#123;</span></span></span><br><span class="line"><span class="string"><span class="meta">            std::cout &lt;&lt; &quot;</span>Remove <span class="string">&quot; &lt;&lt; _FIFO_NAME &lt;&lt; &quot;</span> success!<span class="string">&quot; &lt;&lt; std::endl;</span></span></span><br><span class="line"><span class="string"><span class="meta">        &#125;</span></span></span><br><span class="line"><span class="string"><span class="meta">    &#125;</span></span></span><br><span class="line"><span class="string"><span class="meta">private:</span></span></span><br><span class="line"><span class="string"><span class="meta">    std::string _name;</span></span></span><br><span class="line"><span class="string"><span class="meta">    int _fd;</span></span></span><br><span class="line"><span class="string"><span class="meta">&#125;;</span></span></span><br><span class="line"><span class="string"><span class="meta"></span></span></span><br><span class="line"><span class="string"><span class="meta">class FileOperator</span></span></span><br><span class="line"><span class="string"><span class="meta">&#123;</span></span></span><br><span class="line"><span class="string"><span class="meta">public:</span></span></span><br><span class="line"><span class="string"><span class="meta">    FileOperator(std::string name = _FIFO_NAME)</span></span></span><br><span class="line"><span class="string"><span class="meta">        : _name(name), _fd(-1) &#123;&#125;</span></span></span><br><span class="line"><span class="string"><span class="meta">    bool OpenForRead()</span></span></span><br><span class="line"><span class="string"><span class="meta">    &#123;</span></span></span><br><span class="line"><span class="string"><span class="meta">        // 打开管道文件</span></span></span><br><span class="line"><span class="string"><span class="meta">        _fd = open(_name.c_str(), O_RDONLY);</span></span></span><br><span class="line"><span class="string"><span class="meta">        if (_fd &lt; 0)</span></span></span><br><span class="line"><span class="string"><span class="meta">        &#123;</span></span></span><br><span class="line"><span class="string"><span class="meta">            _ERROR(&quot;</span>open <span class="keyword">error</span><span class="string">&quot;);</span></span></span><br><span class="line"><span class="string"><span class="meta">            return false;</span></span></span><br><span class="line"><span class="string"><span class="meta">        &#125;</span></span></span><br><span class="line"><span class="string"><span class="meta">        char buffer[READ_SIZE] = &#123;&quot;</span>0<span class="string">&quot;&#125;;</span></span></span><br><span class="line"><span class="string"><span class="meta">        // 读取管道文件</span></span></span><br><span class="line"><span class="string"><span class="meta">        int n_read = read(_fd, buffer, sizeof(buffer) - 1);</span></span></span><br><span class="line"><span class="string"><span class="meta">        buffer[n_read] = 0;</span></span></span><br><span class="line"><span class="string"><span class="meta">        if (n_read &gt; 0)</span></span></span><br><span class="line"><span class="string"><span class="meta">        &#123;</span></span></span><br><span class="line"><span class="string"><span class="meta">            std::cout &lt;&lt; &quot;</span>Client say <span class="string">&lt;&quot; &lt;&lt; buffer &lt;&lt; &quot;&gt;</span>\n<span class="string">&quot;;</span></span></span><br><span class="line"><span class="string"><span class="meta">            fflush(stdout);</span></span></span><br><span class="line"><span class="string"><span class="meta">            return true;</span></span></span><br><span class="line"><span class="string"><span class="meta">        &#125;</span></span></span><br><span class="line"><span class="string"><span class="meta">        else if (n_read == 0)</span></span></span><br><span class="line"><span class="string"><span class="meta">        &#123;</span></span></span><br><span class="line"><span class="string"><span class="meta">            std::cout &lt;&lt; &quot;</span>Client exiting\n<span class="string">&quot;</span></span></span><br><span class="line"><span class="string"><span class="meta">                      &lt;&lt; &quot;</span>Server will be exiting too<span class="string">&quot; &lt;&lt; std::endl;</span></span></span><br><span class="line"><span class="string"><span class="meta">            return false;</span></span></span><br><span class="line"><span class="string"><span class="meta">        &#125;</span></span></span><br><span class="line"><span class="string"><span class="meta">        else</span></span></span><br><span class="line"><span class="string"><span class="meta">        &#123;</span></span></span><br><span class="line"><span class="string"><span class="meta">            _ERROR(&quot;</span>read <span class="keyword">error</span><span class="string">&quot;);</span></span></span><br><span class="line"><span class="string"><span class="meta">            return false;</span></span></span><br><span class="line"><span class="string"><span class="meta">        &#125;</span></span></span><br><span class="line"><span class="string"><span class="meta">    &#125;</span></span></span><br><span class="line"><span class="string"><span class="meta">    bool OpenForWrite()</span></span></span><br><span class="line"><span class="string"><span class="meta">    &#123;</span></span></span><br><span class="line"><span class="string"><span class="meta">        // 打开管道文件</span></span></span><br><span class="line"><span class="string"><span class="meta">        _fd = open(_name.c_str(), O_WRONLY);</span></span></span><br><span class="line"><span class="string"><span class="meta">        if (_fd &lt; 0)</span></span></span><br><span class="line"><span class="string"><span class="meta">        &#123;</span></span></span><br><span class="line"><span class="string"><span class="meta">            _ERROR(&quot;</span>open <span class="keyword">error</span><span class="string">&quot;);</span></span></span><br><span class="line"><span class="string"><span class="meta">            return false;</span></span></span><br><span class="line"><span class="string"><span class="meta">        &#125;</span></span></span><br><span class="line"><span class="string"><span class="meta">        std::string msg;</span></span></span><br><span class="line"><span class="string"><span class="meta">        std::cout &lt;&lt; &quot;</span>Please input: <span class="string">&quot;;</span></span></span><br><span class="line"><span class="string"><span class="meta">        getline(std::cin, msg);</span></span></span><br><span class="line"><span class="string"><span class="meta">        // std::cin &gt;&gt; msg;</span></span></span><br><span class="line"><span class="string"><span class="meta">        // 写入管道文件</span></span></span><br><span class="line"><span class="string"><span class="meta">        int n_write = write(_fd, msg.c_str(), msg.size());</span></span></span><br><span class="line"><span class="string"><span class="meta">        if (n_write &gt; 0)</span></span></span><br><span class="line"><span class="string"><span class="meta">        &#123;</span></span></span><br><span class="line"><span class="string"><span class="meta">            fflush(stdin);</span></span></span><br><span class="line"><span class="string"><span class="meta">            fflush(stdout);</span></span></span><br><span class="line"><span class="string"><span class="meta">            return true;</span></span></span><br><span class="line"><span class="string"><span class="meta">        &#125;</span></span></span><br><span class="line"><span class="string"><span class="meta">        else if (n_write &lt; 0)</span></span></span><br><span class="line"><span class="string"><span class="meta">        &#123;</span></span></span><br><span class="line"><span class="string"><span class="meta">            _ERROR(&quot;</span>write <span class="keyword">error</span><span class="string">&quot;);</span></span></span><br><span class="line"><span class="string"><span class="meta">            return false;</span></span></span><br><span class="line"><span class="string"><span class="meta">        &#125;</span></span></span><br><span class="line"><span class="string"><span class="meta">        return true;</span></span></span><br><span class="line"><span class="string"><span class="meta">    &#125;</span></span></span><br><span class="line"><span class="string"><span class="meta">    ~FileOperator()</span></span></span><br><span class="line"><span class="string"><span class="meta">    &#123;</span></span></span><br><span class="line"><span class="string"><span class="meta">        if (_fd != -1)</span></span></span><br><span class="line"><span class="string"><span class="meta">            close(_fd);</span></span></span><br><span class="line"><span class="string"><span class="meta">    &#125;</span></span></span><br><span class="line"><span class="string"><span class="meta">private:</span></span></span><br><span class="line"><span class="string"><span class="meta">    std::string _name;</span></span></span><br><span class="line"><span class="string"><span class="meta">    int _fd;</span></span></span><br><span class="line"><span class="string"><span class="meta">&#125;;</span></span></span><br></pre></td></tr></table></figure>
<p>服务端创建命名管道(通过构造函数自动完成创建)，并从中不断读取</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// server.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;NamedPipe.hpp&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    NamedPipe np;</span><br><span class="line">    FileOperator fp;</span><br><span class="line">    <span class="keyword">while</span>(fp.<span class="built_in">OpenForRead</span>());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>客户端打开同样的管道，并进行写入</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// client.cpp</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;NamedPipe.hpp&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    FileOperator fo;</span><br><span class="line">    <span class="keyword">while</span>(fo.<span class="built_in">OpenForWrite</span>());</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>


<p><strong>通信结果</strong></p>
<!-- ![1750239265033](image/进程间通信/1750239265033.png) -->
<img src="/2025/11/24/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/1750239265033.png" class="">

<h3 id="5-System-V"><a href="#5-System-V" class="headerlink" title="5. System V"></a>5. System V</h3><p><strong><code>System V</code>：一个历史性的 <code>Unix</code> 操作系统分支及其设计的标准</strong></p>
<p>可以将其理解在两个方面：</p>
<ol>
<li><p><strong>一个具体的 <code>Unix</code> 操作系统版本系列：</strong></p>
<ul>
<li><code>System V</code> (读作 “System Five”) 是 <strong><code>AT&amp;T</code> 贝尔实验室</strong> 开发的 <strong><code>Unix</code> 操作系统</strong> 的一个主要商业版本分支</li>
<li>它是 <code>Unix</code> 漫长发展历史中，继最初的 <code>Research Unix</code> 之后，最重要的几个分支之一（其他主要分支包括 <code>BSD</code>）</li>
<li>它的版本按发行顺序命名为：<strong><code>System III</code>, <code>System V Release 1 (SVR1)</code>, <code>SVR2</code>, <code>SVR3</code>, <code>SVR4</code></strong></li>
<li><code>SVR4</code>（<code>1989</code> 年发布）是这一系列发展的顶峰，它是一个重要的<strong>融合版本</strong>，整合了之前 <code>System V</code>、<code>BSD</code>、<code>SunOS</code>（<code>Sun Microsystems</code>）和 <code>Xenix</code>（<code>Microsoft</code>）的关键特性，旨在成为“统一的 Unix”。它在商业市场上获得了巨大的成功，成为 <code>80</code> 年代末到 <code>90</code> 年代 <strong>主流商业 <code>Unix</code></strong> 系统的基础</li>
</ul>
</li>
<li><p><strong>一套操作系统接口和行为的规范（“System V 风格”）：</strong></p>
<ul>
<li>这是 <strong><code>System V</code> 更深远和持久的遗产</strong>。随着 <code>System V</code>（尤其是 <code>SVR4</code>）的广泛流行，它所定义和实现的一系列<strong>核心操作系统机制、接口和行为规范</strong>，成为了事实上的<strong>工业标准</strong></li>
<li>这些规范定义了操作系统核心服务应该如何工作，为不同厂商开发兼容的 <code>Unix</code> 系统提供了蓝图。它们涉及操作系统的许多基础层面：<ul>
<li><strong>进程间通信 (IPC)：</strong> 这是 <code>System V</code> 规范中最著名和最具影响力的部分。它定义了一组标准化的 <code>IPC</code> 机制，包括：<ul>
<li><strong>System V 信号量：</strong> 用于控制对共享资源的同步访问</li>
<li><strong>System V 共享内存：</strong> 允许不同进程直接访问同一块物理内存区域，实现最高效但也最需要谨慎管理的进程间数据共享</li>
<li><strong>System V 消息队列：</strong> 允许进程间通过发送和接收格式化消息来通信</li>
</ul>
</li>
<li><strong>Init 系统和运行级别：</strong> <code>System V</code> 引入了 <strong><code>init</code> 进程</strong> 的特定管理方式和 <strong>运行级别</strong> 的概念。系统启动、关闭、切换状态（如单用户模式、多用户模式、图形模式等）都通过运行级别和与之关联的启动&#x2F;停止脚本来管理。这种管理方式常被称为 <strong>“SysV init”</strong></li>
<li><strong>文件系统布局：</strong> <code>System V</code> 推广了一套特定的<strong>文件和目录组织标准</strong>。例如，系统配置文件通常放在 <code>/etc</code>，可执行程序在 <code>/bin</code> 和 <code>/usr/bin</code>，库文件在 <code>/lib</code> 和 <code>/usr/lib</code>，附加软件在 <code>/opt</code> 等。虽然细节不断演化，但现代 <code>Unix</code>&#x2F;<code>Linux</code> 系统的基本布局深受 <code>System V</code> 影响</li>
<li><strong>其他系统接口：</strong> 包括进程控制、终端管理、系统管理工具等方面，<code>System V</code> 都提供了一套标准化的接口（通常通过 <code>C</code> 库函数和系统调用暴露给开发者）</li>
</ul>
</li>
</ul>
</li>
</ol>
<p>下面我们重点介绍进程间通信的部分</p>
<p><strong>System V 的核心遗产：一套标准化的进程间通信 (<code>IPC</code>)</strong></p>
<p>当谈到 <strong>System V</strong> 在现代操作系统语境下的核心意义时，尤其是在进程间通信领域，它指的<strong>不是</strong>一个具体的操作系统，而是<strong>一套由历史悠久的 <code>Unix System V</code> 操作系统定义并推广的、标准化的进程间通信机制的设计规范和理念</strong></p>
<p><strong>核心概念与设计目标：</strong></p>
<ol>
<li><strong>解决核心问题：</strong> 在多进程的操作系统环境中，不同的进程（运行中的程序）经常需要<strong>协同工作</strong>或<strong>交换数据</strong>。<code>System V IPC</code> 提供了一套由操作系统内核直接支持的、可靠的、标准化的方法来实现这种跨进程的交互</li>
<li><strong>提供基础“通信原语”：</strong> 它定义了三种最基础、最核心的 <code>IPC</code> 机制，如同为进程间通信提供了基本的“积木块”：<ul>
<li><strong>System V 信号量 (Semaphores):</strong><ul>
<li><strong>核心作用：</strong> <strong>同步 (Synchronization)</strong> 与 <strong>互斥 (Mutual Exclusion)</strong></li>
<li><strong>概念理解：</strong> 想象一个需要多个进程共同访问的稀缺资源（如打印机、共享内存区、数据库连接）。信号量就像一个<strong>交通信号灯</strong>或<strong>令牌</strong>。进程在访问资源前必须先“获取”信号量（等待绿灯或拿到令牌），使用完后再“释放”信号量（切换红灯或归还令牌）。这确保了同一时间只有一个（或指定数量）的进程能访问该资源，防止冲突和数据混乱。它不直接传递数据，而是<strong>协调进程的步调</strong></li>
</ul>
</li>
<li><strong>System V 共享内存 (Shared Memory):</strong><ul>
<li><strong>核心作用：</strong> <strong>高效的数据共享</strong></li>
<li><strong>概念理解：</strong> <strong>这是速度最快的 <code>IPC</code> 方式</strong>。操作系统在内核中开辟一块物理内存区域，并允许多个<strong>独立的进程</strong>将其<strong>映射</strong>到各自的<strong>虚拟地址空间</strong>中。一旦映射完成，这些进程就可以像访问自己的普通内存一样<strong>直接读写</strong>这块共享区域。它移除了数据在进程间复制（如通过管道或消息传递）的开销。关键在于，它需要<strong>信号量或其他机制配合</strong>来管理并发访问，避免读写冲突</li>
</ul>
</li>
<li><strong>System V 消息队列 (Message Queues):</strong><ul>
<li><strong>核心作用：</strong> <strong>结构化的、异步的数据传递</strong></li>
<li><strong>概念理解：</strong> 想象一个<strong>由内核维护的“邮箱”或“队列”</strong>。进程 <code>A</code> 可以将格式化的“消息”（一段数据，通常有类型和内容）发送到这个队列中。进程 <code>B</code> 可以在之后（可能立刻，也可能稍后）从队列中读取这条消息。消息队列是<strong>面向消息</strong>的、<strong>解耦</strong>的（发送者和接收者不需要同时存在）、并且支持基于消息类型的选择性读取。它提供了比管道更灵活、更结构化的通信方式</li>
</ul>
</li>
</ul>
</li>
</ol>
<h4 id="5-1-共享内存"><a href="#5-1-共享内存" class="headerlink" title="5.1 共享内存"></a>5.1 共享内存</h4><h5 id="5-1-1-概念理解"><a href="#5-1-1-概念理解" class="headerlink" title="5.1.1 概念理解"></a>5.1.1 概念理解</h5><p><strong>1. System V 共享内存：概念与设计</strong></p>
<ul>
<li><code>System V</code> 共享内存<strong>提供一种让多个进程能够直接、极其高效地访问和修改同一块物理内存区域的机制</strong>，彻底<strong>消除内核复制数据的开销</strong></li>
</ul>
<!-- ![1753018529251](image/进程间通信/1753018529251.png) -->
<img src="/2025/11/24/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/1753018529251.png" class="">

<p><strong>2. 核心概念：共享内存段</strong></p>
<ul>
<li><strong>物理内存区域：</strong> 操作系统内核在物理内存（<code>RAM</code>）中划出一块连续的、特定大小的区域。这块区域被称为一个<strong>共享内存段 (Shared Memory Segment)</strong></li>
<li><strong>虚拟地址映射：</strong> 这是实现“共享”的关键<ul>
<li>每个进程都拥有自己独立的<strong>虚拟地址空间</strong>。进程看到的内存地址（指针指向的位置）是虚拟的，由操作系统和硬件（<code>MMU</code>, <code>Memory Management Unit</code>）最终映射到物理内存地址</li>
<li>共享内存机制允许<strong>多个独立的进程</strong>，请求操作系统将<strong>同一个物理内存段（共享内存段）映射到它们各自不同的虚拟地址空间</strong>中的某个位置</li>
<li>例如，进程 <code>A</code> 可能看到该共享段在它的地址 <code>0x1000</code> 处，进程 <code>B</code> 可能看到它在自己的地址 <code>0x5000</code> 处。但操作系统保证，这两个虚拟地址最终都指向物理内存中的<strong>同一块区域</strong></li>
</ul>
</li>
<li><strong>直接读写：</strong> 一旦映射完成，对于参与映射的进程来说：<ul>
<li>访问这块映射区域（通过它自己虚拟地址空间中的地址）<strong>就像访问自己进程内的普通内存一样</strong>（使用指针读写）</li>
<li>任何进程对这块内存内容的<strong>修改，都会立刻、直接地反映在物理内存上</strong></li>
<li>因此，<strong>所有映射了该共享段的进程，都能立即看到其他进程对这块内存所做的任何修改</strong>。数据传递是<strong>瞬时</strong>和<strong>直接</strong>的</li>
</ul>
</li>
</ul>
<p><strong>3. 核心特性：</strong></p>
<ul>
<li><strong>内核管理，用户空间访问：</strong><ul>
<li>共享内存段的<strong>创建、销毁、权限控制、初始映射</strong>等管理工作，<strong>必须</strong>通过系统调用请求操作系统内核来完成</li>
<li>一旦映射成功，进程在<strong>用户空间</strong>（即应用程序自身的运行环境）就可以<strong>直接</strong>使用指针访问共享内存，<strong>无需</strong>每次访问都陷入内核态。这是其速度优势的根本来源</li>
</ul>
</li>
<li><strong>内核持久性：</strong><ul>
<li>共享内存段一旦被创建，它就作为一个<strong>独立的内核对象</strong>存在</li>
<li>即使创建它的进程终止了，只要没有进程显式地请求销毁它（或系统重启），这个共享内存段<strong>依然保留在物理内存中</strong>（除非被交换出去）</li>
<li>后续启动的其他进程，只要知道该共享段的标识符（或键）并拥有足够的权限，就可以将其映射到自己的地址空间继续访问。这为进程间持久的、跨生命周期的数据共享提供了可能</li>
</ul>
</li>
<li><strong>访问控制：</strong><ul>
<li>共享内存段在创建时可以设置<strong>权限位</strong>（类似文件权限，如用户&#x2F;组&#x2F;其他 的 读&#x2F;写权限）。这限制了哪些用户或组的进程可以映射和访问该段</li>
</ul>
</li>
<li><strong>命名与标识：</strong><ul>
<li>为了允许多个不相关的进程找到并访问同一个共享内存段，<code>System V</code> 使用了 <strong>键 (<code>Key</code>)</strong> 的概念<ul>
<li>进程在创建共享段时，可以指定一个唯一的键（通常通过一个约定的文件路径名转换而来，如 <code>ftok</code> 函数生成）</li>
<li>其他进程只要知道这个键，就可以请求内核找到或创建对应的共享段，并获取其唯一的<strong>标识符 (<code>ID</code>)</strong>。有了 <code>ID</code>，进程就可以请求映射该段了</li>
</ul>
</li>
</ul>
</li>
<li><strong>同步的必要性：</strong><ul>
<li><strong>这是共享内存概念中最关键、最需要深刻理解的一点：共享内存只提供了共享的场所，没有提供访问的规则！</strong></li>
<li>因此，<strong>使用 <code>System V</code> 共享内存，几乎总是需要配合其他同步机制（特别是 <code>System V</code> 信号量，或者其他如互斥锁、读写锁等）来协调多个进程对共享内存的访问顺序</strong>，保证数据的<strong>一致性和完整性</strong>。没有同步，共享内存就会成为数据混乱的根源</li>
</ul>
</li>
</ul>
<h5 id="5-1-2-系统调用"><a href="#5-1-2-系统调用" class="headerlink" title="5.1.2 系统调用"></a>5.1.2 系统调用</h5><p><strong>核心系统调用：</strong></p>
<p><code>System V</code> 共享内存主要涉及四个系统调用：<code>shmget</code>, <code>shmat</code>, <code>shmdt</code>, <code>shmctl</code>。分别用于获取&#x2F;创建段、附加（映射）段、分离（卸载）段、控制段</p>
<p><strong>1. <code>shmget</code> - 获取共享内存段标识符 (Shared Memory GET)</strong></p>
<ul>
<li><strong>目的：</strong> 创建新的共享内存段，或者获取一个已存在段的标识符 (<code>shmid</code>)</li>
<li><strong>函数原型:</strong>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">shmget</span><span class="params">(<span class="type">key_t</span> key, <span class="type">size_t</span> size, <span class="type">int</span> shmflg)</span>;</span><br></pre></td></tr></table></figure></li>
<li><strong>参数:</strong><ul>
<li><code>key_t key</code>: 这是共享内存段的<strong>键 (Key)</strong>。它用于唯一标识系统中的共享内存段。如何生成 <code>key</code>？<ul>
<li><strong><code>IPC_PRIVATE</code> (值为0):</strong> 总是创建<strong>新</strong>的共享内存段。通常用于父子进程间通信（父进程创建，子进程继承）</li>
<li><strong><code>ftok(const char *pathname, int proj_id)</code> 函数:</strong> 这是最常用的方法。它根据一个<strong>已存在的文件路径名</strong> (<code>pathname</code>) 和一个<strong>项目标识符</strong> (<code>proj_id</code>，通常是一个字符，如 <code>&#39;a&#39;</code>)，生成一个唯一的 <code>key_t</code> 值。只要不同进程使用相同的 <code>pathname</code> 和 <code>proj_id</code>，<code>ftok</code> 就会生成相同的 <code>key</code>，从而让它们访问同一个共享段</li>
</ul>
</li>
<li><code>size_t size</code>: 请求的共享内存段的<strong>大小（字节数）</strong><ul>
<li>当创建<strong>新</strong>段 (<code>shmflg</code> 包含 <code>IPC_CREAT</code>) 时，<code>size</code> 必须指定且必须大于 <code>0</code>。内核实际分配的段大小是<strong>系统页大小（通常是 4096 字节）的整数倍</strong>，会向上取整</li>
<li>当获取<strong>已存在</strong>段的标识符 (<code>shmflg</code> 不包含 <code>IPC_CREAT</code> 或包含 <code>IPC_CREAT</code> 但指定了已存在的 <code>key</code>) 时，<code>size</code> 参数会被<strong>忽略</strong>（但通常设为 <code>0</code> 以符合规范）。内核会返回现有段的大小</li>
</ul>
</li>
<li><code>int shmflg</code>: 这是一个<strong>位掩码 (bitmask)</strong>，由权限标志和创建&#x2F;访问标志<strong>按位或 (<code>|</code>)</strong> 组成<ul>
<li><strong>权限标志 (类似文件权限):</strong> 指定共享内存段的访问权限（所有者、组、其他人 的 读&#x2F;写权限）。常用八进制表示：<ul>
<li><code>0600</code>: 所有者可读写 (<code>6 = 4(r) + 2(w)</code>)</li>
<li><code>0666</code>: 所有者、组、其他人都可读写</li>
<li><code>0644</code>: 所有者读写，组和其他人只读</li>
<li><code>IPC_CREAT</code> 或 <code>IPC_EXCL</code> <strong>必须</strong>与权限标志组合使用</li>
</ul>
</li>
<li><strong>创建&#x2F;访问标志:</strong><ul>
<li><code>IPC_CREAT</code>: 如果与指定 <code>key</code> 关联的共享内存段不存在，则<strong>创建</strong>一个新段。如果存在，则<strong>返回</strong>该已存在段的标识符</li>
<li><code>IPC_EXCL</code>: 这个标志<strong>必须与 <code>IPC_CREAT</code> 一起使用</strong> (<code>IPC_CREAT | IPC_EXCL</code>)。它表示<strong>独占创建</strong>。如果与指定 <code>key</code> 关联的段<strong>已存在</strong>，则 <code>shmget</code> <strong>调用失败</strong> (返回 <code>-1</code>, 设置 <code>errno</code> 为 <code>EEXIST</code>)。这确保了调用者创建的是一个全新的、唯一的段</li>
</ul>
</li>
<li><strong>示例组合:</strong><ul>
<li><code>IPC_CREAT | 0666</code>: 获取或创建一个 <code>key</code> 对应的段，权限为所有人可读写</li>
<li><code>IPC_CREAT | IPC_EXCL | 0600</code>: 尝试创建一个新的、独占的段（<code>key</code> 必须不存在），权限为所有者读写</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><strong>返回值:</strong><ul>
<li>成功：返回一个非负整数，即<strong>共享内存段标识符 (shmid)</strong>。后续操作都使用这个 <code>shmid</code>，而不是 <code>key</code></li>
<li>失败：返回 <code>-1</code>，并设置全局变量 <code>errno</code> 指示错误原因（如 <code>EEXIST</code>, <code>EACCES</code>, <code>ENOMEM</code> 等）</li>
</ul>
</li>
</ul>
<p><strong>2. <code>shmat</code> - 附加共享内存段 (Shared Memory ATTach)</strong></p>
<ul>
<li><strong>目的：</strong> 将 <code>shmget</code> 获取到的共享内存段<strong>附加（映射）</strong> 到调用进程的<strong>虚拟地址空间</strong>中。成功后，进程即可通过返回的指针直接访问共享内存</li>
<li><strong>函数原型:</strong>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"><span class="type">void</span> *<span class="title function_">shmat</span><span class="params">(<span class="type">int</span> shmid, <span class="type">const</span> <span class="type">void</span> *shmaddr, <span class="type">int</span> shmflg)</span>;</span><br></pre></td></tr></table></figure></li>
<li><strong>参数:</strong><ul>
<li><code>int shmid</code>: 由 <code>shmget</code> 成功返回的<strong>共享内存段标识符</strong></li>
<li><code>const void *shmaddr</code>: 指定进程希望将共享内存段<strong>附加到的虚拟地址</strong><ul>
<li><strong>通常设置为 <code>(void *)0</code> 或 <code>NULL</code></strong>: 这是<strong>最常用</strong>的方式。表示由<strong>内核自动选择</strong>一个合适的、未使用的虚拟地址空间区域来附加共享内存段。内核的选择通常是安全且兼容性最好的</li>
<li><strong>指定非 NULL 地址</strong>: 这要求附加到 <code>shmaddr</code> 指向的特定地址。这需要满足对齐要求（通常是页对齐），并且该地址范围必须是空闲可用的。这种方式<strong>不常用且容易出错</strong>（可能导致冲突或段错误），应尽量避免，除非有特殊需求</li>
</ul>
</li>
<li><code>int shmflg</code>: 附加标志的位掩码。常用标志：<ul>
<li><code>0</code>: 默认行为。可读可写</li>
<li><code>SHM_RDONLY</code>: 以<strong>只读</strong>方式附加共享内存段。附加后，进程只能读取共享内存的内容，不能写入。这需要进程在附加时拥有该段的<strong>读权限</strong></li>
<li><code>SHM_REMAP</code> (<code>Linux</code> 特有): 强制将共享段附加到 <code>shmaddr</code> 指定的地址，即使该地址已被使用（会覆盖原有映射）。<strong>非常危险，极少使用</strong></li>
<li><code>SHM_EXEC</code> (<code>Linux</code> 特有): 允许执行共享内存中的代码（需要段有执行权限）。出于安全考虑，很少使用</li>
</ul>
</li>
</ul>
</li>
<li><strong>返回值:</strong><ul>
<li>成功：返回一个指向共享内存段在<strong>当前进程地址空间</strong>中起始位置的 <code>void *</code> 指针。进程后续通过这个指针访问共享内存</li>
<li>失败：返回 <code>(void *) -1</code>，并设置 <code>errno</code></li>
</ul>
</li>
</ul>
<p><strong>3. <code>shmdt</code> - 分离共享内存段 (Shared Memory DeTach)</strong></p>
<ul>
<li><strong>目的：</strong> 将之前通过 <code>shmat</code> 附加到当前进程地址空间的共享内存段<strong>分离（卸载）</strong>。分离后，该进程不能再通过之前的指针访问该共享内存段。<strong>这不会删除共享内存段本身！</strong></li>
<li><strong>函数原型:</strong>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">shmdt</span><span class="params">(<span class="type">const</span> <span class="type">void</span> *shmaddr)</span>;</span><br></pre></td></tr></table></figure></li>
<li><strong>参数:</strong><ul>
<li><code>const void *shmaddr</code>: 要分离的共享内存段在当前进程地址空间中的<strong>起始地址</strong>。这个地址必须是之前 <code>shmat</code> 成功调用返回的指针</li>
</ul>
</li>
<li><strong>返回值:</strong><ul>
<li>成功：返回 <code>0</code></li>
<li>失败：返回 <code>-1</code>，并设置 <code>errno</code></li>
</ul>
</li>
</ul>
<p><strong>4. <code>shmctl</code> - 共享内存段控制 (Shared Memory ConTroL)</strong></p>
<ul>
<li><strong>目的：</strong> 对共享内存段执行各种<strong>控制操作</strong>，包括获取信息、设置权限、标记删除等</li>
<li><strong>函数原型:</strong>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">shmctl</span><span class="params">(<span class="type">int</span> shmid, <span class="type">int</span> cmd, <span class="keyword">struct</span> shmid_ds *buf)</span>;</span><br></pre></td></tr></table></figure></li>
<li><strong>参数:</strong><ul>
<li><code>int shmid</code>: 由 <code>shmget</code> 返回的共享内存段标识符</li>
<li><code>int cmd</code>: 要执行的控制命令。最重要的命令有：<ul>
<li><code>IPC_STAT</code>: 将当前共享内存段的<strong>状态信息</strong>（存储在 <code>struct shmid_ds</code> 结构中）复制到 <code>buf</code> 指向的缓冲区。需要<strong>读权限</strong></li>
<li><code>IPC_SET</code>: 使用 <code>buf</code> 指向的 <code>struct shmid_ds</code> 结构中的某些值（主要是 <code>shm_perm.uid</code>, <code>shm_perm.gid</code>, <code>shm_perm.mode</code>）来<strong>更新</strong>共享内存段的属性（如所有者、组、权限）。调用进程必须是段的所有者、创建者或超级用户</li>
<li><code>IPC_RMID</code>: <strong>标记</strong>该共享内存段为<strong>待删除</strong>状态。这是<strong>删除共享内存段的关键操作！</strong><ul>
<li>标记后，该段不会立即被删除</li>
<li>只有当所有附加到此段的进程都调用 <code>shmdt</code> <strong>分离</strong>了该段，<strong>并且</strong>该段被标记为 <code>IPC_RMID</code> 时，内核才会在最后一个进程分离后<strong>实际销毁</strong>该段并释放资源</li>
<li>一旦标记为 <code>IPC_RMID</code>，后续任何进程都无法再使用 <code>shmget</code>（带此 <code>shmid</code> 的 key）或 <code>shmat</code> <strong>附加</strong>这个段（尝试附加会失败）</li>
<li>即使创建段的进程终止，只要其他进程仍附加着该段且未被标记删除，段就继续存在。<code>IPC_RMID</code> 是确保段最终被清理的标准方式。<strong><code>buf</code> 参数对于 <code>IPC_RMID</code> 通常设为 <code>NULL</code></strong></li>
</ul>
</li>
<li><code>SHM_LOCK</code> &#x2F; <code>SHM_UNLOCK</code> (<code>Linux</code> 特有, 需要特权): 将共享内存段<strong>锁定</strong>在物理内存中（防止被交换到磁盘）或解除锁定</li>
</ul>
</li>
<li><code>struct shmid_ds *buf</code>: 指向 <code>struct shmid_ds</code> 结构的指针。该结构在 <code>&lt;sys/shm.h&gt;</code> 中定义，包含了共享内存段的详细信息，例如：  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">shmid_ds</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ipc_perm</span> <span class="title">shm_perm</span>;</span>    <span class="comment">// 权限和所有者信息</span></span><br><span class="line">    <span class="type">size_t</span>          shm_segsz;   <span class="comment">// 段的大小 (bytes)</span></span><br><span class="line">    <span class="type">time_t</span>          shm_atime;   <span class="comment">// 最后附加时间</span></span><br><span class="line">    <span class="type">time_t</span>          shm_dtime;   <span class="comment">// 最后分离时间</span></span><br><span class="line">    <span class="type">time_t</span>          shm_ctime;   <span class="comment">// 最后修改时间 (权限、所有者、大小等)</span></span><br><span class="line">    <span class="type">pid_t</span>           shm_cpid;    <span class="comment">// 创建进程的PID</span></span><br><span class="line">    <span class="type">pid_t</span>           shm_lpid;    <span class="comment">// 最后操作(attach/detach/ctl)进程的PID</span></span><br><span class="line">    <span class="type">shmatt_t</span>        shm_nattch;  <span class="comment">// 当前附加到此段的进程数</span></span><br><span class="line">    ...</span><br><span class="line">&#125;;</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ipc_perm</span> &#123;</span></span><br><span class="line">    <span class="type">key_t</span>          __key;       <span class="comment">// 创建时提供的 key</span></span><br><span class="line">    <span class="type">uid_t</span>          uid;         <span class="comment">// 所有者的有效用户ID</span></span><br><span class="line">    <span class="type">gid_t</span>          gid;         <span class="comment">// 所有者的有效组ID</span></span><br><span class="line">    <span class="type">uid_t</span>          cuid;        <span class="comment">// 创建者的有效用户ID</span></span><br><span class="line">    <span class="type">gid_t</span>          cgid;        <span class="comment">// 创建者的有效组ID</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> mode;        <span class="comment">// 权限位 (低9位，如 0666)</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> __seq;       <span class="comment">// 序列号 (内核内部使用)</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ul>
<li>对于 <code>IPC_STAT</code>，<code>buf</code> 用于<strong>接收</strong>信息</li>
<li>对于 <code>IPC_SET</code>，<code>buf</code> 用于<strong>提供</strong>要更新的信息（只更新特定字段）</li>
<li>对于 <code>IPC_RMID</code>，<code>buf</code> 通常可以设为 <code>NULL</code></li>
</ul>
</li>
</ul>
</li>
<li><strong>返回值:</strong><ul>
<li>成功：返回 <code>0</code> (对于 <code>IPC_RMID</code>, <code>IPC_SET</code>, <code>SHM_LOCK</code> 等命令)，或返回非负值（对于某些命令如 <code>IPC_STAT</code>，具体取决于实现，但通常成功返回 <code>0</code>）</li>
<li>失败：返回 <code>-1</code>，并设置 <code>errno</code></li>
</ul>
</li>
</ul>
<p><strong>关键概念总结 (代码视角):</strong></p>
<ol>
<li><strong>Key 与 shmid:</strong> 使用 <code>key</code> (常由 <code>ftok</code> 生成) 通过 <code>shmget</code> 获取系统唯一的 <code>shmid</code></li>
<li><strong>创建 vs 获取:</strong> <code>shmget</code> 通过 <code>shmflg</code> (<code>IPC_CREAT</code>, <code>IPC_EXCL</code>) 控制是创建新段还是获取已有段</li>
<li><strong>映射 (附加):</strong> 使用 <code>shmat</code> 和 <code>shmid</code> 将段映射到进程地址空间，得到一个本地指针</li>
<li><strong>访问:</strong> 通过 <code>shmat</code> 返回的指针像访问普通内存一样读写共享内存。<strong>务必同步！</strong></li>
<li><strong>分离:</strong> 进程不再需要访问时，使用 <code>shmdt</code> 分离段（传入 <code>shmat</code> 返回的指针）。分离后指针失效</li>
<li><strong>删除 (控制):</strong> 使用 <code>shmctl</code> 带 <code>IPC_RMID</code> 命令标记段为待删除。实际删除发生在最后一个附加进程分离且段被标记之后</li>
<li><strong>权限与状态:</strong> 使用 <code>shmctl</code> 带 <code>IPC_STAT</code>&#x2F;<code>IPC_SET</code> 查询或修改段的状态和权限</li>
<li><strong>内核持久性:</strong> 段 (<code>shmid</code>) 和其内容在内核中持续存在，直到显式删除 (<code>IPC_RMID</code>) 且无进程附加，或系统重启</li>
</ol>
<p><strong>利用共享内存实现 <code>C</code>&#x2F;<code>S</code> 通信</strong></p>
<blockquote>
<p>在已有知识储备的基础上，采用命名管道的方式对共享内存进行同步保护</p>
</blockquote>
<p><code>error.hpp</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ERROR(msg)          \</span></span><br><span class="line"><span class="meta">    do                      \</span></span><br><span class="line"><span class="meta">    &#123;                       \</span></span><br><span class="line"><span class="meta">        perror(msg);        \</span></span><br><span class="line"><span class="meta">        exit(EXIT_FAILURE); \</span></span><br><span class="line"><span class="meta">    &#125; while (0)</span></span><br></pre></td></tr></table></figure>

<p><code>commom.hpp</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/shm.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/ipc.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;error.hpp&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PATH <span class="string">&quot;.&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> PROJ_ID 0314</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CRE <span class="string">&quot;Creator&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> USE <span class="string">&quot;User&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">SharedMemory</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Create</span><span class="params">(<span class="type">size_t</span> size)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        _size = size;</span><br><span class="line">        _key = <span class="built_in">ftok</span>(PATH, PROJ_ID);</span><br><span class="line">        <span class="keyword">if</span> (_key == <span class="number">-1</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">ERROR</span>(<span class="string">&quot;ftok&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        std::cout &lt;&lt; std::hex &lt;&lt; <span class="string">&quot;key: &quot;</span> &lt;&lt; _key &lt;&lt; std::dec &lt;&lt; std::endl;</span><br><span class="line">        _shmid = <span class="built_in">shmget</span>(_key, _size, _shmflg);</span><br><span class="line">        <span class="keyword">if</span> (_shmid &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">ERROR</span>(<span class="string">&quot;shmget&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;shared memory indentifier: &quot;</span> &lt;&lt; _shmid &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Destroy</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = <span class="built_in">shmctl</span>(_shmid, IPC_RMID, <span class="literal">nullptr</span>);</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">ERROR</span>(<span class="string">&quot;shmctl&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Remove shared memory id success!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">CreateIdentify</span><span class="params">(<span class="type">size_t</span> size, <span class="type">const</span> <span class="type">char</span> *name)</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        _user_type = name;</span><br><span class="line">        <span class="keyword">if</span> (_user_type == CRE)</span><br><span class="line">        &#123;</span><br><span class="line">            _shmflg = IPC_CREAT | IPC_EXCL | (<span class="type">mode_t</span>)<span class="number">0666</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (_user_type == USE)</span><br><span class="line">        &#123;</span><br><span class="line">            _shmflg = IPC_CREAT | <span class="number">0666</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Illegal User Type!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">Create</span>(size);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">SharedMemory</span>(<span class="type">size_t</span> size, <span class="type">const</span> <span class="type">char</span> *name)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">CreateIdentify</span>(size, name);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">Attach</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        _virtual_space = (<span class="type">char</span> *)<span class="built_in">shmat</span>(_shmid, <span class="literal">nullptr</span>, <span class="number">0</span>);</span><br><span class="line">        <span class="built_in">memset</span>(_virtual_space, <span class="number">0</span>, _size);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">DeTach</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">int</span> n = <span class="built_in">shmdt</span>(_virtual_space);</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">ERROR</span>(<span class="string">&quot;shmdt&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Disattach success!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="comment">// 只对server方做释放</span></span><br><span class="line">        <span class="keyword">if</span> (_user_type == CRE)</span><br><span class="line">        &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Verification successful: &quot;</span> &lt;&lt; _user_type &lt;&lt; std::endl;</span><br><span class="line">            <span class="built_in">Destroy</span>();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (_user_type == USE)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">return</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Illegal User Type!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">char</span> *<span class="title">GetVirtualSpace</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Virtual space address: %p\n&quot;</span>, _virtual_space);</span><br><span class="line">        <span class="keyword">return</span> _virtual_space;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">SharedMemory</span>()</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    <span class="type">key_t</span> _key;</span><br><span class="line">    <span class="type">size_t</span> _size;</span><br><span class="line">    <span class="type">int</span> _shmflg;</span><br><span class="line">    <span class="type">int</span> _shmid;</span><br><span class="line">    <span class="type">char</span> *_virtual_space;</span><br><span class="line">    std::string _user_type;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>fifo.hpp</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstdio&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;cstring&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;error.hpp&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> FIFO_NAME <span class="string">&quot;fifo&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUFFER_SIZE 1024</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">NamedPipe</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">NamedPipe</span>(std::string name = FIFO_NAME)</span><br><span class="line">        : _name(name)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">mkfifo</span>(_name.<span class="built_in">c_str</span>(), <span class="number">0666</span>) &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">ERROR</span>(<span class="string">&quot;mkfifo&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Make fifo success!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">NamedPipe</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> n = <span class="built_in">unlink</span>(_name.<span class="built_in">c_str</span>());</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">ERROR</span>(<span class="string">&quot;unlink&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Unlink success!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string _name;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title class_">FileOper</span></span><br><span class="line">&#123;</span><br><span class="line"><span class="keyword">public</span>:</span><br><span class="line">    <span class="built_in">FileOper</span>(std::string name = FIFO_NAME)</span><br><span class="line">        : _name(FIFO_NAME), _fd(<span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">OpenForRead</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="comment">// 读取的时候，如果写方没有打开，读方会阻塞，直到有其他方打开管道文件</span></span><br><span class="line">        _fd = <span class="built_in">open</span>(_name.<span class="built_in">c_str</span>(), O_RDONLY);</span><br><span class="line">        <span class="keyword">if</span> (_fd &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">ERROR</span>(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Open named pipe to read!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">void</span> <span class="title">OpenForWrite</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        _fd = <span class="built_in">open</span>(_name.<span class="built_in">c_str</span>(), O_WRONLY);</span><br><span class="line">        <span class="keyword">if</span> (_fd &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">ERROR</span>(<span class="string">&quot;open&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Open named pipe to write!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">bool</span> <span class="title">Write</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">char</span> c = <span class="string">&#x27;c&#x27;</span>;</span><br><span class="line">        <span class="type">size_t</span> n = <span class="built_in">write</span>(_fd, &amp;c, <span class="number">1</span>);</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Awaken server!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        <span class="keyword">return</span> n &gt; <span class="number">0</span> ? <span class="number">1</span> : <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="function"><span class="type">ssize_t</span> <span class="title">Read</span><span class="params">()</span></span></span><br><span class="line"><span class="function">    </span>&#123;</span><br><span class="line">        <span class="type">char</span> c = <span class="string">&#x27;0&#x27;</span>;</span><br><span class="line">        <span class="type">ssize_t</span> n = <span class="built_in">read</span>(_fd, &amp;c, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">if</span> (n &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">ERROR</span>(<span class="string">&quot;read&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> n;</span><br><span class="line">    &#125;</span><br><span class="line">    ~<span class="built_in">FileOper</span>()</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (_fd &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="type">int</span> n = <span class="built_in">close</span>(_fd);</span><br><span class="line">            <span class="keyword">if</span> (n &lt; <span class="number">0</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">ERROR</span>(<span class="string">&quot;close&quot;</span>);</span><br><span class="line">            &#125;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Close file descriptor!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">private</span>:</span><br><span class="line">    std::string _name;</span><br><span class="line">    <span class="type">int</span> _fd;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><code>server.hpp</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;common.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;fifo.hpp&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">SharedMemory <span class="title">shm</span><span class="params">(<span class="number">4096</span>, CRE)</span></span>;</span><br><span class="line">    <span class="function">NamedPipe <span class="title">fifo</span><span class="params">(FIFO_NAME)</span></span>;</span><br><span class="line">    <span class="function">FileOper <span class="title">fp</span><span class="params">(FIFO_NAME)</span></span>;</span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">    <span class="comment">// 附加共享内存</span></span><br><span class="line">    shm.<span class="built_in">Attach</span>();</span><br><span class="line">    fp.<span class="built_in">OpenForRead</span>();</span><br><span class="line">    <span class="comment">// 获取虚拟地址</span></span><br><span class="line">    <span class="type">char</span> *msg = shm.<span class="built_in">GetVirtualSpace</span>();</span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">2</span>);</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;----Start communication----&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">ssize_t</span> n = fp.<span class="built_in">Read</span>();</span><br><span class="line">        <span class="keyword">if</span> (n &gt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Wake up!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Get message:&quot;</span> &lt;&lt; msg &lt;&lt; <span class="string">&quot;\n&quot;</span></span><br><span class="line">                      &lt;&lt; std::endl;</span><br><span class="line">            <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (n == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Exiting!&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            std::cout &lt;&lt; <span class="string">&quot;Unknown error&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">            ;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;----End communication----&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="comment">// 移除附加关系</span></span><br><span class="line">    shm.<span class="built_in">DeTach</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<p><code>client.hpp</code></p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;common.hpp&quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;fifo.hpp&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="type">int</span> <span class="title">main</span><span class="params">()</span></span></span><br><span class="line"><span class="function"></span>&#123;</span><br><span class="line">    <span class="function">SharedMemory <span class="title">shm</span><span class="params">(<span class="number">4096</span>, USE)</span></span>;</span><br><span class="line">    <span class="function">FileOper <span class="title">fp</span><span class="params">(FIFO_NAME)</span></span>;</span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">    shm.<span class="built_in">Attach</span>();</span><br><span class="line">    fp.<span class="built_in">OpenForWrite</span>();</span><br><span class="line">    <span class="type">char</span> *msg = shm.<span class="built_in">GetVirtualSpace</span>();</span><br><span class="line">    <span class="built_in">sleep</span>(<span class="number">2</span>);</span><br><span class="line">    <span class="type">int</span> index = <span class="number">0</span>;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;----Start communication----&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">char</span> c = <span class="string">&#x27;A&#x27;</span>; c &lt;= <span class="string">&#x27;E&#x27;</span>; c++, index += <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;Wrote to server:&quot;</span>;</span><br><span class="line">        msg[index] = c;</span><br><span class="line">        msg[index + <span class="number">1</span>] = c;</span><br><span class="line">        msg[index + <span class="number">2</span>] = <span class="string">&#x27;\0&#x27;</span>;</span><br><span class="line">        std::cout &lt;&lt; c &lt;&lt; c &lt;&lt; std::endl;</span><br><span class="line"></span><br><span class="line">        fp.<span class="built_in">Write</span>();</span><br><span class="line">        std::cout &lt;&lt; <span class="string">&quot;\n&quot;</span>;</span><br><span class="line">        <span class="built_in">sleep</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    std::cout &lt;&lt; <span class="string">&quot;----End communication----&quot;</span> &lt;&lt; std::endl;</span><br><span class="line">    shm.<span class="built_in">DeTach</span>();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><strong>效果</strong><br>终端一 <code>server</code></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">$ ./server </span><br><span class="line">key: cc01006e</span><br><span class="line">shared memory indentifier: 35</span><br><span class="line">Make fifo success!</span><br><span class="line">Open named pipe to <span class="built_in">read</span>!</span><br><span class="line">Virtual space address: 0x7fc5d3fb2000</span><br><span class="line">----Start communication----</span><br><span class="line">Wake up!</span><br><span class="line">Get message:AA</span><br><span class="line"></span><br><span class="line">Wake up!</span><br><span class="line">Get message:AABB</span><br><span class="line"></span><br><span class="line">Wake up!</span><br><span class="line">Get message:AABBCC</span><br><span class="line"></span><br><span class="line">Wake up!</span><br><span class="line">Get message:AABBCCDD</span><br><span class="line"></span><br><span class="line">Wake up!</span><br><span class="line">Get message:AABBCCDDEE</span><br><span class="line"></span><br><span class="line">Exiting!</span><br><span class="line">----End communication----</span><br><span class="line">Disattach success!</span><br><span class="line">Verification successful: Creator</span><br><span class="line">Remove shared memory <span class="built_in">id</span> success!</span><br><span class="line">Close file descriptor!</span><br><span class="line">Unlink success!</span><br><span class="line">$ </span><br></pre></td></tr></table></figure>
<p>终端二 <code>client</code></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">$ ./client </span><br><span class="line">key: cc01006e</span><br><span class="line">shared memory indentifier: 35</span><br><span class="line">Open named pipe to write!</span><br><span class="line">Virtual space address: 0x74e910e2c000</span><br><span class="line">----Start communication----</span><br><span class="line">Wrote to server:AA</span><br><span class="line">Awaken server!</span><br><span class="line"></span><br><span class="line">Wrote to server:BB</span><br><span class="line">Awaken server!</span><br><span class="line"></span><br><span class="line">Wrote to server:CC</span><br><span class="line">Awaken server!</span><br><span class="line"></span><br><span class="line">Wrote to server:DD</span><br><span class="line">Awaken server!</span><br><span class="line"></span><br><span class="line">Wrote to server:EE</span><br><span class="line">Awaken server!</span><br><span class="line"></span><br><span class="line">----End communication----</span><br><span class="line">Disattach success!</span><br><span class="line">Close file descriptor!</span><br><span class="line">$ </span><br></pre></td></tr></table></figure>
<p>终端三 监控</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="keyword">while</span> :; <span class="keyword">do</span> ipcs -m; <span class="built_in">sleep</span> 1; <span class="keyword">done</span></span><br><span class="line"></span><br><span class="line">------ Shared Memory Segments --------</span><br><span class="line">key        shmid      owner      perms      bytes      nattch     status      </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">------ Shared Memory Segments --------</span><br><span class="line">key        shmid      owner      perms      bytes      nattch     status      </span><br><span class="line">0xcc01006e 35         wyf        666        4096       0                       </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">------ Shared Memory Segments --------</span><br><span class="line">key        shmid      owner      perms      bytes      nattch     status      </span><br><span class="line">0xcc01006e 35         wyf        666        4096       1                       </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">------ Shared Memory Segments --------</span><br><span class="line">key        shmid      owner      perms      bytes      nattch     status      </span><br><span class="line">0xcc01006e 35         wyf        666        4096       1                       </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">------ Shared Memory Segments --------</span><br><span class="line">key        shmid      owner      perms      bytes      nattch     status      </span><br><span class="line">0xcc01006e 35         wyf        666        4096       2                       </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">------ Shared Memory Segments --------</span><br><span class="line">key        shmid      owner      perms      bytes      nattch     status      </span><br><span class="line">0xcc01006e 35         wyf        666        4096       2                       </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">------ Shared Memory Segments --------</span><br><span class="line">key        shmid      owner      perms      bytes      nattch     status      </span><br><span class="line">0xcc01006e 35         wyf        666        4096       2                       </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">------ Shared Memory Segments --------</span><br><span class="line">key        shmid      owner      perms      bytes      nattch     status      </span><br><span class="line">0xcc01006e 35         wyf        666        4096       2                       </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">------ Shared Memory Segments --------</span><br><span class="line">key        shmid      owner      perms      bytes      nattch     status      </span><br><span class="line">0xcc01006e 35         wyf        666        4096       2                       </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">------ Shared Memory Segments --------</span><br><span class="line">key        shmid      owner      perms      bytes      nattch     status      </span><br><span class="line">0xcc01006e 35         wyf        666        4096       2                       </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">------ Shared Memory Segments --------</span><br><span class="line">key        shmid      owner      perms      bytes      nattch     status      </span><br><span class="line">0xcc01006e 35         wyf        666        4096       2                       </span><br><span class="line"></span><br><span class="line"></span><br><span class="line">------ Shared Memory Segments --------</span><br><span class="line">key        shmid      owner      perms      bytes      nattch     status      </span><br><span class="line">  </span><br><span class="line"></span><br><span class="line">^C</span><br><span class="line"> 130 $ </span><br></pre></td></tr></table></figure>

<p><strong>通信过程</strong></p>
<!-- ![1752999532982](image/进程间通信/1752999532982.png) -->
<img src="/2025/11/24/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/1752999532982.png" class="">

<h4 id="5-2-消息队列"><a href="#5-2-消息队列" class="headerlink" title="5.2 消息队列"></a>5.2 消息队列</h4><h5 id="5-2-1-概念理解"><a href="#5-2-1-概念理解" class="headerlink" title="5.2.1 概念理解"></a>5.2.1 概念理解</h5><p>消息队列（<code>Message Queue</code>）是 <code>System V IPC</code> 三大核心机制之一，它提供了一种<strong>结构化、异步、解耦</strong>的进程间通信方式。理解其设计原理需要把握以下核心概念：</p>
<p>消息队列的本质是<strong>由操作系统内核维护的先进先出（FIFO）消息缓冲区</strong>：</p>
<ol>
<li><p><strong>结构化存储</strong>：<br>每条消息由两部分组成：</p>
<ul>
<li><strong>消息类型</strong>（正整数标识符）</li>
<li><strong>消息正文</strong>（用户定义的二进制数据块）</li>
</ul>
</li>
<li><p><strong>内核持久性</strong>：<br>消息队列独立于进程存在，即使创建它的进程终止，队列和其中未消费的消息仍保留在内核中</p>
</li>
<li><p><strong>异步通信</strong>：<br>发送方和接收方无需同时在线：</p>
<!-- ![1753002225267](image/进程间通信/1753002225267.png) -->
<img src="/2025/11/24/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/1753002225267.png" class=""></li>
</ol>
<p><strong>1. 消息存储结构</strong></p>
<!-- ![1753005086786](image/进程间通信/1753005086786.png) -->
<img src="/2025/11/24/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/1753005086786.png" class="">

<ul>
<li>每条消息按<strong>到达顺序</strong>链接，但接收时可<strong>按类型选择性读取</strong></li>
<li>内核为每个队列维护元数据：<ul>
<li>当前消息数量</li>
<li>最大消息尺寸</li>
<li>最后操作时间戳</li>
<li>访问权限控制</li>
</ul>
</li>
</ul>
<p><strong>2. 消息发送&#x2F;接收机制</strong></p>
<table>
<thead>
<tr>
<th>操作</th>
<th>原理</th>
</tr>
</thead>
<tbody><tr>
<td><strong>发送(msg_snd)</strong></td>
<td>进程将消息追加到队列尾部，若队列满则阻塞或立即返回（由标志位控制）</td>
</tr>
<tr>
<td><strong>接收(msg_rcv)</strong></td>
<td>进程从队列头部检索消息，可选择：<br> - 读取最早消息（<code>FIFO</code>）<br> - 读取特定类型的首条消息</td>
</tr>
</tbody></table>
<p><strong>3. 类型驱动的消息筛选</strong><br>这是消息队列最强大的特性：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">msgrcv(queue_id, buffer, size, msg_type, flags);</span><br></pre></td></tr></table></figure>
<ul>
<li><strong><code>msg_type = 0</code></strong>：读取队列中第一条消息（<code>FIFO</code>）</li>
<li><strong><code>msg_type &gt; 0</code></strong>：读取队列中<strong>第一条类型等于该值</strong>的消息</li>
<li><strong><code>msg_type &lt; 0</code></strong>：读取队列中<strong>类型值最小且 ≤ |msg_type|</strong> 的消息</li>
</ul>
<blockquote>
<p>示例：若队列包含消息类型 [100, 200, 50, 100]</p>
<ul>
<li><code>msg_type=0</code> → 返回类型100的消息</li>
<li><code>msg_type=100</code> → 返回类型100的消息</li>
<li><code>msg_type=-150</code> → 返回类型50的消息（满足50 ≤ 150且最小）</li>
</ul>
</blockquote>
<p><strong>4. <code>System V</code> 特性</strong>：</p>
<ol>
<li><strong>解耦性</strong>：分离发送方和接收方的生命周期</li>
<li><strong>结构化</strong>：通过消息类型实现数据分类管理</li>
<li><strong>流量控制</strong>：内置阻塞机制防止数据丢失</li>
<li><strong>持久性</strong>：内核托管确保消息可靠性</li>
<li><strong>优先级支持</strong>：通过类型值实现灵活调度</li>
</ol>
<blockquote>
<p><strong>关键📌</strong>：消息队列本质是操作系统内核提供的一个<strong>轻量级消息中间件</strong>，它填补了简单管道与复杂网络通信之间的空白，为单机多进程系统提供了可靠的消息传递基础设施。其类型驱动的消息选择机制是其区别于其他IPC的核心创新点</p>
</blockquote>
<h5 id="5-2-2-系统调用"><a href="#5-2-2-系统调用" class="headerlink" title="5.2.2 系统调用"></a>5.2.2 系统调用</h5><p><strong>核心系统调用接口</strong></p>
<p><strong>1. <code>msgget</code> - 获取消息队列标识符</strong><br><strong>功能</strong>：创建新消息队列或获取现有队列标识符</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/msg.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">msgget</span><span class="params">(<span class="type">key_t</span> key, <span class="type">int</span> msgflg)</span>;</span><br></pre></td></tr></table></figure>

<p><strong>参数</strong>：</p>
<ul>
<li><p><code>key_t key</code>：</p>
<ul>
<li><strong>作用</strong>：唯一标识消息队列的键值</li>
<li><strong>生成方式</strong>：<ul>
<li><code>ftok(path, id)</code>：使用文件路径和项目 <code>ID</code> 生成唯一键</li>
<li><code>IPC_PRIVATE</code>：创建私有队列（仅限有亲缘关系的进程）</li>
</ul>
</li>
<li><strong>示例</strong>：<code>key_t mykey = ftok(&quot;/tmp/app&quot;, &#39;A&#39;);</code></li>
</ul>
</li>
<li><p><code>int msgflg</code>：</p>
<ul>
<li><strong>作用</strong>：控制队列创建和访问权限</li>
<li><strong>组成</strong>：<ul>
<li><strong>权限位</strong>：低9位指定访问权限（类似文件权限）<ul>
<li>示例：<code>0666</code>（所有者、组、其他人可读写）</li>
</ul>
</li>
<li><strong>创建标志</strong>：<ul>
<li><code>IPC_CREAT</code>：队列不存在则创建</li>
<li><code>IPC_EXCL</code>：与<code>IPC_CREAT</code>联用，确保创建新队列</li>
</ul>
</li>
</ul>
</li>
<li><strong>常用组合</strong>：<ul>
<li><code>IPC_CREAT | 0666</code>：获取或创建队列</li>
<li><code>IPC_CREAT | IPC_EXCL | 0600</code>：独占创建新队列</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>返回值</strong>：</p>
<ul>
<li>成功：非负整数（消息队列标识符）</li>
<li>失败：<code>-1</code>（设置 <code>errno</code>）</li>
</ul>
<p><strong>2. <code>msgsnd</code> - 发送消息</strong><br><strong>功能</strong>：向消息队列发送消息</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">msgsnd</span><span class="params">(<span class="type">int</span> msqid, <span class="type">const</span> <span class="type">void</span> *msgp, <span class="type">size_t</span> msgsz, <span class="type">int</span> msgflg)</span>;</span><br></pre></td></tr></table></figure>

<p><strong>参数</strong>：</p>
<ul>
<li><p><code>int msqid</code>：</p>
<ul>
<li><strong>作用</strong>：消息队列标识符（来自msgget）</li>
<li><strong>示例</strong>：<code>int qid = msgget(key, flags);</code></li>
</ul>
</li>
<li><p><code>const void *msgp</code>：</p>
<ul>
<li><strong>作用</strong>：指向消息结构体的指针</li>
<li><strong>结构要求</strong>：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mymsg</span> &#123;</span></span><br><span class="line">    <span class="type">long</span> mtype;     <span class="comment">// 消息类型（必须&gt;0）</span></span><br><span class="line">    <span class="type">char</span> mtext[<span class="number">100</span>];<span class="comment">// 消息内容</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li><strong>注意</strong>：第一个字段必须是<code>long</code>类型的消息类型</li>
</ul>
</li>
<li><p><code>size_t msgsz</code>：</p>
<ul>
<li><strong>作用</strong>：<strong>消息正文的大小（字节）</strong></li>
<li><strong>范围</strong>：<code>0</code> - 系统限制（<code>cat /proc/sys/kernel/msgmax</code>）</li>
<li><strong>注意</strong>：不包括<code>mtype</code>字段的大小</li>
</ul>
</li>
<li><p><code>int msgflg</code>：</p>
<ul>
<li><strong>作用</strong>：控制发送行为</li>
<li><strong>选项</strong>：<ul>
<li><code>0</code>：默认行为（队列满时阻塞）</li>
<li><code>IPC_NOWAIT</code>：队列满时立即返回EAGAIN错误</li>
<li><code>MSG_COPY</code> (Linux特有)：非破坏性读取</li>
<li><code>MSG_EXCEPT</code>：接收非指定类型的消息</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>3. <code>msgrcv</code> - 接收消息</strong><br><strong>功能</strong>：从消息队列接收消息</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">ssize_t</span> <span class="title function_">msgrcv</span><span class="params">(<span class="type">int</span> msqid, <span class="type">void</span> *msgp, <span class="type">size_t</span> msgsz, <span class="type">long</span> msgtyp, <span class="type">int</span> msgflg)</span>;</span><br></pre></td></tr></table></figure>

<p><strong>参数</strong>：</p>
<ul>
<li><p><code>int msqid</code>：消息队列标识符</p>
</li>
<li><p><code>void *msgp</code>：接收消息的缓冲区指针</p>
</li>
<li><p><code>size_t msgsz</code>：</p>
<ul>
<li><strong>作用</strong>：接收缓冲区的大小</li>
<li><strong>特殊处理</strong>：<ul>
<li>如果实际消息 &gt; <code>msgsz</code>：<ul>
<li>未设<code>MSG_NOERROR</code>：返回 <code>E2BIG</code> 错误</li>
<li>设置<code>MSG_NOERROR</code>：截断消息</li>
</ul>
</li>
</ul>
</li>
</ul>
</li>
<li><p><code>long msgtyp</code>：</p>
<ul>
<li><strong>作用</strong>：消息选择器（核心特性）</li>
<li><strong>取值</strong>：<ul>
<li><code>0</code>：读取队列中第一条消息</li>
<li><code>&gt; 0</code>：读取第一条类型等于 <code>msgtyp</code> 的消息</li>
<li><code>&lt; 0</code>：读取类型值最小且 ≤ <code>|msgtyp|</code> 的消息</li>
</ul>
</li>
<li><strong>示例</strong>：<ul>
<li><code>msgtyp = 100</code>：只接收类型 <code>100</code> 的消息</li>
<li><code>msgtyp = -50</code>：接收类型 ≤ <code>50</code> 的最小类型消息</li>
</ul>
</li>
</ul>
</li>
<li><p><code>int msgflg</code>：</p>
<ul>
<li><strong>作用</strong>：控制接收行为</li>
<li><strong>选项</strong>：<ul>
<li><code>0</code>：默认行为（无匹配消息时阻塞）</li>
<li><code>IPC_NOWAIT</code>：无匹配消息时立即返回</li>
<li><code>MSG_NOERROR</code>：允许截断超长消息</li>
<li><code>MSG_EXCEPT</code>：接收非 <code>msgtyp</code> 类型的消息</li>
</ul>
</li>
</ul>
</li>
</ul>
<p><strong>4. <code>msgctl</code> - 控制消息队列</strong><br><strong>功能</strong>：管理消息队列状态</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">msgctl</span><span class="params">(<span class="type">int</span> msqid, <span class="type">int</span> cmd, <span class="keyword">struct</span> msqid_ds *buf)</span>;</span><br></pre></td></tr></table></figure>

<p><strong>参数</strong>：</p>
<ul>
<li><p><code>int msqid</code>：消息队列标识符</p>
</li>
<li><p><code>int cmd</code>：</p>
<ul>
<li><strong>控制命令</strong>：<ul>
<li><code>IPC_STAT</code>：获取队列状态到 <code>buf</code></li>
<li><code>IPC_SET</code>：通过 <code>buf</code> 设置队列参数</li>
<li><code>IPC_RMID</code>：<strong>立即删除消息队列</strong></li>
<li><code>IPC_INFO</code>：获取系统级 <code>IPC</code> 信息</li>
<li><code>MSG_INFO</code>：获取资源消耗信息</li>
<li><code>MSG_STAT</code>：通过索引获取队列状态</li>
</ul>
</li>
</ul>
</li>
<li><p><code>struct msqid_ds *buf</code>：</p>
<ul>
<li><strong>作用</strong>：状态信息结构体</li>
<li><strong>关键字段</strong>：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msqid_ds</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ipc_perm</span> <span class="title">msg_perm</span>;</span>  <span class="comment">// 权限结构</span></span><br><span class="line">    <span class="type">time_t</span> msg_stime;          <span class="comment">// 最后发送时间</span></span><br><span class="line">    <span class="type">time_t</span> msg_rtime;          <span class="comment">// 最后接收时间</span></span><br><span class="line">    <span class="type">time_t</span> msg_ctime;          <span class="comment">// 最后修改时间</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> __msg_cbytes;<span class="comment">// 当前队列字节数</span></span><br><span class="line">    <span class="type">msgqnum_t</span> msg_qnum;        <span class="comment">// 当前消息数</span></span><br><span class="line">    <span class="type">msglen_t</span> msg_qbytes;       <span class="comment">// 最大字节数</span></span><br><span class="line">    <span class="type">pid_t</span> msg_lspid;           <span class="comment">// 最后发送PID</span></span><br><span class="line">    <span class="type">pid_t</span> msg_lrpid;           <span class="comment">// 最后接收PID</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ipc_perm</span> &#123;</span></span><br><span class="line">    <span class="type">key_t</span> __key;       <span class="comment">// 创建时使用的key</span></span><br><span class="line">    <span class="type">uid_t</span> uid;         <span class="comment">// 所有者UID</span></span><br><span class="line">    <span class="type">gid_t</span> gid;         <span class="comment">// 所有者GID</span></span><br><span class="line">    <span class="type">uid_t</span> cuid;        <span class="comment">// 创建者UID</span></span><br><span class="line">    <span class="type">gid_t</span> cgid;        <span class="comment">// 创建者GID</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> mode; <span class="comment">// 权限模式</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
</ul>
<p><strong>5. 消息队列生命周期管理</strong></p>
<ol>
<li><p>创建消息队列</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">key_t</span> key = ftok(<span class="string">&quot;/tmp/myapp&quot;</span>, <span class="string">&#x27;A&#x27;</span>);</span><br><span class="line"><span class="type">int</span> msqid = msgget(key, IPC_CREAT | <span class="number">0666</span>);</span><br><span class="line"><span class="keyword">if</span> (msqid == <span class="number">-1</span>) &#123;</span><br><span class="line">    perror(<span class="string">&quot;msgget failed&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(EXIT_FAILURE);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>发送消息</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">message</span> &#123;</span></span><br><span class="line">    <span class="type">long</span> mtype;</span><br><span class="line">    <span class="type">char</span> mtext[<span class="number">100</span>];</span><br><span class="line">&#125; msg;</span><br><span class="line"></span><br><span class="line">msg.mtype = <span class="number">1</span>; <span class="comment">// 消息类型</span></span><br><span class="line"><span class="built_in">strcpy</span>(msg.mtext, <span class="string">&quot;Hello Message Queue!&quot;</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (msgsnd(msqid, &amp;msg, <span class="built_in">strlen</span>(msg.mtext)+<span class="number">1</span>, <span class="number">0</span>) == <span class="number">-1</span>) &#123;</span><br><span class="line">    perror(<span class="string">&quot;msgsnd failed&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>接收消息</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">message</span> <span class="title">rcv_msg</span>;</span></span><br><span class="line"><span class="type">ssize_t</span> bytes = msgrcv(msqid, &amp;rcv_msg, <span class="keyword">sizeof</span>(rcv_msg.mtext), <span class="number">1</span>, <span class="number">0</span>);</span><br><span class="line"><span class="keyword">if</span> (bytes == <span class="number">-1</span>) &#123;</span><br><span class="line">    perror(<span class="string">&quot;msgrcv failed&quot;</span>);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Received: %s\n&quot;</span>, rcv_msg.mtext);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
<li><p>删除消息队列</p>
 <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (msgctl(msqid, IPC_RMID, <span class="literal">NULL</span>) == <span class="number">-1</span>) &#123;</span><br><span class="line">    perror(<span class="string">&quot;msgctl(IPC_RMID) failed&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li>
</ol>
<p><strong>整个过程</strong></p>
<!-- ![1753005122353](image/进程间通信/1753005122353.png) -->
<img src="/2025/11/24/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/1753005122353.png" class="">

<h4 id="5-3-信号量"><a href="#5-3-信号量" class="headerlink" title="5.3 信号量"></a>5.3 信号量</h4><h5 id="5-3-1-信号量的核心概念"><a href="#5-3-1-信号量的核心概念" class="headerlink" title="5.3.1 信号量的核心概念"></a>5.3.1 信号量的核心概念</h5><p><strong>1. 信号量是什么？</strong><br>信号量是一种<strong>操作系统提供的同步原语</strong>，用于协调多个进程（或线程）对共享资源的访问。它本质上是一个<strong>带等待队列的计数器</strong>，提供两种基本操作：</p>
<ul>
<li><strong>P操作</strong>（等待&#x2F;获取）：尝试获取资源权限</li>
<li><strong>V操作</strong>（释放&#x2F;通知）：释放资源权限</li>
</ul>
<blockquote>
<p><strong>关键📌</strong>：信号量不是资源本身，而是<strong>控制资源访问的交通信号灯系统</strong></p>
</blockquote>
<p><strong>2. 信号量的三大核心要素</strong></p>
<!-- ![1753012927529](image/进程间通信/1753012927529.png) -->
<img src="/2025/11/24/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/1753012927529.png" class="">

<p>(1) 计数器（<code>Counter</code>）</p>
<ul>
<li><strong>物理意义</strong>：当前可用资源的数量</li>
<li><strong>初始值</strong>：系统启动时的资源总数（如：<code>N</code> 个共享内存区）</li>
<li><strong>取值范围</strong>：非负整数（<code>≥ 0</code>）</li>
<li><strong>特殊值</strong>：<ul>
<li><strong>0</strong>：资源已耗尽，新请求需等待</li>
<li><strong>1</strong>：二进制信号量（互斥锁）</li>
</ul>
</li>
</ul>
<p>(2) 等待队列（<code>Wait Queue</code>）</p>
<ul>
<li>当资源不足时：<ul>
<li>请求资源的进程被放入队列</li>
<li>进程进入睡眠状态（不消耗 <code>CPU</code>）</li>
</ul>
</li>
<li>资源释放时：<ul>
<li>从队列唤醒等待最久的进程</li>
<li>唤醒的进程获得资源使用权</li>
</ul>
</li>
</ul>
<p>(3) 原子操作（<code>Atomic Operations</code>）</p>
<table>
<thead>
<tr>
<th>操作</th>
<th>名称</th>
<th>伪代码</th>
<th>行为描述</th>
</tr>
</thead>
<tbody><tr>
<td><strong>P</strong></td>
<td><code>Proberen</code><br>（尝试获取）</td>
<td><code>if(计数器&gt;0) 计数器--</code><br><code>else 加入等待队列</code></td>
<td>申请资源：有则立即获取，无则阻塞等待</td>
</tr>
<tr>
<td><strong>V</strong></td>
<td><code>Verhogen</code><br>（增加释放）</td>
<td><code>计数器++</code><br><code>if(等待队列非空) 唤醒首个进程</code></td>
<td>释放资源：计数器增加并唤醒等待进程</td>
</tr>
</tbody></table>
<blockquote>
<p><strong>原子性保证</strong>：操作系统确保P&#x2F;V操作执行过程<strong>不可中断</strong>，避免竞态条件</p>
</blockquote>
<p>举一个电影院的列子</p>
<p>想象一个热映电影的首映式：</p>
<ul>
<li><strong>资源</strong>：电影院里的 <code>100</code> 个座位</li>
<li><strong>观众</strong>：想要入场的观众（相当于进程）</li>
<li><strong>售票系统</strong>：信号量机制</li>
</ul>
<!-- ![1753013495410](image/进程间通信/1753013495410.png) -->
<img src="/2025/11/24/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/1753013495410.png" class="">

<table>
<thead>
<tr>
<th>信号量组件</th>
<th>电影院类比</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td>计数器</td>
<td>剩余座位显示器</td>
<td>显示当前可售座位数</td>
</tr>
<tr>
<td>P操作</td>
<td>购票流程</td>
<td>尝试获取座位</td>
</tr>
<tr>
<td>V操作</td>
<td>退票&#x2F;离场流程</td>
<td>释放座位</td>
</tr>
<tr>
<td>等待队列</td>
<td>观众排队区</td>
<td>无座时的等待区域</td>
</tr>
</tbody></table>
<p>工作流程</p>
<!-- ![1753013883954](image/进程间通信/1753013883954.png) -->
<img src="/2025/11/24/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/1753013883954.png" class="">

<ol>
<li>初始状态（电影开场前）</li>
</ol>
<ul>
<li>余票计数器 &#x3D; <code>100</code></li>
<li>排队区为空</li>
</ul>
<ol start="2">
<li>正常购票（<code>P</code> 操作）</li>
</ol>
<ul>
<li>前100位观众：立即获得座位</li>
<li>第101位观众：进入排队区等待</li>
</ul>
<ol start="3">
<li>座位释放（<code>V</code> 操作）</li>
</ol>
<ul>
<li><strong>关键机制</strong>：唤醒排队者时，座位直接转移（原子操作）</li>
<li><strong>避免竞态</strong>：不会出现”座位被其他人抢走”的情况</li>
</ul>
<ol start="4">
<li>特殊场景处理</li>
</ol>
<table>
<thead>
<tr>
<th>场景</th>
<th>信号量解决方案</th>
<th>现实类比</th>
</tr>
</thead>
<tbody><tr>
<td>团体票（<code>10</code> 人）</td>
<td>一次性申请10个座位</td>
<td><code>sem_op = -10</code></td>
</tr>
<tr>
<td>VIP优先购票</td>
<td>优先级等待队列</td>
<td>特殊通道排队</td>
</tr>
<tr>
<td>临时加座</td>
<td>动态增加信号量初值</td>
<td>开放二楼观影区</td>
</tr>
<tr>
<td>影院清场（故障）</td>
<td><code>semctl(IPC_RMID)</code></td>
<td>紧急疏散并关闭售票系统</td>
</tr>
</tbody></table>
<p><strong>5. 信号量的原子操作</strong>确保：</p>
<ul>
<li>检查余票</li>
<li>减少计数器</li>
<li>发放座位</li>
<li>这三个步骤<strong>不可分割</strong>执行，避免超卖问题</li>
</ul>
<p>其实也就是<strong>资源访问权的数字化表示</strong>：</p>
<ol>
<li><strong>计数器</strong>：量化资源的可用性</li>
<li><strong>等待队列</strong>：管理资源的请求者</li>
<li><strong>原子操作</strong>：保证状态转换的可靠性</li>
</ol>
<blockquote>
<p>当多个进程需要<strong>有序访问共享资源</strong>时，信号量通过”计数-等待-唤醒”机制：</p>
<ul>
<li>防止资源冲突（互斥访问）</li>
<li>避免资源耗尽（限额控制）</li>
<li>优化资源分配（公平调度）</li>
</ul>
</blockquote>
<p><strong>补充</strong><br>信号量根据其计数器的取值可分为两种基本类型：</p>
<!-- ![1753014581090](image/进程间通信/1753014581090.png) -->
<img src="/2025/11/24/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/1753014581090.png" class="">

<p><strong>1. 二元信号量（Binary Semaphore）</strong></p>
<ul>
<li><strong>计数器范围</strong>：<code>0</code> 或 <code>1</code></li>
<li><strong>别名</strong>：互斥锁（<code>Mutex</code>）</li>
<li><strong>核心功能</strong>：实现<strong>互斥访问</strong></li>
<li><strong>典型应用</strong>：保护临界区资源</li>
</ul>
<p><strong>2. 多元信号量（Counting Semaphore）</strong></p>
<ul>
<li><strong>计数器范围</strong>：<code>0</code> 到<code> N</code>（<code>N &gt; 1</code>）</li>
<li><strong>别名</strong>：计数信号量</li>
<li><strong>核心功能</strong>：管理<strong>资源池</strong></li>
<li><strong>典型应用</strong>：控制多实例资源访问</li>
</ul>
<blockquote>
<p>当资源实例数&gt;1时优先考虑多元信号量；当需要严格互斥时使用二元信号量。在System V IPC中，两者使用相同的API，通过初始值区分功能：初值&#x3D;1是二元信号量，初值&#x3D;N&gt;1是多元信号量</p>
</blockquote>
<blockquote>
<p><strong>关键📌</strong>：信号量的设计哲学体现了计算机科学中最深刻的<strong>同步思想</strong>：当无法消除竞争时，通过<strong>受控的等待</strong>实现有序访问</p>
</blockquote>
<h5 id="5-3-2-系统调用"><a href="#5-3-2-系统调用" class="headerlink" title="5.3.2 系统调用"></a>5.3.2 系统调用</h5><p>信号量的常用系统调用有三个：<code>semget</code>、<code>semop</code>、<code>semctl</code></p>
<p><strong>1. <code>semget</code> - 创建&#x2F;获取信号量集</strong><br><strong>功能</strong>：创建新信号量集或获取已有信号量集标识符<br><strong>函数原型</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/sem.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">semget</span><span class="params">(<span class="type">key_t</span> key, <span class="type">int</span> nsems, <span class="type">int</span> semflg)</span>;</span><br></pre></td></tr></table></figure>
<p><strong>参数</strong>：</p>
<ul>
<li><code>key</code>：信号量集键值<ul>
<li><code>IPC_PRIVATE</code>：创建私有信号量集（仅相关进程可见）</li>
<li><code>ftok()</code>生成：用于跨进程<strong>访问同一信号量集</strong></li>
</ul>
</li>
<li><code>nsems</code>：信号量数量<ul>
<li>创建时：必须 <code>&gt; 0</code>，指定集合中信号量个数</li>
<li>获取已有：设为 <code>0</code></li>
</ul>
</li>
<li><code>semflg</code>：标志位（位或组合）<ul>
<li><code>IPC_CREAT</code>：不存在则创建</li>
<li><code>IPC_EXCL</code>：与<code>IPC_CREAT</code>同用时，若已存在则失败</li>
<li>权限位：如<code>0666</code>（八进制读写权限）</li>
</ul>
</li>
</ul>
<p><strong>返回值</strong>：<br>成功返回信号量集标识符（非负整数），失败返回 <code>-1</code></p>
<p><strong>2. <code>semop</code> - 信号量操作</strong><br><strong>功能</strong>：执行信号量的 <code>P</code>&#x2F;<code>V</code> 操作（申请&#x2F;释放资源）<br><strong>函数原型</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/sem.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">semop</span><span class="params">(<span class="type">int</span> semid, <span class="keyword">struct</span> sembuf *sops, <span class="type">size_t</span> nsops)</span>;</span><br></pre></td></tr></table></figure>
<p><strong>参数说明</strong>：</p>
<ul>
<li><code>semid</code>：<code>semget</code>返回的标识符</li>
<li><code>sops</code>：操作结构体数组指针</li>
<li><code>nsops</code>：操作数组长度（需操作信号量个数）</li>
</ul>
<p><strong>sembuf结构体</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sembuf</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> sem_num;  <span class="comment">// 信号量在集合中的索引（0起始）</span></span><br><span class="line">    <span class="type">short</span> sem_op;   <span class="comment">// 操作类型：</span></span><br><span class="line">                   <span class="comment">//   -1：P操作（申请资源，若资源不足则阻塞）</span></span><br><span class="line">                   <span class="comment">//   +1：V操作（释放资源）</span></span><br><span class="line">                   <span class="comment">//    0：等待信号量变为0</span></span><br><span class="line">    <span class="type">short</span> sem_flg;  <span class="comment">// 标志位：</span></span><br><span class="line">                   <span class="comment">//   IPC_NOWAIT：非阻塞模式</span></span><br><span class="line">                   <span class="comment">//   SEM_UNDO：进程退出时自动撤销操作</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>返回值</strong>：成功返回 <code>0</code>，失败返回 <code>-1</code></p>
<p><strong>3. <code>semctl</code> - 信号量控制</strong><br><strong>功能</strong>：初始化、删除或查询信号量<br><strong>函数原型</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/sem.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">semctl</span><span class="params">(<span class="type">int</span> semid, <span class="type">int</span> semnum, <span class="type">int</span> cmd, ... <span class="comment">/* union semun arg */</span>)</span>;</span><br></pre></td></tr></table></figure>
<p><strong>参数说明</strong>：</p>
<ul>
<li><code>semid</code>：信号量集标识符</li>
<li><code>semnum</code>：信号量在集合中的索引</li>
<li><code>cmd</code>：控制命令：<ul>
<li><code>IPC_STAT</code> - 获取信号量集状态</li>
<li><code>IPC_SET</code> - 修改信号量集属性</li>
<li><code>IPC_RMID</code>：立即删除信号量集（忽略<code>semnum</code>）</li>
<li><code>SETVAL</code>：设置单个信号量值（需第四个参数）</li>
<li><code>GETVAL</code>：获取单个信号量值</li>
<li><code>SETALL</code>：设置所有信号量值</li>
<li><code>GETALL</code>：获取所有信号量值</li>
</ul>
</li>
<li>第四个参数：<code>union semun</code>（需用户自定义）：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">semun</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> val;               <span class="comment">// SETVAL使用</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">semid_ds</span> *<span class="title">buf</span>;</span>  <span class="comment">// IPC_STAT/IPC_SET使用</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> *<span class="built_in">array</span>; <span class="comment">// SETALL/GETALL使用</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
<li><strong>关键字段</strong>  <figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">semid_ds</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ipc_perm</span> <span class="title">sem_perm</span>;</span>  <span class="comment">// 权限控制结构（见下文）</span></span><br><span class="line">    <span class="type">time_t</span>          sem_otime; <span class="comment">// 最后操作时间（上次semop的时间戳）</span></span><br><span class="line">    <span class="type">time_t</span>          sem_ctime; <span class="comment">// 最后修改时间（创建/更改状态时间）</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>   sem_nsems; <span class="comment">// 信号量集中的信号量数量</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ipc_perm</span> &#123;</span></span><br><span class="line">    <span class="type">key_t</span>          __key;    <span class="comment">// 创建时使用的键值</span></span><br><span class="line">    <span class="type">uid_t</span>          uid;      <span class="comment">// 所有者的用户ID</span></span><br><span class="line">    <span class="type">gid_t</span>          gid;      <span class="comment">// 所有者的组ID</span></span><br><span class="line">    <span class="type">uid_t</span>          cuid;     <span class="comment">// 创建者的用户ID</span></span><br><span class="line">    <span class="type">gid_t</span>          cgid;     <span class="comment">// 创建者的组ID</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> mode;     <span class="comment">// 权限模式（9位权限位）</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> __seq;    <span class="comment">// 序列号（内核内部使用）</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></li>
</ul>
<p><strong>完整使用流程</strong></p>
<ol>
<li><p><strong>创建信号量集</strong>  </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> semid = semget(key, <span class="number">1</span>, IPC_CREAT | <span class="number">0666</span>);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>初始化信号量</strong>  </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">union</span> <span class="title">semun</span> <span class="title">arg</span>;</span></span><br><span class="line">arg.val = <span class="number">1</span>;  <span class="comment">// 初始资源数=1（二进制信号量）</span></span><br><span class="line">semctl(semid, <span class="number">0</span>, SETVAL, arg);</span><br></pre></td></tr></table></figure>
</li>
<li><p><strong>进程间同步操作</strong>  </p>
<ul>
<li>进程A（申请资源）：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sembuf</span> <span class="title">op</span> =</span> &#123;<span class="number">0</span>, <span class="number">-1</span>, <span class="number">0</span>&#125;;  <span class="comment">// P操作</span></span><br><span class="line">semop(semid, &amp;op, <span class="number">1</span>);</span><br></pre></td></tr></table></figure></li>
<li>进程B（释放资源）：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sembuf</span> <span class="title">op</span> =</span> &#123;<span class="number">0</span>, +<span class="number">1</span>, <span class="number">0</span>&#125;;  <span class="comment">// V操作</span></span><br><span class="line">semop(semid, &amp;op, <span class="number">1</span>);</span><br></pre></td></tr></table></figure></li>
</ul>
</li>
<li><p><strong>清理信号量</strong>  </p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">semctl(semid, <span class="number">0</span>, IPC_RMID, <span class="number">0</span>);</span><br></pre></td></tr></table></figure></li>
</ol>
<h4 id="5-4-共性总结"><a href="#5-4-共性总结" class="headerlink" title="5.4 共性总结"></a>5.4 共性总结</h4><h5 id="5-4-1-三大-IPC-机制的共同设计"><a href="#5-4-1-三大-IPC-机制的共同设计" class="headerlink" title="5.4.1 三大 IPC 机制的共同设计"></a>5.4.1 三大 IPC 机制的共同设计</h5><p><code>System V</code> 的共享内存、消息队列和信号量虽然功能不同，但共享统一的设计理念和实现框架：</p>
<!-- ![alt text](image/进程间通信/image.png) -->
<img src="/2025/11/24/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/image.png" class="">

<p><strong>1. 键值标识系统 (Key-based Identification)</strong><br>所有 <code>IPC</code> 对象都通过 <code>key_t</code> 类型的<strong>键值</strong>在系统范围内唯一标识：</p>
<table>
<thead>
<tr>
<th>机制</th>
<th>创建函数</th>
<th>获取键值方式</th>
</tr>
</thead>
<tbody><tr>
<td><strong>共享内存</strong></td>
<td><code>shmget()</code></td>
<td><code>ftok(path, proj_id)</code></td>
</tr>
<tr>
<td><strong>消息队列</strong></td>
<td><code>msgget()</code></td>
<td><code>ftok(path, proj_id)</code></td>
</tr>
<tr>
<td><strong>信号量</strong></td>
<td><code>semget()</code></td>
<td><code>ftok(path, proj_id)</code></td>
</tr>
</tbody></table>
<p><strong>工作原理</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">key_t</span> mykey = ftok(<span class="string">&quot;/tmp/myapp&quot;</span>, <span class="string">&#x27;A&#x27;</span>); <span class="comment">// 路径+项目ID生成唯一键</span></span><br><span class="line"><span class="type">int</span> id = shmget(mykey, size, <span class="number">0666</span>|IPC_CREAT); <span class="comment">// 使用键创建对象</span></span><br></pre></td></tr></table></figure>

<p><strong>2. 统一权限模型 (Standard Permission Model)</strong><br>所有 <code>IPC</code> 对象使用相同的权限控制结构 <code>struct ipc_perm</code>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ipc_perm</span> &#123;</span></span><br><span class="line">    <span class="type">key_t</span>          __key;    <span class="comment">// 创建时使用的键</span></span><br><span class="line">    <span class="type">uid_t</span>          uid;      <span class="comment">// 所有者的有效用户ID</span></span><br><span class="line">    <span class="type">gid_t</span>          gid;      <span class="comment">// 所有者的有效组ID</span></span><br><span class="line">    <span class="type">uid_t</span>          cuid;     <span class="comment">// 创建者的有效用户ID</span></span><br><span class="line">    <span class="type">gid_t</span>          cgid;     <span class="comment">// 创建者的有效组ID</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> mode;     <span class="comment">// 权限位（如 0666）</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> __seq;    <span class="comment">// 序列号（内核使用）</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>权限位说明</strong>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">rwx rwx rwx</span><br><span class="line">↓↓↓ ↓↓↓ ↓↓↓</span><br><span class="line">用户 组  其他</span><br><span class="line"></span><br><span class="line">r = 4 (读)</span><br><span class="line">w = 2 (写)</span><br><span class="line">x = 1 (执行) // IPC中通常忽略</span><br></pre></td></tr></table></figure>

<p><strong>3. 内核持久性 (Kernel Persistence)</strong><br>三大机制共享相同的生命周期特性：</p>
<table>
<thead>
<tr>
<th>特性</th>
<th>说明</th>
</tr>
</thead>
<tbody><tr>
<td><strong>创建者无关</strong></td>
<td>对象独立于创建进程存在</td>
</tr>
<tr>
<td><strong>显式删除</strong></td>
<td>必须调用 <code>XXXctl(IPC_RMID)</code> 删除</td>
</tr>
<tr>
<td><strong>系统重启清除</strong></td>
<td>对象在系统重启后自动清除</td>
</tr>
<tr>
<td><strong>资源泄漏风险</strong></td>
<td>未删除的对象会永久占用内核资源</td>
</tr>
</tbody></table>
<p><strong>4. 相似控制结构 (Control Structures)</strong><br>所有 <code>IPC</code> 对象都有类似的状态结构体：</p>
<table>
<thead>
<tr>
<th>机制</th>
<th>状态结构体</th>
<th>包含字段</th>
</tr>
</thead>
<tbody><tr>
<td>共享内存</td>
<td><code>struct shmid_ds</code></td>
<td>大小、附加进程数、权限等</td>
</tr>
<tr>
<td>消息队列</td>
<td><code>struct msqid_ds</code></td>
<td>消息数、字节数、权限等</td>
</tr>
<tr>
<td>信号量</td>
<td><code>struct semid_ds</code></td>
<td>信号量数、权限等</td>
</tr>
</tbody></table>
<p><strong>共同字段</strong>：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">XXXid_ds</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ipc_perm</span> <span class="title">XXX_perm</span>;</span>  <span class="comment">// 权限结构</span></span><br><span class="line">    <span class="type">time_t</span>          XXX_stime; <span class="comment">// 最后操作时间</span></span><br><span class="line">    <span class="type">time_t</span>          XXX_rtime; <span class="comment">// 最后接收时间</span></span><br><span class="line">    <span class="type">time_t</span>          XXX_ctime; <span class="comment">// 最后修改时间</span></span><br><span class="line">    <span class="comment">// ... 类型特有字段</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>5. 标准控制接口 (Control Interface)</strong><br>所有机制都使用 <code>XXXctl()</code> 系统调用进行管理：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">XXXctl</span><span class="params">(<span class="type">int</span> id, <span class="type">int</span> cmd, <span class="keyword">struct</span> XXXid_ds *buf)</span>;</span><br></pre></td></tr></table></figure>

<p><strong>通用命令</strong>：</p>
<table>
<thead>
<tr>
<th>命令</th>
<th>功能</th>
</tr>
</thead>
<tbody><tr>
<td><code>IPC_STAT</code></td>
<td>获取对象状态信息</td>
</tr>
<tr>
<td><code>IPC_SET</code></td>
<td>修改对象参数（如权限）</td>
</tr>
<tr>
<td><code>IPC_RMID</code></td>
<td>立即删除对象</td>
</tr>
</tbody></table>
<p><strong>6. 原子操作保证 (Atomic Operations)</strong><br>所有 <code>IPC</code> 操作都具备原子性：</p>
<ul>
<li><strong>共享内存</strong>：虽然访问非原子，但创建&#x2F;附加操作是原子的</li>
<li><strong>消息队列</strong>：<code>msgsnd/msgrcv</code> 是原子操作</li>
<li><strong>信号量</strong>：<code>semop</code> 是原子操作</li>
</ul>
<h5 id="5-4-2-Shell-管理工具"><a href="#5-4-2-Shell-管理工具" class="headerlink" title="5.4.2 Shell 管理工具"></a>5.4.2 Shell 管理工具</h5><p><strong>1. 查看 <code>IPC</code> 对象：<code>ipcs</code></strong><br><strong>通用选项</strong>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">ipcs -a  <span class="comment"># 显示所有IPC对象（默认）</span></span><br></pre></td></tr></table></figure>

<p><strong>类型过滤</strong>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ipcs -m  <span class="comment"># 仅显示共享内存</span></span><br><span class="line">ipcs -q  <span class="comment"># 仅显示消息队列</span></span><br><span class="line">ipcs -s  <span class="comment"># 仅显示信号量</span></span><br></pre></td></tr></table></figure>

<p><strong>详细信息</strong>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">ipcs -l  <span class="comment"># 显示系统限制</span></span><br><span class="line">ipcs -p  <span class="comment"># 显示创建者和最后操作者的PID</span></span><br><span class="line">ipcs -t  <span class="comment"># 显示时间信息</span></span><br><span class="line">ipcs -c  <span class="comment"># 显示创建者/所有者信息</span></span><br><span class="line">ipcs -u  <span class="comment"># 显示汇总信息</span></span><br></pre></td></tr></table></figure>

<p><strong>示例</strong>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ ipcs</span><br><span class="line">------ Shared Memory Segments --------</span><br><span class="line">key        shmid      owner      perms      bytes      nattch     status</span><br><span class="line">0x0052e2c1 65536      user       600        1024       2</span><br><span class="line"></span><br><span class="line">------ Message Queues --------</span><br><span class="line">key        msqid      owner      perms      used-bytes   messages</span><br><span class="line">0x0000ff11 32769      user       666        1024         5</span><br><span class="line"></span><br><span class="line">------ Semaphore Arrays --------</span><br><span class="line">key        semid      owner      perms      nsems</span><br><span class="line">0x0000ff22 163841     user       666        3</span><br></pre></td></tr></table></figure>

<p><strong>2. 删除 <code>IPC</code> 对象：<code>ipcrm</code></strong><br><strong>按类型删除</strong>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ipcrm -m &lt;shmid&gt;  <span class="comment"># 删除共享内存</span></span><br><span class="line">ipcrm -q &lt;msqid&gt;  <span class="comment"># 删除消息队列</span></span><br><span class="line">ipcrm -s &lt;semid&gt;  <span class="comment"># 删除信号量</span></span><br></pre></td></tr></table></figure>

<p><strong>按键值删除</strong>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">ipcrm -M &lt;key&gt;  <span class="comment"># 删除共享内存（按键）</span></span><br><span class="line">ipcrm -Q &lt;key&gt;  <span class="comment"># 删除消息队列（按键）</span></span><br><span class="line">ipcrm -S &lt;key&gt;  <span class="comment"># 删除信号量（按键）</span></span><br></pre></td></tr></table></figure>

<p><strong>批量删除</strong>：</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">ipcrm -a  <span class="comment"># 删除当前用户拥有的所有IPC对象（危险！）</span></span><br><span class="line">ipcrm -all <span class="comment"># 删除系统所有IPC对象（需要root权限）</span></span><br></pre></td></tr></table></figure>

<h5 id="5-4-3-系统限制查看与配置"><a href="#5-4-3-系统限制查看与配置" class="headerlink" title="5.4.3 系统限制查看与配置"></a>5.4.3 系统限制查看与配置</h5><p><strong>1. 查看当前限制</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 共享内存限制</span></span><br><span class="line"><span class="built_in">cat</span> /proc/sys/kernel/shmmax  <span class="comment"># 单个共享内存段最大尺寸</span></span><br><span class="line"><span class="built_in">cat</span> /proc/sys/kernel/shmmni  <span class="comment"># 系统最大共享内存段数</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 消息队列限制</span></span><br><span class="line"><span class="built_in">cat</span> /proc/sys/kernel/msgmax  <span class="comment"># 单个消息最大尺寸</span></span><br><span class="line"><span class="built_in">cat</span> /proc/sys/kernel/msgmnb  <span class="comment"># 单个队列最大字节数</span></span><br><span class="line"><span class="built_in">cat</span> /proc/sys/kernel/msgmni  <span class="comment"># 系统最大消息队列数</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 信号量限制</span></span><br><span class="line"><span class="built_in">cat</span> /proc/sys/kernel/sem     <span class="comment"># 显示4个值：SEMMSL SEMMNS SEMOPM SEMMNI</span></span><br></pre></td></tr></table></figure>

<p><strong>2. 临时修改限制</strong></p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">sysctl -w kernel.shmmax=2147483648  <span class="comment"># 设置共享内存最大为2GB</span></span><br></pre></td></tr></table></figure>

<p><strong>3. 永久修改限制</strong><br>编辑 <code>/etc/sysctl.conf</code>：</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">kernel.shmmax = 2147483648</span><br><span class="line">kernel.msgmax = 65536</span><br><span class="line">kernel.sem = 250 32000 100 128</span><br></pre></td></tr></table></figure>
<p>执行 <code>sysctl -p</code> 应用更改</p>
<h4 id="5-5-内核管理和组织"><a href="#5-5-内核管理和组织" class="headerlink" title="5.5 内核管理和组织"></a>5.5 内核管理和组织</h4><h5 id="5-5-1-顶层管理结构：struct-ipc-ids"><a href="#5-5-1-顶层管理结构：struct-ipc-ids" class="headerlink" title="5.5.1 顶层管理结构：struct ipc_ids"></a>5.5.1 顶层管理结构：struct ipc_ids</h5><p>这是内核中管理所有 <code>IPC</code> 对象的顶层结构：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ipc_ids</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> in_use;             <span class="comment">// 当前使用的IPC对象数量</span></span><br><span class="line">    <span class="type">int</span> max_id;             <span class="comment">// 当前分配的最大ID值</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> seq;     <span class="comment">// 序列号计数器，用于生成唯一ID</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">short</span> seq_max; <span class="comment">// 序列号的最大值</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mutex</span> <span class="title">mutex</span>;</span>     <span class="comment">// 互斥锁，保护此结构的并发访问</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ipc_id_ary</span> <span class="title">nullentry</span>;</span> <span class="comment">// 空条目占位符</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">ipc_id_ary</span>* <span class="title">entries</span>;</span>  <span class="comment">// 指向IPC对象指针数组的指针</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ol>
<li><p><strong>entries 指针</strong>：</p>
<ul>
<li>指向一个 <code>struct ipc_id_ary</code> 结构</li>
<li>该结构包含一个<strong>柔性数组</strong>，存储了所有 <code>IPC</code> 对象的指针</li>
</ul>
</li>
<li><p><strong>ID 生成机制</strong>：</p>
<ul>
<li><code>seq</code> 序列号与数组索引组合生成唯一 <code>ID</code></li>
<li>公式：<code>id = SEQ_MULTIPLIER * index + seq</code></li>
<li>用户空间看到的 <code>IPC ID</code> 是通过此公式生成的</li>
</ul>
</li>
</ol>
<h5 id="5-5-2-IPC-对象指针数组：struct-ipc-id-ary"><a href="#5-5-2-IPC-对象指针数组：struct-ipc-id-ary" class="headerlink" title="5.5.2 IPC 对象指针数组：struct ipc_id_ary"></a>5.5.2 IPC 对象指针数组：struct ipc_id_ary</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">ipc_id_ary</span> &#123;</span></span><br><span class="line">    <span class="type">int</span> size;                       <span class="comment">// 数组的大小</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kern_ipc_perm</span> *<span class="title">p</span>[0];</span>     <span class="comment">// 柔性数组，存储指向kern_ipc_perm的指针</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ol>
<li><p><strong>柔性数组</strong>：</p>
<ul>
<li><code>p[0]</code> 是柔性数组的声明</li>
<li>实际分配时根据 <code>size</code> 动态确定数组长度</li>
<li>存储所有 <code>IPC</code> 对象的基类指针</li>
</ul>
</li>
<li><p><strong>索引即 ID</strong>：</p>
<ul>
<li>数组下标对应 <code>IPC</code> 对象的内部 <code>ID</code></li>
<li>共享内存、消息队列、信号量都存储在此数组中</li>
<li>通过下标可直接访问对应 <code>IPC</code> 对象</li>
</ul>
</li>
</ol>
<h5 id="5-5-3-IPC-公共头结构：struct-kern-ipc-perm"><a href="#5-5-3-IPC-公共头结构：struct-kern-ipc-perm" class="headerlink" title="5.5.3 IPC 公共头结构：struct kern_ipc_perm"></a>5.5.3 IPC 公共头结构：struct kern_ipc_perm</h5><p>这是所有 <code>IPC</code> 对象的公共基础结构：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kern_ipc_perm</span> &#123;</span></span><br><span class="line">    <span class="type">spinlock_t</span>  lock;       <span class="comment">// 自旋锁，保护该结构的并发访问</span></span><br><span class="line">    <span class="type">int</span>         deleted;    <span class="comment">// 标记对象是否已被删除</span></span><br><span class="line">    <span class="type">key_t</span>       key;        <span class="comment">// 用户提供的键值，用于标识IPC对象</span></span><br><span class="line">    <span class="type">uid_t</span>       uid;        <span class="comment">// 所有者的用户ID</span></span><br><span class="line">    <span class="type">gid_t</span>       gid;        <span class="comment">// 所有者的组ID</span></span><br><span class="line">    <span class="type">uid_t</span>       cuid;       <span class="comment">// 创建者的用户ID</span></span><br><span class="line">    <span class="type">gid_t</span>       cgid;       <span class="comment">// 创建者的组ID</span></span><br><span class="line">    <span class="type">mode_t</span>      mode;       <span class="comment">// 权限模式（rwxrwxrwx）</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> seq;      <span class="comment">// 序列号，与ipc_ids中的seq对应</span></span><br><span class="line">    <span class="type">void</span>        *security;  <span class="comment">// 指向安全模块相关数据（如SELinux）</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<ol>
<li><strong>统一权限模型</strong>：<ul>
<li>包含所有权限和所有者信息</li>
<li>在用户空间表现为 <code>struct ipc_perm</code></li>
</ul>
</li>
</ol>
<h5 id="5-5-4-具体-IPC-对象结构"><a href="#5-5-4-具体-IPC-对象结构" class="headerlink" title="5.5.4 具体 IPC 对象结构"></a>5.5.4 具体 IPC 对象结构</h5><p><strong>1. 共享内存结构：<code>struct shmid_kernel</code></strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">shmid_kernel</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kern_ipc_perm</span>    <span class="title">shm_perm</span>;</span>   <span class="comment">// 公共权限头（强制转换点）</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file</span> *           <span class="title">shm_file</span>;</span>   <span class="comment">// 关联的文件对象指针</span></span><br><span class="line">    <span class="type">int</span>                     id;         <span class="comment">// 内部标识符</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>           shm_nattch; <span class="comment">// 当前附加的进程数</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>           shm_segsz;  <span class="comment">// 段大小（字节）</span></span><br><span class="line">    <span class="type">time_t</span>                  shm_atim;   <span class="comment">// 最后附加时间</span></span><br><span class="line">    <span class="type">time_t</span>                  shm_dtim;   <span class="comment">// 最后分离时间</span></span><br><span class="line">    <span class="type">time_t</span>                  shm_ctim;   <span class="comment">// 最后修改时间</span></span><br><span class="line">    <span class="type">pid_t</span>                   shm_cprid;  <span class="comment">// 创建者PID</span></span><br><span class="line">    <span class="type">pid_t</span>                   shm_lprid;  <span class="comment">// 最后操作者PID</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">user_struct</span> *    <span class="title">mlock_user</span>;</span> <span class="comment">// 内存锁定信息</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>强制类型转换：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 从ipc_id_ary数组中获取共享内存对象</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kern_ipc_perm</span> *<span class="title">perm</span> =</span> ids-&gt;entries-&gt;p[index];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">shmid_kernel</span> *<span class="title">shm</span> =</span> (<span class="keyword">struct</span> shmid_kernel *)perm;</span><br></pre></td></tr></table></figure>

<p><strong>2. 消息队列结构：<code>struct msg_queue</code></strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg_queue</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kern_ipc_perm</span> <span class="title">q_perm</span>;</span>        <span class="comment">// 公共权限头</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 消息队列特有成员</span></span><br><span class="line">    <span class="type">int</span> q_id;                           <span class="comment">// 内部标识符</span></span><br><span class="line">    <span class="type">time_t</span> q_stime;                     <span class="comment">// 最后发送时间</span></span><br><span class="line">    <span class="type">time_t</span> q_rtime;                     <span class="comment">// 最后接收时间</span></span><br><span class="line">    <span class="type">time_t</span> q_ctime;                     <span class="comment">// 最后修改时间</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> q_cbytes;             <span class="comment">// 当前队列字节数</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> q_qnum;               <span class="comment">// 消息数量</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> q_qbytes;             <span class="comment">// 最大队列字节数</span></span><br><span class="line">    <span class="type">pid_t</span> q_lspid;                      <span class="comment">// 最后发送者PID</span></span><br><span class="line">    <span class="type">pid_t</span> q_lrpid;                      <span class="comment">// 最后接收者PID</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 消息管理结构</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">q_messages</span>;</span>        <span class="comment">// 消息链表头</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">q_receivers</span>;</span>       <span class="comment">// 等待接收的进程</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">q_senders</span>;</span>         <span class="comment">// 等待发送的进程</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>强制类型转换：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kern_ipc_perm</span> *<span class="title">perm</span> =</span> ids-&gt;entries-&gt;p[index];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">msg_queue</span> *<span class="title">msgq</span> =</span> (<span class="keyword">struct</span> msg_queue *)perm;</span><br></pre></td></tr></table></figure>

<p><strong>3. 信号量结构：<code>struct sem_array</code></strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sem_array</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kern_ipc_perm</span>    <span class="title">sem_perm</span>;</span>       <span class="comment">// 公共权限头</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 信号量集特有成员</span></span><br><span class="line">    <span class="type">int</span>                     sem_id;         <span class="comment">// 内部标识符</span></span><br><span class="line">    <span class="type">time_t</span>                  sem_otime;      <span class="comment">// 最后操作时间</span></span><br><span class="line">    <span class="type">time_t</span>                  sem_ctime;      <span class="comment">// 最后修改时间</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 信号量数组管理</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sem</span> *            <span class="title">sem_base</span>;</span>       <span class="comment">// 信号量数组指针</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span>           sem_nsems;      <span class="comment">// 信号量数量</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 待处理操作管理</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sem_queue</span> *      <span class="title">sem_pending</span>;</span>    <span class="comment">// 待处理操作队列</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sem_queue</span> **     <span class="title">sem_pending_last</span>;</span> <span class="comment">// 最后待处理操作</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// UNDO机制</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">sem_undo</span> *       <span class="title">undo</span>;</span>           <span class="comment">// UNDO记录指针</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p>强制类型转换：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kern_ipc_perm</span> *<span class="title">perm</span> =</span> ids-&gt;entries-&gt;p[index];</span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">sem_array</span> *<span class="title">sema</span> =</span> (<span class="keyword">struct</span> sem_array *)perm;</span><br></pre></td></tr></table></figure>

<h5 id="5-5-5-内核数据结构关系图"><a href="#5-5-5-内核数据结构关系图" class="headerlink" title="5.5.5 内核数据结构关系图"></a>5.5.5 内核数据结构关系图</h5><!-- ![1753105096633](image/进程间通信/1753105096633.png) -->
<img src="/2025/11/24/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/1753105096633.png" class="">

<h5 id="5-5-6-类型转换过程"><a href="#5-5-6-类型转换过程" class="headerlink" title="5.5.6 类型转换过程"></a>5.5.6 类型转换过程</h5><p><strong>1. 存储机制</strong></p>
<ul>
<li><code>ipc_id_ary</code> 的 <code>p[]</code> 数组存储 <code>kern_ipc_perm*</code> 指针</li>
<li>所有具体 <code>IPC</code> 结构都以 <code>kern_ipc_perm</code> 作为第一个成员</li>
</ul>
<p><strong>2. 转换原理</strong></p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">shmid_kernel</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">kern_ipc_perm</span> <span class="title">shm_perm</span>;</span> <span class="comment">// 必须作为第一个成员</span></span><br><span class="line">    <span class="comment">// ... 其他成员</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>

<p><strong>3. 访问过程</strong></p>
<ol>
<li><p>通过索引获取基类指针：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">kern_ipc_perm</span> *<span class="title">perm</span> =</span> ids-&gt;entries-&gt;p[index];</span><br></pre></td></tr></table></figure>
</li>
<li><p>转换为具体类型：</p>
<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 转换为共享内存</span></span><br><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">shmid_kernel</span> *<span class="title">shm</span> =</span> (<span class="keyword">struct</span> shmid_kernel *)perm;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 访问共享内存特有成员</span></span><br><span class="line"><span class="type">unsigned</span> <span class="type">long</span> size = shm-&gt;shm_segsz;</span><br></pre></td></tr></table></figure></li>
</ol>
<h5 id="5-5-7-IPC-对象生命周期"><a href="#5-5-7-IPC-对象生命周期" class="headerlink" title="5.5.7 IPC 对象生命周期"></a>5.5.7 IPC 对象生命周期</h5><p><strong>1. 创建过程</strong></p>
<!-- ![1753103289147](image/进程间通信/1753103289147.png) -->
<img src="/2025/11/24/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/1753103289147.png" class="">

<p><strong>2. 删除过程</strong></p>
<!-- ![1753103314326](image/进程间通信/1753103314326.png) -->
<img src="/2025/11/24/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/1753103314326.png" class="">


                
                <p class="end">__END__</p>
            </div>
            <div class="article-footer">
                <div class="suffix-box">
    <div class="suffix-box-left">
        <img src="/image/sidebar/avatar.jpg" alt="Live For Code">
    </div>
    <div class="suffix-box-right">
        <span class="suffix-box-title">文章作者：</span>Live For Code
        <br>
        <span class="suffix-box-title">文章出处：</span><a href="/2025/11/24/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/" target="_blank">进程间通信</a>
        <br>
        <span class="suffix-box-title">作者签名：</span>简单地活着, 肆意又精彩.
        <br>
        <span class="suffix-box-title">关于主题：</span><a href="https://github.com/first19326/Hexo-LiveForCode" target="_blank">Hexo - Live For Code</a>
        <br>
        <span class="suffix-box-title">版权声明：</span>文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-nd/4.0/" title="BY-NC-SA" target="_blank">BY-NC-SA</a> 许可协议，转载请注明出处
        <br>
    </div>
    <div style="clear: both;"></div>
</div>
                
                
                <div class="article-prev-next">
                    
                        <a href="/2025/11/24/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/" class="prev-prefix">« </a> 上一篇：    <a href="/2025/11/24/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/%E8%BF%9B%E7%A8%8B%E9%97%B4%E9%80%9A%E4%BF%A1/" title="发布于 2025-11-24 04:19"></a>
                        <br>
                    
                    
                        <a href="/2025/11/23/%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6/" class="next-prefix">» </a> 下一篇：    <a href="/2025/11/23/%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6/" title="发布于 2025-11-23 07:46">进程控制</a>
                    
                </div>
            </div>
            
    <div class="article-comments">
        
            <div class="comments-title">
                评论列表
            </div>
        
        <div class="comments-content"></div>
    </div>
    
 
        </div>
    
</div>
    <div id="footer">
    <div><span class='face'>ღゝ◡╹)ノ♡</span></div><div>【人生若只如初见<span><i class='iconfont icon-like-fill'></i></span>何事秋风悲画扇】</div><div>&copy; 2020-2023 WorstOne. All Rights Reserved.</div>
</div>
    <div id="sidebar">
    <div class="menu-wrap" style="display:none;">
        
            <div class="menu-notice">
                <span class="iconfont icon-notice"></span>
                <div class="notice">
                    <span>简单地活着，肆意而又精彩！</span>
                </div>
            </div>
        
        <nav class="menu">
            <div class="menu-introduce"> 
                <div class="introduce-avatar">
                    <img src="/image/sidebar/avatar.jpg">
                </div> 
                <div class="introduce-info"> 
                    <div class="introduce-user">
                        
                            <a href="https://worstone.cn" target="_blank"><span>Live For Code</span></a>
                        
                    </div>
                </div> 
            </div> 
            <div class="menu-list">
                <ul>
                    
                        <li class=""><a href="/" class="" target="_self"><span class="iconfont icon-home-fill"></span>首页</a></li>
                    
                        <li class=""><a href="/category" class="" target="_self"><span class="iconfont icon-folder-fill"></span>分类</a></li>
                    
                        <li class=""><a href="/tag" class="" target="_self"><span class="iconfont icon-discount-fill"></span>标签</a></li>
                    
                        <li class=""><a href="/archive" class="" target="_self"><span class="iconfont icon-calendar-fill"></span>归档</a></li>
                    
                        <li class=""><a href="/donate" class="" target="_self"><span class="iconfont icon-heart-fill"></span>赞赏</a></li>
                    
                        <li class=""><a href="/about" class="" target="_self"><span class="iconfont icon-about-fill"></span>关于</a></li>
                    
                        <li class=""><a href="/atom.xml" class="" target="_blank"><span class="iconfont icon-rss"></span>订阅</a></li>
                    
                        <li class=""><a href="javascript:;" class="search" target="_self"><span class="iconfont icon-search-menu"></span>搜索</a></li>
                    
                        <li class=""><a href="/comment" class="" target="_self"><span class="iconfont icon-comments-fill"></span>留言板</a></li>
                    
                        <li class=""><a href="/friend" class="" target="_self"><span class="iconfont icon-link"></span>友情链接</a></li>
                    
                </ul> 
            </div> 
            <div class="menu-link">
                <div class="box">
                    <div class="image-box"></div>
                </div>
                
                    <a name="知乎" href="https://zhihu.com/people/worstone-29" class="" target="_blank" data=""><span class="iconfont icon-zhihu"></span></a>
                
                    <a name="微博" href="https://weibo.com/u/5749847477" class="" target="_blank" data=""><span class="iconfont icon-weibo"></span></a>
                
                    <a name="QQ" href="javascript:;" class="image" target="_self" data="/image/sidebar/qq.png"><span class="iconfont icon-qq"></span></a>
                
                    <a name="微信" href="javascript:;" class="" target="_self" data=""><span class="iconfont icon-wechat"></span></a>
                
                    <a name="GitHub" href="https://github.com/first19326" class="" target="_blank" data=""><span class="iconfont icon-github"></span></a>
                
            </div> 
        </nav>
        <button class="menu-button-close"></button>
        <div class="morph-shape" id="morph-shape" data-morph-open="M-7.312,0H15c0,0,66,113.339,66,399.5C81,664.006,15,800,15,800H-7.312V0z;M-7.312,0H100c0,0,0,113.839,0,400c0,264.506,0,400,0,400H-7.312V0z">
            <svg xmlns="http://www.w3.org/2000/svg" width="100%" height="100%" viewBox="0 0 100 800" preserveAspectRatio="none">
                <path d="M-7.312,0H0c0,0,0,113.839,0,400c0,264.506,0,400,0,400h-7.312V0z"/>
            </svg>
        </div>
    </div>
    <button class="menu-button-open">MENU</button>
    <div class="menu-cover"></div>
</div>
    <link type="text/css" rel="stylesheet" href="/css/search.css">
<script type="text/javascript" src="/js/iscroll.js"></script>
<script type="text/javascript" src="/js/instantsearch.min.js"></script>
<div class="search-window">
    <div class="search-content">
        <div class="search-content-icon">
            <i class="iconfont icon-search"></i>
        </div>
        <div id="search-input" class="search-input"></div>
    </div>

    <div class="search-scroll">
        <div class="search-result">
            <div id="search-stats" class="search-stats"></div>
            <div id="search-hits"></div>
            <div id="search-pagination" class="search-pagination"></div>
        </div>
    </div>

    <span class="search-close-icon">
        <i class="iconfont icon-close"></i>
    </span>
</div>
    <div id="tools">
    <div class="progressbar-top"></div>
    
    <link type="text/css" rel="stylesheet" href="/css/APlayer.css">
    <script type="text/javascript" src="/js/APlayer.min.js"></script>
    <script type="text/javascript" src="/js/Meting.min.js"></script>
    <script>
        var meting_api = 'https://api.i-meto.com/meting/api?server=:server&type=:type&id=:id&auth=:auth&r=:r';
    </script>
    <meting-js id="3778678" lrcshow="false" server="netease" type="playlist" fixed="true" autoplay="false" loop="all" order="random" preload="auto" volume="0.67" mutex="true"></meting-js>

    <div class="wrap-right">
    <div class="wrap-right-hide">
         <div class="wrap-right-button favorites">
            <div class="iconbox" switch="false">
                <span class="iconfont icon-favorites"></span>
            </div>
            <span class="icontext">关注</span>
         </div>
        <div class="wrap-right-button search">
            <div class="iconbox">
                <span class="iconfont icon-search-menu"></span>
            </div>
            <span class="icontext">搜索</span>
        </div>
        <div class="wrap-right-button menu-button">
            <div class="iconbox">
                <span class="iconfont icon-menu"></span>
            </div>
            <span class="icontext">菜单</span>
        </div>
        <div class="wrap-right-button mode">
            <div class="light">
                <div class="iconbox">
                    <span class="iconfont icon-daymode"></span>
                </div>
                <span class="icontext">浅色模式</span>
            </div>
            <div class="dark">
                <div class="iconbox">
                    <span class="iconfont icon-nightmode-fill"></span>
                </div>
                <span class="icontext">深色模式</span>
            </div>
        </div>
        <div class="wrap-right-button bottom">
            <div class="iconbox">
                <span class="iconfont icon-top"></span>
            </div>
            <span class="icontext">跳至底部</span>
        </div>
    </div>
    <div class="wrap-right-show">
        <div class="wrap-right-button set">
            <div class="iconbox">
                <span class="iconfont icon-setting"></span>
            </div>
            <span class="icontext">设置</span>
        </div>
        <div class="wrap-right-button top">
            <div class="iconbox">
                <span class="iconfont icon-top"></span>
            </div>
            <span class="icontext">返回顶部</span>
        </div>
    </div>
</div>
    <div class="loading"></div>
</div>
    <script>
    window.config = {
        GitHubUserName     : "first19326",
        GitHubRepositories : "Hexo-LiveForCode",

        User             : "Live For Code",
        UserAvatar       : "/image/sidebar/avatar.jpg",
        WebsiteStartDate : "2020-01-01",
        Home             : "https://worstone.cn",

        WebsiteTitleBlur         : "(◍´꒳`◍) Hi, Live For Code",
        WebsiteTitleBlurTimeOut  : 500,
        WebsiteTitleFocus        : "(*´∇｀*) 欢迎回来!",
        WebsiteTitleFocusTimeOut : 1000,
        WebsiteFavicon           : {
            light : "/image/website/logo/logo.png",
            dark  : "/image/website/logo/logo-dark.png"
        },

        ProgressBar : {
            id       : "topProgressBar",
            color    : "#77B6FF",
            height   : "2px",
            duration : 0.2
        },

        Loading: {
            rebound : {
                tension  : 16,
                friction : 5
            },
            spinner : {
                id     : "spinner",
                radius : 90,
                sides  : 3,
                depth  : 4,
                colors : {
                    background : "#F0F0F0",
                    stroke     : "#272633",
                    base       : "",
                    child      : "#272633"
                },
                alwaysForward : true,
                restAt        : 0.5,
                renderBase    : false
            }
        },

        HomeHeaderAnimationRendered : true,
        HomeHeaderAnimation         : {
            radius      : 15,
            density     : 0.2,
            color       : "rgba(255, 255, 255, .2)",
            clearOffset : 0.3
        },

        BackAnimationRendered          : true,
        IEBrowserBackAnimationRendered : false,
        BackAnimation                  : {
            colorSaturation  : "60%",
            colorBrightness  : "50%",
            colorAlpha       : 0.5,
            colorCycleSpeed  : 5,
            verticalPosition : "random",
            horizontalSpeed  : 200,
            ribbonCount      : 3,
            strokeSize       : 0,
            parallaxAmount   : -0.2,
            animateSections  : true
        },

        HomeHeaderImage : [
            
                "/image/header/home.jpg",
            
                "/image/header/home.jpeg",
            
        ],
        HomeBannerText  : "",

        ArticleHeaderImage : [
            
                "/image/header/article.jpg",
            
        ],

        OtherBannerText : "",

        Error : {
            icon    : "icon-swimming",
            title   : "PAGE NOT FOUND",
            content : [
                
                    "很抱歉，您访问的页面不存在！",
                
                    "可能是输入地址有误或该地址已变更。",
                
            ],
            buttons : [
                
                    {
                        icon  : "icon-home",
                        text  : "返回首页",
                        href  : "/",
                        class : ""
                    },
                
            ]
        },

        MenuNotice : {
            enable : true,
            notice : "简单地活着，肆意而又精彩！",
            speed  : 20
        },
        MenuList : [
            
                {
                    name   : "首页",
                    icon   : "icon-home-fill",
                    href   : "/",
                    type   : "index",
                    class  : "",
                    target : "_self"
                },
            
                {
                    name   : "分类",
                    icon   : "icon-folder-fill",
                    href   : "/category",
                    type   : "category",
                    class  : "",
                    target : "_self"
                },
            
                {
                    name   : "标签",
                    icon   : "icon-discount-fill",
                    href   : "/tag",
                    type   : "tag",
                    class  : "",
                    target : "_self"
                },
            
                {
                    name   : "归档",
                    icon   : "icon-calendar-fill",
                    href   : "/archive",
                    type   : "archive",
                    class  : "",
                    target : "_self"
                },
            
                {
                    name   : "赞赏",
                    icon   : "icon-heart-fill",
                    href   : "/donate",
                    type   : "donate",
                    class  : "",
                    target : "_self"
                },
            
                {
                    name   : "关于",
                    icon   : "icon-about-fill",
                    href   : "/about",
                    type   : "about",
                    class  : "",
                    target : "_self"
                },
            
                {
                    name   : "订阅",
                    icon   : "icon-rss",
                    href   : "/atom.xml",
                    type   : "",
                    class  : "",
                    target : "_blank"
                },
            
                {
                    name   : "搜索",
                    icon   : "icon-search-menu",
                    href   : "javascript:;",
                    type   : "",
                    class  : "search",
                    target : "_self"
                },
            
                {
                    name   : "留言板",
                    icon   : "icon-comments-fill",
                    href   : "/comment",
                    type   : "comment",
                    class  : "",
                    target : "_self"
                },
            
                {
                    name   : "友情链接",
                    icon   : "icon-link",
                    href   : "/friend",
                    type   : "friend",
                    class  : "",
                    target : "_self"
                },
            
        ],
        MenuLink : [
            
                
                    {
                        name   : "知乎",
                        icon   : "icon-zhihu",
                        href   : "https://zhihu.com/people/worstone-29",
                        class  : "",
                        target : "_blank",
                        image  : ""
                    },
                
                    {
                        name   : "微博",
                        icon   : "icon-weibo",
                        href   : "https://weibo.com/u/5749847477",
                        class  : "",
                        target : "_blank",
                        image  : ""
                    },
                
                    {
                        name   : "QQ",
                        icon   : "icon-qq",
                        href   : "javascript:;",
                        class  : "image",
                        target : "_self",
                        image  : "/image/sidebar/qq.png"
                    },
                
                    {
                        name   : "微信",
                        icon   : "icon-wechat",
                        href   : "javascript:;",
                        class  : "",
                        target : "_self",
                        image  : ""
                    },
                
                    {
                        name   : "GitHub",
                        icon   : "icon-github",
                        href   : "https://github.com/first19326",
                        class  : "",
                        target : "_blank",
                        image  : ""
                    },
                
            
        ],

        FooterStyle : 2,
        BottomText  : "<div><span class='face'>ღゝ◡╹)ノ♡</span></div><div>【人生若只如初见<span><i class='iconfont icon-like-fill'></i></span>何事秋风悲画扇】</div><div>&copy; 2020-2023 WorstOne. All Rights Reserved.</div>",

        ConsoleList : [
            
                
                    [
                        
                            
                                "Based on cnblogs theme SimpleMemory.",
                            
                                "",
                            
                        
                    ],
                
                    [
                        
                            
                                "SimpleMemory Author:",
                            
                                "BNDong",
                            
                        
                    ],
                
                    [
                        
                            
                                "Theme:",
                            
                                "LiveForCode",
                            
                        
                    ],
                
            
        ],

        FontIconExtend : "",

        Donate : {
            paypal  : "",
            bitcoin : "",
            alipay  : "/image/donate/alipay.png",
            wechat  : "/image/donate/wechat.png"
        },

        Search : {
            applicationID : "010C3EANT8",
            apiKey        : "c7abab9f11b79102b9aff7fe6d41447d",
            indexName     : "Notes",
            hits          : {
                page : 10
            },
            labels        : {
                placeholder : "搜索",
                empty       : "未发现与 「${query}」 相关的内容",
                stats       : "${hits} 条相关条目，使用了 ${time} 毫秒",
            }
        }, 

        Comment : {
            switch : true,
            type   : "Valine",
        },

        Waline : {
            el              : ".comments-content",
            serverURL       : "",
            path            : window.location.pathname,
            meta            : "['nick', 'mail', 'link']",
            requiredMeta    : "['nick', 'mail']",
            pageSize        : 10,
            lang            : "zh-cn",
            locale: {
                admin       : "博主",
                anonymous   : "匿名用户",
                sofa        : "快来做第一个评论的人吧 ~",
                placeholder : "你是我一生只会遇见一次的惊喜...",
            },
            dark            : "html[color-scheme='dark']",
            search          : false,
            pageview        : true,
            comment         : true,
            copyright       : false,
        },

        Valine : {
            el             : ".comments-content",
            appId          : "srhKtvWPQTWYKh3qX8G8M7v0-gzGzoHsz",
            appKey         : "8uVSP1q6UlALVC5igYfIfv2h",
            serverURLs     : "",
            placeholder    : "你是我一生只会遇见一次的惊喜...",
            avatar         : "mm",
            meta           : "nick,mail,link",
            requiredFields : "nick,mail",
            pageSize       : 5,
            lang           : "zh-cn",
            visitor        : true,
            enableQQ       : true
        },

        Tocbot : {
            switch                : true,
            tocSelector           : ".toc",
            contentSelector       : ".article-body",
            headingSelector       : "h1, h2, h3, h4, h5",
            headingsOffset        : 0,
            scrollSmooth          : true,
            scrollSmoothOffset    : -5,
            positionFixedSelector : ".toc",
            positionFixedClass    : "toc-fixed",
            fixedSidebarOffset    : "",
        },

        Require : {
            baseUrl     : "/js/",
            waitSeconds : 100
        },

        Music : {
            type : "Meting"
        },
        APlayer : {
            container : ".aplayer",
            fixed     : true,
            autoplay  : false,
            loop      : "all",
            order     : "random",
            preload   : "auto",
            volume    : 0.67,
            mutex     : true,
            lrcType   : 3,
            audio     : [
                
                    {
                        name   : "Endless Tears",
                        artist : "CLIFF EDGE",
                        cover  : "/music/cover/Endless Tears.jpg",
                        url    : "/music/song/Endless Tears.mp3",
                        lrc    : "/music/lrc/Endless Tears.lrc"
                    },
                
            ]
        },
        Meting : {
            api      : "https://api.i-meto.com/meting/api",
            id       : "3778678", 
            lrcshow  : false, 
            server   : "netease", 
            type     : "playlist", 
            fixed    : true, 
            autoplay : false, 
            loop     : "all", 
            order    : "random", 
            preload  : "auto", 
            volume   : 0.67, 
            mutex    : true
        },

        Mouse : {
            enable  : true,
            options : {
                size  : 6,
                sizeF : 24
            }
        },

        LazyLoad : {
            default : "/image/website/lazyload.svg"
        },
  
        Style : {
            aplayer          : "/css/APlayer.css",
            archive          : "/css/archive.css",
            base             : "/css/base.css",
            clipboard        : "/css/clipboard.css",
            code             : "/css/code.css",
            donate           : "/css/donate.css",
            fancybox         : "/css/jquery.fancybox.css",
            footer           : "/css/footer.css",
            iconfont         : "/iconfont/iconfont.css",
            index            : "/css/index.css",
            menuBubble       : "/css/menu-bubble.css",
            mouse            : "/css/mouse.css",
            page             : "/css/page.css",
            post             : "/css/post.css",
            search           : "/css/search.css",
            tocbot           : "/css/tocbot.css",
            valine           : "/css/valine.css",
            waline           : "/css/waline.css",
            walineCustom     : "/css/waline-custom.css"
        },

        Script: {
            aplayer          : "/js/APlayer.min.js",
            config           : "/js/require.config.js",
            index            : "/js/index.js",
            instantSearch    : "/js/instantsearch.min.js",
            iscroll          : "/js/iscroll.js",
            jQuery           : "/js/jquery-3.4.1.min.js",
            loading          : "/js/loading.js",
            meting           : "/js/Meting.min.js",
            require          : "/js/require.min.js",
            waline           : "/js/waline.mjs",
            pageview         : "/js/pageview.mjs",
            comment          : "/js/comment.mjs",
        },

        Font: {
            LongCang    : "/font/LongCang.css",
            Monda       : "/font/Monda.css",
            NotoSansSC  : "/font/NotoSansSC.css",
            NotoSerifSC : "/font/NotoSerifSC.css",
            Playball    : "/font/Playball.css",
            PTMono      : "/font/PTMono.css",
            Roboto      : "/font/Roboto.css",
            RobotoSlab  : "/font/RobotoSlab.css",
            Rosario     : "/font/Rosario.css",
            UbuntuMono  : "/font/UbuntuMono.css"
        },

        Suffix : {
            about : "简单地活着, 肆意又精彩."
        },
            
        Theme : {
            url  : "https://github.com/first19326/Hexo-LiveForCode",
            name : "Hexo - Live For Code"
        }  
    };
</script>
    <script type="text/javascript" src="/js/index.js"></script>
</body>
</html>