<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>进程控制</title>
      <link href="/2025/11/23/%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6/"/>
      <url>/2025/11/23/%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h2 id="进程控制"><a href="#进程控制" class="headerlink" title="进程控制"></a>进程控制</h2><h3 id="1-进程创建"><a href="#1-进程创建" class="headerlink" title="1. 进程创建"></a>1. 进程创建</h3><h4 id="1-1-重识-fork-函数"><a href="#1-1-重识-fork-函数" class="headerlink" title="1.1 重识 fork 函数"></a>1.1 重识 fork 函数</h4><h5 id="1-1-1-fork-回顾"><a href="#1-1-1-fork-回顾" class="headerlink" title="1.1.1 fork 回顾"></a>1.1.1 fork 回顾</h5><p>在进程概念中已经提到过 <code>fork</code> 函数</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">fork</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="comment">// 子进程返回 0，父进程返回子进程 pid，出错返回 -1</span></span><br></pre></td></tr></table></figure><p>调用 <code>fork</code> 时，当控制转移到内核中的 <code>fork</code> 代码部分后，内核：</p><ul><li>分配新的内存块和内核数据结构给子进程</li><li>将父进程部分数据结构内容拷贝至子进程</li><li>添加子进程到系统进程列表中</li><li><code>fork</code> 返回，调度器开始调度</li></ul><!-- ![1749342974252](image/进程控制/1749342974252.png) --><img src="/2025/11/23/%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6/1749342974252.png" class=""><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Before fork: pid is: %d\n&quot;</span>, getpid());</span><br><span class="line">    <span class="type">pid_t</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;Fork error\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;After fork:  pid is: %d\n&quot;</span>, getpid());</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行结果</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ ./fork </span><br><span class="line">Before fork: pid is: 1549627</span><br><span class="line">After fork:  pid is: 1549627</span><br><span class="line">After fork:  pid is: 1549628 </span><br></pre></td></tr></table></figure><p>可以看到，输出一行 <code>After fork</code> 和两行 <code>After fork</code>，但是进程 <code>1549628</code> 并没有打印 <code>After fork</code> 原因如下👇</p><!-- ![1749346249337](image/进程控制/1749346249337.png) --><img src="/2025/11/23/%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6/1749346249337.png" class=""><p><code>fork</code> 之前父进程独立执行，<code>fork</code> 之后，父子进程分别执行，属于两个执行流，执行的先后顺序完全由调度器决定</p><h5 id="1-1-2-写时拷贝-Copy-On-Write"><a href="#1-1-2-写时拷贝-Copy-On-Write" class="headerlink" title="1.1.2 写时拷贝(Copy On Write)"></a>1.1.2 写时拷贝(Copy On Write)</h5><p><strong>写时拷贝</strong>，其<strong>只有在真正需要修改内存内容时，才执行实际的物理内存复制操作。</strong> 在此之前，多个进程可以安全地共享同一份物理内存页的只读副本。通常，父子进程代码共享，父子不再写入时，数据也是共享的，当任意一方尝试写入的时候，便以写时拷贝的方式各自得到一份副本</p><!-- ![1749347910479](image/进程控制/1749347910479.png) --><img src="/2025/11/23/%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6/1749347910479.png" class=""><p><strong>写时拷贝 <code>fork()</code> 的工作原理</strong></p><ol><li><p><strong>共享初始状态：</strong></p><ul><li>当父进程调用 <code>fork()</code> 时，操作系统<strong>不会立即复制</strong>父进程的物理内存页</li><li>相反，它只为子进程创建一个新的<strong>进程描述符（PCB）</strong> 和一个新的<strong>页表</strong></li><li>子进程的页表被初始化为<strong>指向父进程相同的物理内存页</strong></li><li>此时，父子进程共享<strong>所有</strong>物理内存页（包括代码、数据、堆、栈）。它们在用户空间看到的是完全相同的地址空间内容</li><li><code>fork()</code> <strong>立即返回</strong>给父子进程（父进程得到子进程 <code>PID</code>，子进程得到 <code>0</code>）。这个初始创建过程非常快，因为它只涉及创建元数据（页表项等），不涉及大量内存复制</li></ul></li><li><p><strong>标记为只读（关键步骤）：</strong></p><ul><li>为了让 <code>COW</code> 机制生效，操作系统会将所有被父子进程共享的物理内存页在<strong>双方的页表项</strong>中都标记为<strong>只读</strong></li><li>这意味着父子进程目前都只能<strong>读取</strong>这些共享页，不能写入</li></ul></li><li><p><strong>触发写时拷贝：</strong></p><ul><li>当<strong>父进程</strong>或<strong>子进程</strong>中的任何一个<strong>首次尝试写入</strong>某个共享的内存页时，<code>CPU</code> 会检测到这是一个对“只读”页的写操作</li><li>这会触发一个<strong>缺页异常</strong></li><li>操作系统捕获这个异常</li></ul></li><li><p><strong>执行实际拷贝：</strong></p><ul><li>操作系统检查引发异常的地址对应的物理页</li><li>它发现这个页是共享的（标记为 <code>COW</code>）</li><li>操作系统：<ul><li><strong>分配</strong>一个新的、空闲的物理内存页</li><li><strong>复制</strong>原来共享物理页的内容到这个新分配的页</li><li><strong>更新</strong>尝试写入的那个进程（父或子）的页表项：使其指向新复制的物理页，并将页表项标记为<strong>可读写</strong></li><li><strong>保留</strong>另一个进程的页表项：仍然指向原来的物理页，并保持（或恢复）其<strong>可读写</strong>权限（如果该页之前未被另一个进程写入触发过 <code>COW</code>）。如果另一个进程之后尝试写入这个页，它也会触发自己的 <code>COW</code> 操作</li></ul></li><li>操作系统在完成复制和页表更新后，返回到引发异常的指令处重新执行</li><li>这次，写操作就可以成功执行在<strong>新复制的、私有的</strong>物理页上了</li></ul></li><li><p><strong>后续写入：</strong></p><ul><li>对于已经被处理过 <code>COW</code> 的页（即某个进程已经拥有其私有副本），该进程后续的写入操作会直接作用于它的私有副本，不会再触发异常</li><li>另一个进程如果还未写入过该页，它访问的仍然是原来的共享页（或该页后来被它自己触发了 <code>COW</code> 后得到的私有副本）</li></ul></li></ol><h5 id="1-2-3-fork常规用法"><a href="#1-2-3-fork常规用法" class="headerlink" title="1.2.3 fork常规用法"></a>1.2.3 fork常规用法</h5><p><code>fork()</code> 的核心价值在于创建隔离的执行环境。其主要应用场景围绕进程创建、程序加载 (<code>fork+exec</code>)、并发处理、守护进程实现、进程监控以及利用进程间通信实现协作</p><ul><li>父进程希望复制自己，使父子进程同时执行不同的代码段</li><li>进程需要执行不同的程序</li></ul><h5 id="1-2-4-fork-失败的原因"><a href="#1-2-4-fork-失败的原因" class="headerlink" title="1.2.4 fork 失败的原因"></a>1.2.4 fork 失败的原因</h5><p><code>fork()</code> 系统调用失败（返回 <code>-1</code>）通常是由于操作系统无法为新进程分配必要的资源。以下是最常见的原因及其触发场景：</p><ol><li><p><strong>进程数达到系统或用户限制 (最常见原因之一):</strong></p><ul><li><strong>系统级限制:</strong> 操作系统内核有一个全局变量 (<code>max_processes</code> 或类似) 限制整个系统能同时存在的最大进程数。当所有进程槽（<code>PCB</code> 表项）都被占用时，<code>fork()</code> 会失败</li><li><strong>用户级限制 (<code>RLIMIT_NPROC</code>):</strong> 系统管理员或 <code>init</code> 系统（如 <code>systemd</code>）可以为每个用户（或登录会话）设置允许创建的最大进程数限制。通过 <code>ulimit -u</code> 命令可以查看或设置当前 Shell 会话的软限制。当用户或其子进程创建的总进程数（包括线程，因为 <code>Linux</code> 上线程也是轻量级进程 <code>LWP</code>）达到这个上限时，<code>fork()</code> 会失败</li><li><strong>触发场景:</strong><ul><li>编写了创建大量子进程且没有正确等待回收的代码（产生了“进程泄漏”或僵尸进程堆积）</li><li>恶意或错误的程序（如 <code>fork</code> 炸弹 <code>:()&#123; :|:&amp; &#125;;:</code>）</li><li>系统负载极高，大量用户或进程在运行</li><li>容器（如 <code>Docker</code>）环境中被配置了严格的进程数限制 (<code>pids.max</code> <code>cgroup</code> 参数)</li></ul></li></ul></li><li><p><strong>内存不足:</strong></p><ul><li><strong>物理内存 + Swap 耗尽:</strong> <code>fork()</code> 需要为新进程创建内核数据结构（如 <code>task_struct</code>, 页表）。更重要的是，即使采用写时拷贝 (<code>COW</code>)，也需要为新进程的页表分配内存（虚拟地址空间结构），并预留一部分物理内存来应对潜在的 <code>COW</code> 操作。如果系统物理内存和交换空间 (<code>Swap</code>) 都严重不足，无法满足这些需求，<code>fork()</code> 会失败</li><li><strong>虚拟地址空间耗尽 (<code>RLIMIT_AS</code>):</strong> 每个进程都有一定的虚拟地址空间大小限制（在 <code>32</code> 位系统上通常是 <code>3GB</code> 用户空间，<code>64</code> 位系统则非常大）。虽然 <code>fork()</code> 本身不立即分配大量物理内存，但它会为子进程复制父进程的虚拟地址空间布局。如果父进程的虚拟地址空间已经非常庞大且碎片化，或者用户进程的虚拟地址空间限制 (<code>RLIMIT_AS</code>) 设置过低，导致内核无法为子进程分配足够的虚拟内存区域描述符 (<code>vm_area_struct</code>) 或建立完整的页表映射，<code>fork()</code> 也可能失败。这在 <code>32</code> 位系统处理超大进程时更常见</li></ul></li><li><p><strong>内核资源耗尽:</strong></p><ul><li><strong>PID 耗尽:</strong> 系统用于标识进程的 <code>PID</code> 号是有限的（由 <code>/proc/sys/kernel/pid_max</code> 定义）。虽然这个上限通常很大（默认 32768），但在极端情况下（如短时间创建销毁大量进程），<code>PID</code> 号池可能被暂时耗尽，导致 <code>fork()</code> 无法分配新的 <code>PID</code></li><li><strong>其他内核结构:</strong> 创建进程还需要分配其他内核数据结构，如文件描述符表项（虽然文件描述符本身是继承的，但内核需要管理）、信号处理结构、各种内核锁和队列的资源等。如果这些底层内核资源池耗尽，<code>fork()</code> 也会失败。这种情况相对少见，通常发生在内核存在资源泄漏或系统配置极不合理时</li></ul></li></ol><p>注意 ⚠ <strong>检查 <code>fork()</code> 的返回值</strong></p><h3 id="2-进程终止"><a href="#2-进程终止" class="headerlink" title="2. 进程终止"></a>2. 进程终止</h3><p>进程终止的本质是释放系统资源，就是释放进程申请的相关内核数据结构和对应的数据和代码</p><h4 id="2-1-进程退出场景"><a href="#2-1-进程退出场景" class="headerlink" title="2.1 进程退出场景"></a>2.1 进程退出场景</h4><ul><li><strong>代码运行完毕，结果正确：</strong> 通过退出状态码 <code>0</code> 表示</li><li><strong>代码运行完毕，结果不正确：</strong> 通过<strong>非零</strong>的退出状态码 (通常 1-255) 表示具体错误类型</li><li><strong>代码异常终止：</strong> 进程因接收到<strong>信号</strong>而被迫终止（如 <code>SIGINT</code> (<code>ctrl+c</code>), <code>SIGSEGV</code>, <code>SIGFPE</code>, <code>SIGABRT</code>, <code>SIGKILL</code> 等）</li></ul><h4 id="2-2-进程退出方法"><a href="#2-2-进程退出方法" class="headerlink" title="2.2 进程退出方法"></a>2.2 进程退出方法</h4><p><strong>正常终止</strong>可以通过 <code>echo $?</code> 查看进程退出码, <code>echo $?</code>在 <code>shell</code> 中存储的是<strong>上一个执行完毕的（子）进程的退出状态码</strong></p><ul><li>从 <code>main</code> 返回</li><li>调用 <code>exit</code></li><li>调用 <code>_exit</code></li></ul><p><strong>异常退出</strong></p><ul><li><code>ctrl + c</code>:信号终止</li></ul><h5 id="2-2-1-退出码"><a href="#2-2-1-退出码" class="headerlink" title="2.2.1 退出码"></a>2.2.1 退出码</h5><p>退出码也叫退出状态，在 <code>Linux</code> 中，<strong>退出码（Exit Status 或 Exit Code）</strong> 是进程终止时返回给其父进程（通常是 <code>Shell</code>）的一个 <strong>0 到 255 之间的整数值</strong>，用于指示进程的执行结果。在命令结束以后，我们知道命令是成功完成的还是以错误结束。其基本思想是：<code>0</code> 通常表示成功，<strong>非 <code>0</code></strong> 值表示各种类型的错误(具体含义由程序定义)</p><table><thead><tr><th align="left">退出码</th><th align="left">含义</th><th align="left">常见场景&#x2F;说明</th></tr></thead><tbody><tr><td align="left"><strong>0</strong></td><td align="left"><strong>成功 (<code>Success</code>)</strong></td><td align="left">命令或程序按预期成功完成</td></tr><tr><td align="left"><strong>1</strong></td><td align="left"><strong>一般性错误 (<code>General Error/Catch-all for errors</code>)</strong></td><td align="left">程序内部未指定具体错误类型的失败（例如，命令语法正确但操作失败）</td></tr><tr><td align="left"><strong>2</strong></td><td align="left"><strong><code>Shell</code> 内置命令或脚本的误用 (<code>Misuse of shell builtins</code>)</strong></td><td align="left">命令参数错误、非法选项（如 <code>bash -c &#39;echo $@&#39;</code> 不带参数）</td></tr><tr><td align="left"><strong>126</strong></td><td align="left"><strong>命令不可执行 (<code>Command invoked cannot execute</code>)</strong></td><td align="left">文件权限不足（非可执行文件）、或尝试执行一个目录</td></tr><tr><td align="left"><strong>127</strong></td><td align="left"><strong>命令未找到 (<code>Command not found</code>)</strong></td><td align="left"><code>PATH</code> 中不存在该命令，或输入了错误的命令名</td></tr><tr><td align="left"><strong>128</strong></td><td align="left"><strong>无效退出码参数 (<code>Invalid argument to exit</code>)</strong></td><td align="left">程序试图使用 <code>exit</code> 传递一个非整数参数（如 <code>exit 3.14</code>）</td></tr><tr><td align="left"><strong>128 + N</strong></td><td align="left"><strong>进程因信号 <code>N</code> 终止 (<code>Fatal error signal &quot;N&quot;</code>)</strong></td><td align="left"><strong>最重要的异常退出码！</strong> 表示进程被信号 <code>N</code> 强制终止</td></tr><tr><td align="left"><strong>130</strong></td><td align="left"><strong>(<code>128</code> + <code>2</code>)</strong> 进程被 <code>SIGINT</code> 中断</td><td align="left">用户按下了 <code>Ctrl+C</code> 终止前台进程</td></tr><tr><td align="left"><strong>137</strong></td><td align="left"><strong>(<code>128</code> + <code>9</code>)</strong> 进程被 <code>SIGKILL</code> 强制杀死</td><td align="left">使用 <code>kill -9</code> 或系统 <code>OOM Killer</code> 终止进程</td></tr><tr><td align="left"><strong>139</strong></td><td align="left"><strong>(128 + 11)</strong> 进程因 <code>SIGSEGV</code> 崩溃</td><td align="left">段错误（<code>Segmentation Fault</code>），通常是非法内存访问（如空指针解引用、数组越界）</td></tr><tr><td align="left"><strong>143</strong></td><td align="left"><strong>(<code>128</code> + <code>15</code>)</strong> 进程被 <code>SIGTERM</code> 终止</td><td align="left">默认的 <code>kill</code> 命令发送的信号，请求进程正常退出</td></tr><tr><td align="left"><strong>255</strong></td><td align="left"><strong>退出状态超出范围 (<code>Exit status out of range</code>)</strong></td><td align="left">程序返回了大于 <code>255</code> 的退出码（会被 <code>Shell</code> 截断为 <code>255</code>）</td></tr></tbody></table><h5 id="2-3-1-exit-VS-exit"><a href="#2-3-1-exit-VS-exit" class="headerlink" title="2.3.1 exit VS _exit"></a>2.3.1 exit VS _exit</h5><p><strong><code>exit</code></strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line">[[<span class="keyword">noreturn</span>]] <span class="type">void</span> <span class="title function_">exit</span><span class="params">(<span class="type">int</span> status)</span>;</span><br></pre></td></tr></table></figure><p><strong><code>_exit</code></strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line">[[<span class="keyword">noreturn</span>]] <span class="type">void</span> _exit(<span class="type">int</span> status);</span><br><span class="line"><span class="comment">// 属于 POSIX 系统调用</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line">[[<span class="keyword">noreturn</span>]] <span class="type">void</span> _Exit(<span class="type">int</span> status);</span><br><span class="line"><span class="comment">// 是 C99 标准引入的函数（与 _exit 行为一致）</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 注：[[noreturn]] 表示向编译器声明该函数 永远不会返回到调用点</span></span><br></pre></td></tr></table></figure><p>在 <code>Linux</code> 环境下，<code>exit()</code> 和 <code>_exit()</code> 函数都用于终止进程，但它们在资源清理和缓冲区处理上有重要区别：</p><ol><li><code>_exit()</code> 系统调用(粗暴终止)<ul><li><strong>定义</strong>：<code>#include &lt;unistd.h&gt;``void _exit(int status);</code></li><li><strong>行为</strong>：<ul><li><strong>直接终止进程</strong>：立即结束调用进程</li><li><strong>不清理缓冲区</strong>：不刷新标准 <code>I</code>&#x2F;<code>O</code> 缓冲区（如 <code>printf</code> 的缓冲区）</li><li><strong>关闭文件描述符</strong>：关闭进程打开的所有文件描述符</li><li><strong>通知父进程</strong>：向父进程发送 <code>SIGCHLD</code> 信号，并通过 <code>wait()</code> 传递退出状态 <code>status</code></li></ul></li><li><strong>使用场景</strong>：<ul><li>子进程退出时避免干扰父进程的 <code>I</code>&#x2F;<code>O</code> 缓冲区（尤其在 <code>fork()</code> 后）</li><li>需要立即终止进程且不进行任何清理时</li></ul></li></ul></li></ol><p><strong>示例</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello&quot;</span>);  <span class="comment">// 无换行符，数据在缓冲区</span></span><br><span class="line">    _exit(<span class="number">0</span>);         <span class="comment">// 直接退出，&quot;Hello&quot; 不会被输出！</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>执行结果</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ ./_exit </span><br><span class="line">$ <span class="built_in">echo</span> $?</span><br><span class="line">0</span><br></pre></td></tr></table></figure><ol start="2"><li><code>exit()</code> 库函数(安全终止)<ul><li><strong>定义</strong>：<code>#include &lt;stdlib.h&gt;``void exit(int status);</code></li><li><strong>行为</strong>：<ol><li><strong>调用退出处理函数</strong>：按注册的逆序执行 <code>atexit()</code> 或 <code>on_exit()</code> 注册的函数</li><li><strong>刷新所有 <code>I</code>&#x2F;<code>O</code> 缓冲区</strong>：清空 <code>stdio</code> 缓冲区（如输出 <code>printf</code> 的内容）</li><li><strong>关闭所有 <code>I</code>&#x2F;<code>O</code> 流</strong>：关闭通过 <code>fopen()</code> 打开的文件流</li><li><strong>删除临时文件</strong>：删除 <code>tmpfile()</code> 创建的临时文件</li><li><strong>最终调用 <code>_exit()</code></strong>：执行系统调用 <code>_exit(status)</code> 终止进程</li></ol></li><li><strong>使用场景</strong>：<ul><li>正常退出程序时（确保资源正确释放）</li><li>需要执行自定义清理逻辑（通过 <code>atexit()</code> 注册）</li></ul></li></ul></li></ol><p><strong>示例</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">cleanup</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Cleanup done\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    atexit(cleanup);  <span class="comment">// 注册清理函数</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">    <span class="built_in">exit</span>(<span class="number">0</span>);          <span class="comment">// 输出 &quot;Hello&quot; 和 &quot;Cleanup done&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>执行结果</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ ./exit </span><br><span class="line">HelloCleanup <span class="keyword">done</span></span><br></pre></td></tr></table></figure><table><thead><tr><th><strong>特性</strong></th><th><code>_exit()</code></th><th><code>exit()</code></th></tr></thead><tbody><tr><td><strong>所属库</strong></td><td>系统调用（<code>Unix API</code>）</td><td><code>C</code> 标准库函数</td></tr><tr><td><strong>刷新 <code>I</code>&#x2F;<code>O</code> 缓冲区</strong></td><td>❌ 不刷新</td><td>✅ 刷新</td></tr><tr><td><strong>执行退出处理函数</strong></td><td>❌ 不执行 <code>atexit()</code></td><td>✅ 执行</td></tr><tr><td><strong>关闭文件描述符</strong></td><td>✅ 关闭</td><td>✅ 关闭（间接通过 <code>_exit</code>）</td></tr><tr><td><strong>典型使用场景</strong></td><td>子进程退出、紧急终止</td><td>正常程序退出</td></tr></tbody></table><!-- ![1749366034866](image/进程控制/1749366034866.png) --><img src="/2025/11/23/%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6/1749366034866.png" class=""><blockquote><p>return退出是更常见的退出进程方法，执行return n等同于执行 exit(n)，调用 main函数时会将main的返回值当作exit的参数</p></blockquote><h3 id="3-进程等待"><a href="#3-进程等待" class="headerlink" title="3. 进程等待"></a>3. 进程等待</h3><h4 id="3-1-基本概念"><a href="#3-1-基本概念" class="headerlink" title="3.1 基本概念"></a>3.1 基本概念</h4><p>进程等待是指一个正在运行的进程，由于某些原因（主要是需要外部资源或事件），暂时无法继续执行，主动或被动地让出 <code>CPU</code>，并进入一种非运行状态（通常是阻塞状态），直到它所等待的条件得到满足为止</p><ul><li>在进程概念中讲到，子进程退出，父进程如果不管不顾，就可能造成”僵尸进程”的问题，进而导致内存泄漏</li><li>如果进程变成僵尸状态，哪怕 <code>kill -9</code> 也无能为力(<code>wait</code> 解决)</li><li>父进程通过进程等待的方式，回收子进程资源，获取子进程退出信息</li></ul><h4 id="3-2-进程等待的方法"><a href="#3-2-进程等待的方法" class="headerlink" title="3.2 进程等待的方法"></a>3.2 进程等待的方法</h4><h5 id="3-2-1-wait"><a href="#3-2-1-wait" class="headerlink" title="3.2.1 wait"></a>3.2.1 wait</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">wait</span><span class="params">(<span class="type">int</span> *_Nullable wstatus)</span>;</span><br></pre></td></tr></table></figure><p><strong>功能</strong>- 等待任意一个子进程结束(无法指定具体子进程，按结束顺序处理)<br>    <strong>参数</strong></p><ul><li>输出型参数，获取子进程退出状态，不关心可以设置为 <code>NULL</code><br>  <strong>返回值</strong></li><li>等待成功返回等待进程的 <code>pid</code>，失败返回 <code>-1</code></li></ul><!-- ![1752671923889](image/进程控制/1752671923889.png) --><img src="/2025/11/23/%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6/1752671923889.png" class=""><h5 id="3-2-2-waitpid"><a href="#3-2-2-waitpid" class="headerlink" title="3.2.2 waitpid"></a>3.2.2 waitpid</h5><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">waitpid</span><span class="params">(<span class="type">pid_t</span> pid, <span class="type">int</span> *_Nullable wstatus, <span class="type">int</span> options)</span>;</span><br></pre></td></tr></table></figure><p><strong>功能</strong> 等待指定子进程结束，支持非阻塞模式(精确控制等待的子进程)<br>    <strong>参数</strong></p><ul><li><p><code>pid</code></p><ul><li><code>pid = -1</code>，等待任意一个子进程，等价于<code>wait</code></li><li><code>pid &gt; 0</code>，等待其进程与所设值相等的子进程</li></ul></li><li><p><code>status </code>输出型参数</p><ul><li><code>WIFEXITED(status)</code>：查看进程是否是正常退出，正常退出为真</li><li><code>WEXITSTATUS(status)</code>：查看进程的退出码</li></ul></li><li><p><code>options </code>默认为 <code>0</code>，表示阻塞等待</p><ul><li><code>WNOHANG</code>：若<code>pid</code>指定的子进程没有结束，则<code>waitpid()</code>函数返回0，不予等待；若正常结束，则返回该子进程的 <code>PID</code><br>  <strong>返回值</strong></li></ul></li><li><p>正常返回的时候返回收集到的子进程的 <code>pid</code></p></li><li><p>如果设置了 <code>WNOHANG</code></p><ul><li>调用中<code>waitpid</code>发现没有已退出的子进程可收集，则返回 <code>0</code></li><li>如果调用出错，则返回 <code>-1</code>，且 <code>errno</code> 被设置为相应的值以示错误所在</li></ul></li><li><p>如果子进程已经退出，调用<code>wait/waitpid</code>时，<code>wait/waitpid</code>会立即返回，并且释放资源，获得子进程的退出信息</p></li><li><p>如果在任意时刻调用<code>wait/waitpid</code>，子进程存在且正常运行，则进程可能阻塞</p></li><li><p>如果子进程不存在，则立即出错并且返回</p></li></ul><p><strong>阻塞</strong></p><!-- ![1752671985396](image/进程控制/1752671985396.png) --><img src="/2025/11/23/%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6/1752671985396.png" class=""><p><strong>非阻塞</strong></p><!-- ![1752672039590](image/进程控制/1752672039590.png) --><img src="/2025/11/23/%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6/1752672039590.png" class=""><h5 id="3-2-3-获取子进程-status"><a href="#3-2-3-获取子进程-status" class="headerlink" title="3.2.3 获取子进程 status"></a>3.2.3 获取子进程 status</h5><ul><li><code>wait</code> 和 <code>waitpid</code>，都有一个 <code>status</code>，由操作系统填充</li><li>如果传递 <code>NULL</code>，表示不关心子进程的退出状态信息</li><li><code>status</code> 不能简单的当作整型看待，以更细致的视角—比特看待，类似于位图，如下图(只研究低 <code>16</code> 位)</li></ul><!-- ![1749370975266](image/进程控制/1749370975266.png) --><img src="/2025/11/23/%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6/1749370975266.png" class=""><h6 id="3-2-4-阻塞等待-VS-非阻塞等待"><a href="#3-2-4-阻塞等待-VS-非阻塞等待" class="headerlink" title="3.2.4 阻塞等待 VS 非阻塞等待"></a>3.2.4 阻塞等待 VS 非阻塞等待</h6><p><strong>阻塞等待</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pid_t</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;Fork error&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;I&#x27;m child process[%d]\n&quot;</span>, getpid());</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Sleeping\n&quot;</span>);</span><br><span class="line">        sleep(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> *p = <span class="literal">NULL</span>;</span><br><span class="line">        *p = <span class="number">42</span>; <span class="comment">// 制造段错误(SIGSEGV)</span></span><br><span class="line">        <span class="comment">// exit(128);</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> status = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> ret = waitpid(pid, &amp;status, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (ret == pid)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Wait sucess! Process[%d]\n&quot;</span>, ret);</span><br><span class="line">        <span class="comment">// 检测是否正常退出</span></span><br><span class="line">        <span class="keyword">if</span> (WIFEXITED(status))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Exited normally with status: %d\n&quot;</span>, WEXITSTATUS(status));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 检测是否被信号终止</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (WIFSIGNALED(status))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Killed by signall: %d\n&quot;</span>, WTERMSIG(status));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;Wait error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行结果</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ ./wait</span><br><span class="line">I<span class="string">&#x27;m child process[1573142]</span></span><br><span class="line"><span class="string">Sleeping</span></span><br><span class="line"><span class="string">Wait sucess! Process[1573142]</span></span><br><span class="line"><span class="string">Killed by signall: 11</span></span><br><span class="line"><span class="string">$ echo $?</span></span><br><span class="line"><span class="string">0   #父进程正常退出</span></span><br></pre></td></tr></table></figure><p><strong>非阻塞等待</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">void</span> <span class="params">(* task)</span><span class="params">(<span class="type">int</span>)</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">PrintTask</span><span class="params">(<span class="type">int</span> id)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Task: %d\n&quot;</span>,id);</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">CountTask</span><span class="params">(<span class="type">int</span> num)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Count: %d\n&quot;</span>,num);</span><br><span class="line">    sleep(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">work</span><span class="params">(task t,<span class="type">int</span> num)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i=<span class="number">0</span>;i&lt;num;i++)</span><br><span class="line">    &#123;</span><br><span class="line">        t(i+<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pid_t</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;Fork error&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;I&#x27;m child process[%d]\n&quot;</span>, getpid());</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Sleeping\n&quot;</span>);</span><br><span class="line">        sleep(<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">        <span class="type">int</span> *p = <span class="literal">NULL</span>;</span><br><span class="line">        *p = <span class="number">42</span>; <span class="comment">// 制造段错误(SIGSEGV)</span></span><br><span class="line">        <span class="comment">// exit(128);</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> status = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        ret = waitpid(pid, &amp;status, WNOHANG);</span><br><span class="line">        <span class="keyword">if</span> (ret &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">&quot;Fork error&quot;</span>);</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(ret == pid)&#123;<span class="keyword">break</span>;&#125;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Process is working\n&quot;</span>);</span><br><span class="line">        <span class="comment">// 父进程执行自己的代码</span></span><br><span class="line">        work(PrintTask,<span class="number">2</span>);</span><br><span class="line">        work(CountTask,<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (ret == pid)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Wait sucess! Process[%d]\n&quot;</span>, ret);</span><br><span class="line">        <span class="comment">// 检测是否正常退出</span></span><br><span class="line">        <span class="keyword">if</span> (WIFEXITED(status))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Exited normally with status: %d\n&quot;</span>, WEXITSTATUS(status));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// 检测是否被信号终止</span></span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (WIFSIGNALED(status))</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Killed by signall: %d\n&quot;</span>, WTERMSIG(status));</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">// ……</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;Wait error&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行结果</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">$ ./_wait </span><br><span class="line">Process is working</span><br><span class="line">Task: 1</span><br><span class="line">I<span class="string">&#x27;m child process[1575149]</span></span><br><span class="line"><span class="string">Sleeping</span></span><br><span class="line"><span class="string">Task: 2</span></span><br><span class="line"><span class="string">Count: 1</span></span><br><span class="line"><span class="string">Count: 2</span></span><br><span class="line"><span class="string">Count: 3</span></span><br><span class="line"><span class="string">Wait sucess! Process[1575149]</span></span><br><span class="line"><span class="string">Killed by signall: 11</span></span><br></pre></td></tr></table></figure><h3 id="4-进程程序替换"><a href="#4-进程程序替换" class="headerlink" title="4. 进程程序替换"></a>4. 进程程序替换</h3><h4 id="4-1-基本概念"><a href="#4-1-基本概念" class="headerlink" title="4.1 基本概念"></a>4.1 基本概念</h4><p>进程替换是 <code>Unix/Linux</code> 系统中<strong>核心的进程管理技术</strong>，指在不创建新进程的情况下，<strong>将当前进程的代码和数据完全替换为另一个程序的技术</strong>。这是通过 <code>exec</code> 函数族实现的，常与 <code>fork()</code> 结合使用<br><code>fork</code> 之后，父子各自执行父进程代码的一部分，但是如果子进程想要执行一个全新的程序呢?🤔答案是<strong>程序替换</strong><br>程序替换是通过特定的接口，加载磁盘上的一个全新的程序(代码和数据)，加载到调用进程的地址空间中</p><h4 id="4-2-替换原理"><a href="#4-2-替换原理" class="headerlink" title="4.2 替换原理"></a>4.2 替换原理</h4><p>用 <code>fork</code> 创建子进程之后执行的是和父进程相同的程序(但有可能执行不同的代码分支)，子进程往往要调用一种 <code>exec</code> 函数以执行另一个程序，当进程调用一种 <code>exec</code> 函数时，该进程的用户空间代码和数据完全被新程序替换，从新程序的启动处开始执行。调用 <code>exec</code> 函数并不创建新进程，所以调用 <code>exec</code> 前后该进程的 <code>id</code> 并未改变</p><ul><li><strong>本质</strong>：将当前进程的<strong>内存映像</strong>（代码、数据、堆栈）替换为新程序的映像</li><li><strong>进程ID不变</strong>：<code>PID</code>、<code>PPID</code>、文件描述符等属性保留</li><li><strong>执行流重置</strong>：从新程序的 <code>main()</code> 函数开始执行</li><li><strong>永不返回</strong>：成功调用后<strong>不返回原程序</strong>（除非出错）</li></ul><h4 id="4-3替换函数"><a href="#4-3替换函数" class="headerlink" title="4.3替换函数"></a>4.3替换函数</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">extern</span> <span class="type">char</span> **environ;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">execl</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">const</span> <span class="type">char</span> *arg, ...)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">execlp</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *file, <span class="type">const</span> <span class="type">char</span> *arg, ...)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">execle</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">const</span> <span class="type">char</span> *arg, ...)</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">execv</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *pathname, <span class="type">char</span> *<span class="type">const</span> argv[])</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">execvp</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *file, <span class="type">char</span> *<span class="type">const</span> argv[])</span>;</span><br><span class="line"><span class="type">int</span> <span class="title function_">execvpe</span><span class="params">(<span class="type">const</span> <span class="type">char</span> *file, <span class="type">char</span> *<span class="type">const</span> argv[], <span class="type">char</span> *<span class="type">const</span> envp[])</span>;</span><br></pre></td></tr></table></figure><p><strong>关键特性：替换后保留的资源</strong></p><table><thead><tr><th>资源类型</th><th>是否保留</th><th>说明</th></tr></thead><tbody><tr><td>进程 <code>ID</code> (<code>PID</code>)</td><td>✔️</td><td>还是同一个进程</td></tr><tr><td>父进程 <code>ID</code> (<code>PPID</code>)</td><td>✔️</td><td>父子关系不变</td></tr><tr><td>打开的文件描述符</td><td>✔️</td><td><strong>除非</strong>显式设置 <code>FD_CLOEXEC</code></td></tr><tr><td>工作目录</td><td>✔️</td><td>当前目录不变</td></tr><tr><td>信号处理设置</td><td>❌</td><td>重置为默认处理方式</td></tr><tr><td>内存锁 (<code>mlock</code>)</td><td>❌</td><td>自动释放</td></tr></tbody></table><blockquote><p><strong>文件描述符保留示例</strong>：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> fd = open(<span class="string">&quot;log.txt&quot;</span>, O_WRONLY);</span><br><span class="line">execl(<span class="string">&quot;/bin/ls&quot;</span>, <span class="string">&quot;ls&quot;</span>, <span class="literal">NULL</span>);  <span class="comment">// ls 的输出会写入 log.txt！</span></span><br></pre></td></tr></table></figure></blockquote><ul><li><code>l(list)</code></li><li><code>v(vector)</code></li><li><code>p(path)</code></li><li><code>e(env)</code></li></ul><p><strong>exec 函数族对比（6个变体）</strong></p><table><thead><tr><th>函数</th><th>参数传递方式</th><th>环境变量处理</th><th>PATH搜索</th><th>典型用例</th></tr></thead><tbody><tr><td><code>execl</code></td><td>参数列表</td><td>继承当前环境</td><td>❌</td><td>固定路径程序</td></tr><tr><td><code>execv</code></td><td>参数数组</td><td>继承当前环境</td><td>❌</td><td>动态构建参数</td></tr><tr><td><code>execle</code></td><td>参数列表</td><td>自定义环境变量</td><td>❌</td><td>精确控制环境</td></tr><tr><td><code>execve</code></td><td>参数数组</td><td>自定义环境变量</td><td>❌</td><td>系统编程首选（唯一系统调用）</td></tr><tr><td><code>execlp</code></td><td>参数列表</td><td>继承当前环境</td><td>✔️</td><td>执行 <code>PATH</code> 中的命令</td></tr><tr><td><code>execvp</code></td><td>参数数组</td><td>继承当前环境</td><td>✔️</td><td><code>Shell</code> 命令实现核心</td></tr></tbody></table><!-- ![1749459136756](image/进程控制/1749459136756.png) --><img src="/2025/11/23/%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6/1749459136756.png" class=""><p>使用示例</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> *<span class="type">const</span> argv[]=&#123;<span class="string">&quot;ls&quot;</span>,<span class="string">&quot;-l&quot;</span>,<span class="string">&quot;NULL&quot;</span>&#125;;</span><br><span class="line">    <span class="type">char</span> *<span class="type">const</span> envp[]=&#123;<span class="string">&quot;PATH=/bin:/usr/bin&quot;</span>,<span class="string">&quot;TERM=console&quot;</span>,<span class="string">&quot;NULL&quot;</span>&#125;;</span><br><span class="line">    </span><br><span class="line">    execl(<span class="string">&quot;/bin/ls&quot;</span>,<span class="string">&quot;ls&quot;</span>,<span class="string">&quot;-l&quot;</span>,<span class="literal">NULL</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用环境变量PATH，无需写全路径</span></span><br><span class="line">    execlp(<span class="string">&quot;ls&quot;</span>,<span class="string">&quot;ls&quot;</span>,<span class="string">&quot;-l&quot;</span>,<span class="literal">NULL</span>);</span><br><span class="line">    perror(<span class="string">&quot;execl error&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 自定义环境变量</span></span><br><span class="line">    execle(<span class="string">&quot;ls&quot;</span>,<span class="string">&quot;ls&quot;</span>,<span class="string">&quot;-l&quot;</span>,<span class="literal">NULL</span>,envp);</span><br><span class="line">    perror(<span class="string">&quot;execl error&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用数组传递参数</span></span><br><span class="line">    execv(<span class="string">&quot;/bin/ls&quot;</span>,argv);</span><br><span class="line">    perror(<span class="string">&quot;execl error&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 使用环境变量PATH，无需写全路径</span></span><br><span class="line">    execvp(<span class="string">&quot;ls&quot;</span>,argv);</span><br><span class="line">    perror(<span class="string">&quot;execl error&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 自定义环境变量    </span></span><br><span class="line">    execve(<span class="string">&quot;/bin/ls&quot;</span>,argv,envp);</span><br><span class="line">    perror(<span class="string">&quot;execl error&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>错误处理关键点</strong></p><ol><li><strong>返回值检查</strong>：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (execvp(<span class="string">&quot;unknown_cmd&quot;</span>, args) == <span class="number">-1</span>) &#123;</span><br><span class="line">    perror(<span class="string">&quot;execvp failed&quot;</span>);  <span class="comment">// 打印 &quot;execvp failed: No such file or directory&quot;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><strong>错误类型</strong>：<ul><li><code>ENOENT</code>：文件不存在</li><li><code>EACCES</code>：权限不足</li><li><code>ENOMEM</code>：内存不足</li><li><code>E2BIG</code>：参数列表过长</li></ul></li></ol><blockquote><p><strong>进程替换法则</strong>：  </p><ul><li>需要<strong>保持进程上下文</strong> → 用 exec</li><li>需要<strong>隔离执行环境</strong> → 用 fork-exec</li><li>需要<strong>精确控制环境</strong> → 用 execve </li><li>执行<strong>用户命令</strong> → 用 execvp&#x2F;execlp</li></ul></blockquote><h3 id="5-微型Shell"><a href="#5-微型Shell" class="headerlink" title="5. 微型Shell"></a>5. 微型Shell</h3><h4 id="5-1-目标"><a href="#5-1-目标" class="headerlink" title="5.1 目标"></a>5.1 目标</h4><ul><li>能处理普通命令</li><li>能处理内建命令</li><li>将命令同本地变量、环境变量串联起来</li><li>通过自主实现的 <code>Sehll</code> 理解其运行原理</li></ul><h4 id="5-2-实现原理"><a href="#5-2-实现原理" class="headerlink" title="5.2 实现原理"></a>5.2 实现原理</h4><p>比如下面的互动</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">ls</span></span><br><span class="line">client.cpp  makefile  NamedPipe.hpp  server.cpp</span><br><span class="line">$ top</span><br><span class="line">top - 23:35:10 up 34 days,  4:02,  3 <span class="built_in">users</span>,  load average: 1.01, 1.05, 1.01</span><br><span class="line">Tasks: 150 total,   3 running, 147 sleeping,   0 stopped,   0 zombie</span><br><span class="line">%Cpu(s): 19.0 us, 33.3 sy,  0.0 ni, 47.6 <span class="built_in">id</span>,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st </span><br><span class="line">MiB Mem :   1775.4 total,    192.3 free,   1268.1 used,    471.6 buff/cache     </span><br><span class="line">MiB Swap:      0.0 total,      0.0 free,      0.0 used.    507.3 avail Mem </span><br><span class="line"></span><br><span class="line">    PID USER      PR  NI    VIRT    RES    SHR S  %CPU  %MEM     TIME+ COMMAND                                                                          </span><br><span class="line"> 227896 wyf       20   0    6380   1280   1152 R 100.0   0.1     4w+1d prcess_pool                                                                      </span><br><span class="line">      1 root      20   0   22580   9636   5616 S   0.0   0.5   1:06.51 systemd                                                                          </span><br><span class="line">      2 root      20   0       0      0      0 S   0.0   0.0   0:00.40 kthreadd                                                                         </span><br><span class="line">      3 root      20   0       0      0      0 S   0.0   0.0   0:00.00 pool_workqueue_release                                                           </span><br><span class="line">      4 root       0 -20       0      0      0 I   0.0   0.0   0:00.00 kworker/R-rcu_g                                                                  </span><br><span class="line">        ……                                                              </span><br><span class="line">$ <span class="built_in">pwd</span></span><br><span class="line">/home/wyf/code/</span><br><span class="line">$ </span><br></pre></td></tr></table></figure><p>用下图中的时间轴来表示事件的发生次序，其中时间从左向右。<code>shell</code> 由表示为 <code>bash</code> 的方块表示，随着时间从左向右移动。<code>shell</code> 从用户读入字符串 <code>ls</code>，随机建立新进程，在新进程中运行并等待其结束，随后继续读取新的输入，继续重复上述过程</p><!-- ![1752508555092](image/进程控制/1752508555092.png) --><img src="/2025/11/23/%E8%BF%9B%E7%A8%8B%E6%8E%A7%E5%88%B6/1752508555092.png" class=""><p>进而可以将 <code>shell</code> 可以简化为下面的循环过程</p><ol><li>获取命令行</li><li>解析命令行</li><li>建立新的子进程(<code>fork</code>)</li><li>替换子进程(<code>execvp</code>)</li><li>父进程等待子进程退出</li></ol><p>这样就都和前面所介绍的内容串接起来了</p><h4 id="5-3-实现源码"><a href="#5-3-实现源码" class="headerlink" title="5.3 实现源码"></a>5.3 实现源码</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br><span class="line">140</span><br><span class="line">141</span><br><span class="line">142</span><br><span class="line">143</span><br><span class="line">144</span><br><span class="line">145</span><br><span class="line">146</span><br><span class="line">147</span><br><span class="line">148</span><br><span class="line">149</span><br><span class="line">150</span><br><span class="line">151</span><br><span class="line">152</span><br><span class="line">153</span><br><span class="line">154</span><br><span class="line">155</span><br><span class="line">156</span><br><span class="line">157</span><br><span class="line">158</span><br><span class="line">159</span><br><span class="line">160</span><br><span class="line">161</span><br><span class="line">162</span><br><span class="line">163</span><br><span class="line">164</span><br><span class="line">165</span><br><span class="line">166</span><br><span class="line">167</span><br><span class="line">168</span><br><span class="line">169</span><br><span class="line">170</span><br><span class="line">171</span><br><span class="line">172</span><br><span class="line">173</span><br><span class="line">174</span><br><span class="line">175</span><br><span class="line">176</span><br><span class="line">177</span><br><span class="line">178</span><br><span class="line">179</span><br><span class="line">180</span><br><span class="line">181</span><br><span class="line">182</span><br><span class="line">183</span><br><span class="line">184</span><br><span class="line">185</span><br><span class="line">186</span><br><span class="line">187</span><br><span class="line">188</span><br><span class="line">189</span><br><span class="line">190</span><br><span class="line">191</span><br><span class="line">192</span><br><span class="line">193</span><br><span class="line">194</span><br><span class="line">195</span><br><span class="line">196</span><br><span class="line">197</span><br><span class="line">198</span><br><span class="line">199</span><br><span class="line">200</span><br><span class="line">201</span><br><span class="line">202</span><br><span class="line">203</span><br><span class="line">204</span><br><span class="line">205</span><br><span class="line">206</span><br><span class="line">207</span><br><span class="line">208</span><br><span class="line">209</span><br><span class="line">210</span><br><span class="line">211</span><br><span class="line">212</span><br><span class="line">213</span><br><span class="line">214</span><br><span class="line">215</span><br><span class="line">216</span><br><span class="line">217</span><br><span class="line">218</span><br><span class="line">219</span><br><span class="line">220</span><br><span class="line">221</span><br><span class="line">222</span><br><span class="line">223</span><br><span class="line">224</span><br><span class="line">225</span><br><span class="line">226</span><br><span class="line">227</span><br><span class="line">228</span><br><span class="line">229</span><br><span class="line">230</span><br><span class="line">231</span><br><span class="line">232</span><br><span class="line">233</span><br><span class="line">234</span><br><span class="line">235</span><br><span class="line">236</span><br><span class="line">237</span><br><span class="line">238</span><br><span class="line">239</span><br><span class="line">240</span><br><span class="line">241</span><br><span class="line">242</span><br><span class="line">243</span><br><span class="line">244</span><br><span class="line">245</span><br><span class="line">246</span><br><span class="line">247</span><br><span class="line">248</span><br><span class="line">249</span><br><span class="line">250</span><br><span class="line">251</span><br><span class="line">252</span><br><span class="line">253</span><br><span class="line">254</span><br><span class="line">255</span><br><span class="line">256</span><br><span class="line">257</span><br><span class="line">258</span><br><span class="line">259</span><br><span class="line">260</span><br><span class="line">261</span><br><span class="line">262</span><br><span class="line">263</span><br><span class="line">264</span><br><span class="line">265</span><br><span class="line">266</span><br><span class="line">267</span><br><span class="line">268</span><br><span class="line">269</span><br><span class="line">270</span><br><span class="line">271</span><br><span class="line">272</span><br><span class="line">273</span><br><span class="line">274</span><br><span class="line">275</span><br><span class="line">276</span><br><span class="line">277</span><br><span class="line">278</span><br><span class="line">279</span><br><span class="line">280</span><br><span class="line">281</span><br><span class="line">282</span><br><span class="line">283</span><br><span class="line">284</span><br><span class="line">285</span><br><span class="line">286</span><br><span class="line">287</span><br><span class="line">288</span><br><span class="line">289</span><br><span class="line">290</span><br><span class="line">291</span><br><span class="line">292</span><br><span class="line">293</span><br><span class="line">294</span><br><span class="line">295</span><br><span class="line">296</span><br><span class="line">297</span><br><span class="line">298</span><br><span class="line">299</span><br><span class="line">300</span><br><span class="line">301</span><br><span class="line">302</span><br><span class="line">303</span><br><span class="line">304</span><br><span class="line">305</span><br><span class="line">306</span><br><span class="line">307</span><br><span class="line">308</span><br><span class="line">309</span><br><span class="line">310</span><br><span class="line">311</span><br><span class="line">312</span><br><span class="line">313</span><br><span class="line">314</span><br><span class="line">315</span><br><span class="line">316</span><br><span class="line">317</span><br><span class="line">318</span><br><span class="line">319</span><br><span class="line">320</span><br><span class="line">321</span><br><span class="line">322</span><br><span class="line">323</span><br><span class="line">324</span><br><span class="line">325</span><br><span class="line">326</span><br><span class="line">327</span><br><span class="line">328</span><br><span class="line">329</span><br><span class="line">330</span><br><span class="line">331</span><br><span class="line">332</span><br><span class="line">333</span><br><span class="line">334</span><br><span class="line">335</span><br><span class="line">336</span><br><span class="line">337</span><br><span class="line">338</span><br><span class="line">339</span><br><span class="line">340</span><br><span class="line">341</span><br><span class="line">342</span><br><span class="line">343</span><br><span class="line">344</span><br><span class="line">345</span><br><span class="line">346</span><br><span class="line">347</span><br><span class="line">348</span><br><span class="line">349</span><br><span class="line">350</span><br><span class="line">351</span><br><span class="line">352</span><br><span class="line">353</span><br><span class="line">354</span><br><span class="line">355</span><br><span class="line">356</span><br><span class="line">357</span><br><span class="line">358</span><br><span class="line">359</span><br><span class="line">360</span><br><span class="line">361</span><br><span class="line">362</span><br><span class="line">363</span><br><span class="line">364</span><br><span class="line">365</span><br><span class="line">366</span><br><span class="line">367</span><br><span class="line">368</span><br><span class="line">369</span><br><span class="line">370</span><br><span class="line">371</span><br><span class="line">372</span><br><span class="line">373</span><br><span class="line">374</span><br><span class="line">375</span><br><span class="line">376</span><br><span class="line">377</span><br><span class="line">378</span><br><span class="line">379</span><br><span class="line">380</span><br><span class="line">381</span><br><span class="line">382</span><br><span class="line">383</span><br><span class="line">384</span><br><span class="line">385</span><br><span class="line">386</span><br><span class="line">387</span><br><span class="line">388</span><br><span class="line">389</span><br><span class="line">390</span><br><span class="line">391</span><br><span class="line">392</span><br><span class="line">393</span><br><span class="line">394</span><br><span class="line">395</span><br><span class="line">396</span><br><span class="line">397</span><br><span class="line">398</span><br><span class="line">399</span><br><span class="line">400</span><br><span class="line">401</span><br><span class="line">402</span><br><span class="line">403</span><br><span class="line">404</span><br><span class="line">405</span><br><span class="line">406</span><br><span class="line">407</span><br><span class="line">408</span><br><span class="line">409</span><br><span class="line">410</span><br><span class="line">411</span><br><span class="line">412</span><br><span class="line">413</span><br><span class="line">414</span><br><span class="line">415</span><br><span class="line">416</span><br><span class="line">417</span><br><span class="line">418</span><br><span class="line">419</span><br><span class="line">420</span><br><span class="line">421</span><br><span class="line">422</span><br><span class="line">423</span><br><span class="line">424</span><br><span class="line">425</span><br><span class="line">426</span><br><span class="line">427</span><br><span class="line">428</span><br><span class="line">429</span><br><span class="line">430</span><br><span class="line">431</span><br><span class="line">432</span><br><span class="line">433</span><br><span class="line">434</span><br><span class="line">435</span><br><span class="line">436</span><br><span class="line">437</span><br><span class="line">438</span><br><span class="line">439</span><br><span class="line">440</span><br><span class="line">441</span><br><span class="line">442</span><br><span class="line">443</span><br><span class="line">444</span><br><span class="line">445</span><br><span class="line">446</span><br><span class="line">447</span><br><span class="line">448</span><br><span class="line">449</span><br><span class="line">450</span><br><span class="line">451</span><br><span class="line">452</span><br><span class="line">453</span><br><span class="line">454</span><br><span class="line">455</span><br><span class="line">456</span><br><span class="line">457</span><br><span class="line">458</span><br><span class="line">459</span><br><span class="line">460</span><br><span class="line">461</span><br><span class="line">462</span><br><span class="line">463</span><br><span class="line">464</span><br><span class="line">465</span><br><span class="line">466</span><br><span class="line">467</span><br><span class="line">468</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;iostream&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;wait.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/stat.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;fcntl.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CMDLINESIZE 128</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> CMDSIZE 1024</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ARGVSIZE 512</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SPACE <span class="string">&quot; &quot;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> ENVSIZE 1000</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> BUFFERSIZE 1024</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> NO_REDIR 0</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> INPUT_REDIR 1</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> OUTPUT_REDIR 2</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> APPEND_REDIR 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 命令行参数表</span></span><br><span class="line"><span class="type">int</span> g_argc = <span class="number">0</span>;</span><br><span class="line"><span class="type">char</span> *g_argv[ARGVSIZE];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 环境变量表</span></span><br><span class="line"><span class="type">char</span> *g_env[ENVSIZE];</span><br><span class="line"><span class="type">int</span> g_envs = <span class="number">0</span>;</span><br><span class="line"><span class="keyword">extern</span> <span class="type">char</span> **environ;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 重定向</span></span><br><span class="line"><span class="type">int</span> redir = <span class="number">0</span>;</span><br><span class="line"><span class="built_in">std</span>::<span class="built_in">string</span> filename;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 退出状态</span></span><br><span class="line"><span class="type">int</span> g_status = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 命令行提示符</span></span><br><span class="line"><span class="type">char</span> CmdLine[CMDLINESIZE];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 所输入命令行</span></span><br><span class="line"><span class="type">char</span> Cmd[CMDSIZE];</span><br><span class="line"></span><br><span class="line"><span class="comment">// 更新环境变量所用</span></span><br><span class="line"><span class="type">char</span> buffer[BUFFERSIZE];</span><br><span class="line"><span class="type">char</span> tmp_buffer[BUFFERSIZE];</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">InitEnv</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    g_envs = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">memset</span>(g_env, <span class="number">0</span>, <span class="keyword">sizeof</span>(g_env));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; environ[i]; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        g_env[i] = (<span class="type">char</span> *)<span class="built_in">malloc</span>(<span class="built_in">strlen</span>(environ[i]) + <span class="number">1</span>);</span><br><span class="line">        <span class="built_in">strcpy</span>(g_env[i], environ[i]);</span><br><span class="line">        g_envs++;</span><br><span class="line">    &#125;</span><br><span class="line">    g_env[g_envs] = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="comment">// g_env[1]=(char*)&quot;MYTEST=SUCESS!!!&quot;;</span></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; g_env[i]; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        putenv(g_env[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    environ = g_env;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *<span class="title function_">GetUsr</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *usr = getenv(<span class="string">&quot;USER&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> usr == <span class="literal">NULL</span> ? <span class="literal">NULL</span> : usr;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *<span class="title function_">GetHostName</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">char</span> hostname[<span class="number">1024</span>];</span><br><span class="line">    <span class="comment">// 系统调用获取主机名</span></span><br><span class="line">    gethostname(hostname, <span class="keyword">sizeof</span>(hostname));</span><br><span class="line">    <span class="keyword">return</span> hostname == <span class="literal">NULL</span> ? <span class="literal">NULL</span> : hostname;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">const</span> <span class="type">char</span> *<span class="title function_">GetPwd</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 获取当前路径---使用系统调用</span></span><br><span class="line">    <span class="keyword">if</span> (getcwd(tmp_buffer, <span class="keyword">sizeof</span>(tmp_buffer)))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(tmp_buffer, getenv(<span class="string">&quot;PWD&quot;</span>)) != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="built_in">snprintf</span>(buffer, <span class="keyword">sizeof</span>(buffer), <span class="string">&quot;PWD=%s&quot;</span>, tmp_buffer);</span><br><span class="line">            putenv(buffer);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *pwd = getenv(<span class="string">&quot;PWD&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> pwd == <span class="literal">NULL</span> ? <span class="literal">NULL</span> : pwd;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">char</span> *<span class="title function_">GetHome</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> *home = getenv(<span class="string">&quot;HOME&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> home == <span class="literal">NULL</span> ? <span class="literal">NULL</span> : home;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">bool</span> <span class="title function_">MakCmdLine</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> pwd = GetPwd();</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> pwd_last = pwd.substr(pwd.rfind(<span class="string">&quot;/&quot;</span>) + <span class="number">1</span>, <span class="built_in">strlen</span>(pwd.c_str()) - pwd.rfind(<span class="string">&quot;/&quot;</span>));</span><br><span class="line">    <span class="built_in">snprintf</span>(CmdLine, <span class="keyword">sizeof</span>(CmdLine), <span class="string">&quot;[%s@%s %s]-_-&quot;</span>, GetUsr(), GetHostName(), pwd_last.c_str());</span><br><span class="line">    <span class="keyword">return</span> pwd_last.c_str() == <span class="literal">NULL</span> ? <span class="literal">false</span> : <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">bool</span> <span class="title function_">PrintCommandLine</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 打印命令行提示符</span></span><br><span class="line">    <span class="keyword">if</span> (MakCmdLine())</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s&quot;</span>, CmdLine);</span><br><span class="line">        fflush(<span class="built_in">stdout</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">bool</span> <span class="title function_">GetCmd</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 获取输入的命令</span></span><br><span class="line">    <span class="keyword">return</span> fgets(Cmd, <span class="keyword">sizeof</span>(Cmd), <span class="built_in">stdin</span>) == <span class="literal">NULL</span> ? <span class="literal">false</span> : <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">IsSpace</span><span class="params">(<span class="type">char</span> c[], <span class="type">int</span> *index)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">while</span> (c[*index] != <span class="string">&#x27;\0&#x27;</span> &amp;&amp; <span class="built_in">isspace</span>(c[*index]))</span><br><span class="line">    &#123;</span><br><span class="line">        ++(*index);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ls -a -l -n &gt; log.txt</span></span><br><span class="line"><span class="type">bool</span> <span class="title function_">CheckRedir</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    redir = NO_REDIR;</span><br><span class="line">    filename.clear();</span><br><span class="line">    <span class="type">int</span> start = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> end = <span class="built_in">strlen</span>(Cmd) - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">while</span> (start &lt;= end)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (Cmd[start] == <span class="string">&#x27;&lt;&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            redir = INPUT_REDIR;</span><br><span class="line">            Cmd[start] = <span class="number">0</span>;</span><br><span class="line">            start++;</span><br><span class="line">            IsSpace(Cmd, &amp;start);</span><br><span class="line">            <span class="keyword">if</span> (Cmd[start])</span><br><span class="line">            &#123;</span><br><span class="line">                filename = Cmd + start;</span><br><span class="line">                filename.erase(filename.find_last_not_of(<span class="string">&quot;\n\r\t&quot;</span>) + <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;No file name\n&quot;</span>);</span><br><span class="line">                redir = NO_REDIR;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span> (Cmd[start] == <span class="string">&#x27;&gt;&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (Cmd[start + <span class="number">1</span>] == <span class="string">&#x27;&gt;&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                redir = APPEND_REDIR;</span><br><span class="line">                Cmd[start] = <span class="number">0</span>;</span><br><span class="line">                Cmd[start + <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">                start += <span class="number">2</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                redir = OUTPUT_REDIR;</span><br><span class="line">                Cmd[start] = <span class="number">0</span>;</span><br><span class="line">                start++;</span><br><span class="line">            &#125;</span><br><span class="line">            IsSpace(Cmd, &amp;start);</span><br><span class="line">            <span class="keyword">if</span> (Cmd[start])</span><br><span class="line">            &#123;</span><br><span class="line">                filename = Cmd + start;</span><br><span class="line">                filename.erase(filename.find_last_not_of(<span class="string">&quot;\n\r\t&quot;</span>) + <span class="number">1</span>);</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span></span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;No file name\n&quot;</span>);</span><br><span class="line">                redir = NO_REDIR;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">else</span></span><br><span class="line">        &#123;</span><br><span class="line">            ++start;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">CmdSlice</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 处理输入的命令</span></span><br><span class="line">    Cmd[<span class="built_in">strlen</span>(Cmd) - <span class="number">1</span>] = <span class="number">0</span>;</span><br><span class="line">    g_argc = <span class="number">0</span>;</span><br><span class="line">    g_argv[g_argc] = strtok(Cmd, SPACE);</span><br><span class="line">    <span class="keyword">while</span> (g_argv[g_argc] != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        g_argv[++g_argc] = strtok(<span class="literal">NULL</span>, SPACE);</span><br><span class="line">    &#125;</span><br><span class="line">    g_argv[g_argc] = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> g_argc == <span class="number">0</span> ? <span class="literal">false</span> : <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">RedirOpen</span><span class="params">(<span class="type">int</span> &amp;fd)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (redir == INPUT_REDIR)</span><br><span class="line">    &#123;</span><br><span class="line">        fd = open(filename.c_str(), O_RDONLY);</span><br><span class="line">        <span class="keyword">if</span> (fd &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">&quot;open failed:&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        dup2(fd, <span class="number">0</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (redir == OUTPUT_REDIR)</span><br><span class="line">    &#123;</span><br><span class="line">        fd = open(filename.c_str(), O_CREAT | O_WRONLY | O_TRUNC, <span class="number">00666</span>);</span><br><span class="line">        <span class="keyword">if</span> (fd &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">&quot;open failed:&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        dup2(fd, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (redir == APPEND_REDIR)</span><br><span class="line">    &#123;</span><br><span class="line">        fd = open(filename.c_str(), O_CREAT | O_WRONLY | O_APPEND, <span class="number">00666</span>);</span><br><span class="line">        <span class="keyword">if</span> (fd &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">&quot;open failed:&quot;</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        dup2(fd, <span class="number">1</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"><span class="type">bool</span> <span class="title function_">RedirOpenAndRcover</span><span class="params">(<span class="type">int</span> &amp;fd, <span class="type">int</span> &amp;back_up)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (redir == INPUT_REDIR)</span><br><span class="line">    &#123;</span><br><span class="line">        fd = open(filename.c_str(), O_RDONLY);</span><br><span class="line">        <span class="keyword">if</span> (fd &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">&quot;open failed:&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        back_up = dup(<span class="number">0</span>);</span><br><span class="line">        dup2(fd, <span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (redir == OUTPUT_REDIR)</span><br><span class="line">    &#123;</span><br><span class="line">        fd = open(filename.c_str(), O_CREAT | O_WRONLY | O_TRUNC, <span class="number">00666</span>);</span><br><span class="line">        <span class="keyword">if</span> (fd &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">&quot;open failed:&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        back_up = dup(<span class="number">1</span>);</span><br><span class="line">        dup2(fd, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (redir == APPEND_REDIR)</span><br><span class="line">    &#123;</span><br><span class="line">        fd = open(filename.c_str(), O_CREAT | O_WRONLY | O_APPEND, <span class="number">00666</span>);</span><br><span class="line">        <span class="keyword">if</span> (fd &lt; <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">&quot;open failed:&quot;</span>);</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        back_up = dup(<span class="number">1</span>);</span><br><span class="line">        dup2(fd, <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">Cd</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (g_argc == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (chdir(GetHome()) != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">&quot;cd failed:&quot;</span>);</span><br><span class="line">            g_status = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (g_argc == <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">const</span> <span class="type">char</span> *target_path = g_argv[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">strcmp</span>(target_path, <span class="string">&quot;~&quot;</span>) == <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            target_path = GetHome();</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span> (chdir(target_path) != <span class="number">0</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            perror(<span class="string">&quot;cd failed:&quot;</span>);</span><br><span class="line">            g_status = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        g_status = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">fprintf</span>(<span class="built_in">stderr</span>, <span class="string">&quot;cd too many arguments\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (getcwd(tmp_buffer, <span class="keyword">sizeof</span>(tmp_buffer)))</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">snprintf</span>(buffer, <span class="keyword">sizeof</span>(buffer), <span class="string">&quot;PWD=%s&quot;</span>, tmp_buffer);</span><br><span class="line">        putenv(buffer);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">Echo</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">if</span> (g_argc == <span class="number">1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (g_argc == <span class="number">2</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">std</span>::<span class="built_in">string</span> echo = g_argv[<span class="number">1</span>];</span><br><span class="line">        <span class="keyword">if</span> (echo[<span class="number">0</span>] == <span class="string">&#x27;$&#x27;</span>)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (echo[<span class="number">1</span>] == <span class="string">&#x27;?&#x27;</span>)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>, g_status);</span><br><span class="line">                g_status = <span class="number">0</span>;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">std</span>::<span class="built_in">string</span> what = echo.substr(<span class="number">1</span>, echo.size() - <span class="number">1</span>);</span><br><span class="line">            <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; environ[i]; i++)</span><br><span class="line">            &#123;</span><br><span class="line">                <span class="built_in">std</span>::<span class="built_in">string</span> tmp = environ[i];</span><br><span class="line">                <span class="built_in">std</span>::<span class="built_in">string</span> prefix = tmp.substr(<span class="number">0</span>, tmp.find(<span class="string">&quot;=&quot;</span>));</span><br><span class="line">                <span class="keyword">if</span> (<span class="built_in">strcmp</span>(prefix.c_str(), what.c_str()) == <span class="number">0</span>)</span><br><span class="line">                &#123;</span><br><span class="line">                    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, getenv(what.c_str()));</span><br><span class="line">                    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">                    <span class="keyword">break</span>;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">            g_status = <span class="number">1</span>;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, g_argv[<span class="number">1</span>]);</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    g_status = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">ChecKAndExecuteBulitin</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">std</span>::<span class="built_in">string</span> cmd = g_argv[<span class="number">0</span>];</span><br><span class="line">    <span class="type">int</span> fd = <span class="number">-1</span>, back_up = <span class="number">-1</span>;</span><br><span class="line">    <span class="type">bool</span> redir_sucess = RedirOpenAndRcover(fd, back_up);</span><br><span class="line">    <span class="type">bool</span> is_builtin = <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span> (cmd == <span class="string">&quot;cd&quot;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        is_builtin = Cd();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (cmd == <span class="string">&quot;echo&quot;</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        is_builtin = Echo();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (redir_sucess)</span><br><span class="line">    &#123;</span><br><span class="line">        fflush(<span class="built_in">stdin</span>);</span><br><span class="line">        fflush(<span class="built_in">stdout</span>);</span><br><span class="line">        close(fd);</span><br><span class="line">        <span class="comment">// if(redir==INPUT_REDIR)</span></span><br><span class="line">        <span class="comment">//&#123;</span></span><br><span class="line">        <span class="comment">//     dup2(back_up,0);</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        <span class="comment">// else if(redir==OUTPUT_REDIR || redir== APPEND_REDIR)</span></span><br><span class="line">        <span class="comment">//&#123;</span></span><br><span class="line">        <span class="comment">//     dup2(back_up,1);</span></span><br><span class="line">        <span class="comment">// &#125;</span></span><br><span class="line">        dup2(back_up, redir == INPUT_REDIR ? <span class="number">0</span> : <span class="number">1</span>);</span><br><span class="line">        close(back_up);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (is_builtin)</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">bool</span> <span class="title function_">Execution</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="comment">// 执行命令</span></span><br><span class="line">    <span class="type">int</span> id = fork();</span><br><span class="line">    <span class="keyword">if</span> (id == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="type">int</span> fd = <span class="number">-1</span>;</span><br><span class="line">        <span class="keyword">if</span> (RedirOpen(fd))</span><br><span class="line">            close(fd);</span><br><span class="line">        execvp(g_argv[<span class="number">0</span>], g_argv);</span><br><span class="line">        perror(<span class="string">&quot;execvpe failed:&quot;</span>);</span><br><span class="line">        g_status = <span class="number">1</span>;</span><br><span class="line">        <span class="built_in">exit</span>(<span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="type">int</span> status = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> wait = waitpid(id, &amp;status, <span class="number">0</span>);</span><br><span class="line">    <span class="keyword">if</span> (wait == <span class="number">-1</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;wait failed:&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (WIFEXITED(status))</span><br><span class="line">    &#123;</span><br><span class="line">        g_status = WEXITSTATUS(status);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (WIFSIGNALED(status))</span><br><span class="line">    &#123;</span><br><span class="line">        g_status = WTERMSIG(status);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">test</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; g_argv[i]; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;g_argv[%d]:%s\n&quot;</span>, i, g_argv[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;g_argc:%d\n&quot;</span>, g_argc);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    InitEnv();</span><br><span class="line">    <span class="keyword">while</span> (<span class="literal">true</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="comment">// 输出命令行提示符</span></span><br><span class="line">        PrintCommandLine();</span><br><span class="line">        <span class="comment">// 获取输入命令</span></span><br><span class="line">        <span class="keyword">if</span> (!GetCmd())</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">// 检查重定向</span></span><br><span class="line">        <span class="keyword">if</span> (CheckRedir())</span><br><span class="line">            ;</span><br><span class="line">        <span class="comment">// 处理输入命令</span></span><br><span class="line">        <span class="keyword">if</span> (!CmdSlice())</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">// 检查并执行内建命令</span></span><br><span class="line">        <span class="keyword">if</span> (ChecKAndExecuteBulitin())</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">        <span class="comment">// 执行普通命令</span></span><br><span class="line">        <span class="keyword">if</span> (Execution())</span><br><span class="line">            <span class="keyword">continue</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>效果展示</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">wyf@hcss-ecs-0be3:~/code/myshell$ ./myshell </span><br><span class="line">[wyf@hcss-ecs-0be3 myshell]-_-<span class="built_in">ls</span></span><br><span class="line">makefile  myshell  myshell.cpp  myshell.o</span><br><span class="line">[wyf@hcss-ecs-0be3 myshell]-_-<span class="built_in">ls</span> -lin</span><br><span class="line">total 260</span><br><span class="line">804103 -rw-rw-r-- 1 1000 1000    362 Jul 14 23:21 makefile</span><br><span class="line">807122 -rwxrwxr-x 1 1000 1000 105240 Jul 15 00:04 myshell</span><br><span class="line">804105 -rw-rw-r-- 1 1000 1000  10050 Jul 14 23:32 myshell.cpp</span><br><span class="line">807121 -rw-rw-r-- 1 1000 1000 142024 Jul 15 00:04 myshell.o</span><br><span class="line">[wyf@hcss-ecs-0be3 myshell]-_-top</span><br><span class="line">top - 00:04:24 up 34 days,  4:32,  3 <span class="built_in">users</span>,  load average: 1.00, 1.00, 1.00</span><br><span class="line">Tasks: 150 total,   2 running, 148 sleeping,   0 stopped,   0 zombie</span><br><span class="line">%Cpu(s): 20.0 us, 35.0 sy,  0.0 ni, 45.0 <span class="built_in">id</span>,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st </span><br><span class="line">MiB Mem :   1775.4 total,    163.1 free,   1284.2 used,    484.4 buff/cache     </span><br><span class="line">MiB Swap:      0.0 total,      0.0 free,      0.0 used.    491.2 avail Mem </span><br><span class="line"></span><br><span class="line">    PID USER      PR  NI    VIRT    RES    SHR S  %CPU  %MEM     TIME+ COMMAND                                                                          </span><br><span class="line"> 227896 wyf       20   0    6380   1280   1152 R 100.0   0.1     4w+1d prcess_pool                                                                      </span><br><span class="line">1605632 wyf       20   0 1158712  77376  46592 S   9.1   4.3   0:04.80 node                                                                             </span><br><span class="line">      1 root      20   0   22580   9636   5616 S   0.0   0.5   1:06.56 systemd                                                                          </span><br><span class="line">      2 root      20   0       0      0      0 S   0.0   0.0   0:00.40 kthreadd                                                                         </span><br><span class="line">      3 root      20   0       0      0      0 S   0.0   0.0   0:00.00 pool_workqueue_release                                                           </span><br><span class="line">      4 root       0 -20       0      0      0 I   0.0   0.0   0:00.00 kworker/R-rcu_g                                                                  </span><br><span class="line">        ……                        </span><br><span class="line">[wyf@hcss-ecs-0be3 myshell]-_-<span class="built_in">pwd</span></span><br><span class="line">/home/wyf/code/myshell</span><br><span class="line">[wyf@hcss-ecs-0be3 myshell]-_-<span class="built_in">cd</span> ..</span><br><span class="line">[wyf@hcss-ecs-0be3 code]-_-<span class="built_in">cd</span> ..</span><br><span class="line">[wyf@hcss-ecs-0be3 wyf]-_-<span class="built_in">pwd</span></span><br><span class="line">/home/wyf</span><br><span class="line">[wyf@hcss-ecs-0be3 wyf]-_-<span class="built_in">echo</span> <span class="string">&quot;Hello&quot;</span></span><br><span class="line"><span class="string">&quot;Hello&quot;</span></span><br><span class="line">[wyf@hcss-ecs-0be3 wyf]-_-^C</span><br><span class="line"> 130 wyf@hcss-ecs-0be3:~/code/myshell$ </span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>初识进程-概念</title>
      <link href="/2025/11/22/%E5%88%9D%E8%AF%86%E8%BF%9B%E7%A8%8B-%E6%A6%82%E5%BF%B5/"/>
      <url>/2025/11/22/%E5%88%9D%E8%AF%86%E8%BF%9B%E7%A8%8B-%E6%A6%82%E5%BF%B5/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h2 id="进程概念"><a href="#进程概念" class="headerlink" title="进程概念"></a>进程概念</h2><h3 id="1-冯诺依曼体系结构"><a href="#1-冯诺依曼体系结构" class="headerlink" title="1. 冯诺依曼体系结构"></a>1. 冯诺依曼体系结构</h3><p>冯诺依曼体系结构(<code>Von Neumann Architecture</code>)由美籍匈牙利科学家<strong>约翰·冯·诺依曼</strong>在 <code>1945</code> 年提出。其核心思想是将<strong>程序指令和数据存储在同一存储器中</strong>，并通过同一总线传输。这一设计奠定了当代几乎所有通用计算机的基础</p><!-- ![1749126204602](image/进程概念/1749126204602.png) --><img src="/2025/11/22/%E5%88%9D%E8%AF%86%E8%BF%9B%E7%A8%8B-%E6%A6%82%E5%BF%B5/1749126204602.png" class=""><p><strong>核心五大组成部分</strong>：</p><ol><li><p><strong>中央处理器（CPU）</strong></p><ul><li><strong>运算器（ALU）</strong>：执行算术和逻辑运算</li><li><strong>控制器（CU）</strong>：从内存读取指令，解码并协调各部件工作</li></ul></li><li><p><strong>存储器（Memory）</strong></p><ul><li><strong>统一存储程序和数据</strong>：指令（程序）和操作数（数据）以二进制形式存放在同一内存中，按地址访问</li></ul></li><li><p><strong>输入设备（Input）</strong></p><ul><li>将程序和数据输入计算机（如键盘、鼠标）</li></ul></li><li><p><strong>输出设备（Output）</strong></p><ul><li>将处理结果呈现给用户（如显示器、打印机）</li></ul></li><li><p><strong>总线（Bus）</strong></p><ul><li><strong>数据&#x2F;地址&#x2F;控制总线</strong>：在部件间传输信息（指令、数据、控制信号）</li></ul></li></ol><p>注：</p><ul><li>这里的存储器指的是内存</li><li>不考虑缓存情况，这里的 <code>CPU</code> 能且只能对内存进行读写，不能访问外设(输入输出设备)</li><li>外设(输入输出设备)要输入输出数据，也只能和内存或从内存中读取</li></ul><p>下面我们用 <code>QQ</code> 聊天的过程，结合冯诺依曼体系，理解数据流动的过程<br>我们在进行 <code>点击QQ图标-&gt;输入账号登录-&gt;打开聊天窗口-&gt;输入消息&quot;你好!&quot;-&gt;点击发送</code> 这样的操作之后，在后台的数据流动过程：<br>下面我们用 <code>QQ</code> 聊天和发送文件的过程，结合<strong>冯诺依曼体系</strong>和<strong>网络通信原理</strong>，生动拆解数据流动的每一步（以 <code>Windows</code> 电脑为例）：</p><ol><li><p><strong>启动程序(冯诺依曼：CPU+存储器)</strong></p><ul><li>双击 <code>QQ</code> 图标 → <code>Windows</code> 从硬盘加载 <code>QQ</code> 程序到内存 → <code>CPU</code> 执行代码 → 登录界面显示</li></ul></li><li><p><strong>登录验证(网络I&#x2F;O)</strong></p><ul><li>输入账号密码 → <strong>键盘（输入设备）</strong> 生成电信号 → <code>CPU</code> 通过<strong>系统总线</strong>读取数据 → <code>QQ</code> 程序将账号密码按腾讯协议<strong>封装成数据包</strong></li><li>数据包通过<strong>网卡（输出设备）</strong> 发出 → 经路由器 → <strong>腾讯登录服务器</strong></li><li>服务器验证成功 → 返回”登录令牌”给 <code>QQ</code> 客户端 → <code>QQ</code> 主界面加载好友列表（数据从内存渲染到显卡）</li></ul></li><li><p><strong>发送消息（核心数据流）</strong></p><ul><li>输入”你好！” → 文字暂存于<strong>内存</strong>（聊天窗口编辑区）</li><li>点击发送 → <code>CPU</code> 执行发送指令：<ul><li><strong>步骤①：封装消息</strong></li><li><strong>步骤②：网络传输</strong>数据包 → <strong>操作系统网络栈</strong> → 经<strong>网卡</strong>发出 → 通过家庭路由器 → 互联网 → <strong>腾讯消息中转服务器</strong></li><li><strong>步骤③：服务器处理</strong><br>腾讯服务器解密校验 → 查询接收者 <code>IP</code> → 转发消息至<strong>好友的QQ客户端</strong>（若对方在线）</li></ul></li></ul></li><li><p><strong>好友接收消息（反向流程）</strong></p><ul><li>好友的<strong>网卡（输入设备）</strong> 收到数据包 → 传输给内存 → <code>QQ</code> 程序被操作系统唤醒 → <code>CPU</code> 解析数据包 → 解密文字 → 在聊天窗口渲染”你好！”</li><li><strong>界面更新</strong>：显卡将新消息画面输出到显示器（输出设备）</li></ul></li></ol><p>冯诺依曼架构中 <strong>CPU必须中介所有操作</strong>：</p><ul><li>键盘输入不能直连网卡，需 <code>CPU</code> 调度</li><li>文件不能从硬盘直发网络，需经内存组装</li><li>网络数据包必须由 <code>CPU</code> 解码才能显示</li></ul><h3 id="2-操作系统"><a href="#2-操作系统" class="headerlink" title="2. 操作系统"></a>2. 操作系统</h3><h4 id="2-1-概念"><a href="#2-1-概念" class="headerlink" title="2.1 概念"></a>2.1 概念</h4><p>任何计算机都包括一个基本的程序集合，称为操作系统(<code>Operator System</code>)。笼统的理解，操作系统包括：</p><ul><li>内核(进程管理、内存管理、文件管理、驱动管理)</li><li>其他程序(例如函数库、<code>Shell</code> 程序等等)</li></ul><h4 id="2-2-设计OS的目的"><a href="#2-2-设计OS的目的" class="headerlink" title="2.2 设计OS的目的"></a>2.2 设计OS的目的</h4><p>如果没有操作系统，想象你使用一台“裸机”：</p><ul><li>需手动分配内存地址才能启动 <code>QQ</code>；</li><li>发送文件要编写硬盘扇区读写代码；</li><li>打印机需自己设计信号时序</li></ul><p>操作系统的核心使命是：管理硬件资源，提供人机交互与程序运行环境</p><!-- ![1749169906605](image/进程概念/1749169906605.png) --><img src="/2025/11/22/%E5%88%9D%E8%AF%86%E8%BF%9B%E7%A8%8B-%E6%A6%82%E5%BF%B5/1749169906605.png" class=""><ul><li>对上，与硬件交互，管理所有的软硬件资源</li><li>对下，为用户程序(应用程序)提供一个良好的执行环境</li></ul><p>操作系统在整个计算机软硬件架构中，操作系统的定位是：<strong>一款纯正的”搞管理”的软件</strong></p><h4 id="2-3-设计哲学-—-先描述，再组织"><a href="#2-3-设计哲学-—-先描述，再组织" class="headerlink" title="2.3 设计哲学 — 先描述，再组织"></a>2.3 设计哲学 — 先描述，再组织</h4><p><strong>先描述，再组织</strong>其本质是 <strong>用数据结构抽象资源，再用算法组织调度</strong>。这一思想贯穿操作系统对<strong>进程、文件、设备、内存等所有资源的管理</strong></p><p><strong>什么是“先描述，再组织”？</strong></p><ul><li><strong>先描述（Describe）</strong>:<strong>用数据结构定义资源属性</strong>，将物理实体抽象为可操作的信息集合。<em>例如：进程不是“一段运行的代码”，而是包含状态、优先级、内存映射等属性的结构体</em></li><li><strong>再组织（Organize）</strong><br><strong>通过数据结构（链表、树、队列等）管理这些描述块</strong>，实现高效调度</li></ul><p>通过这样的组织方式最大的好处之一就是<strong>解耦物理与逻辑</strong>和<strong>实现策略与机制分离</strong>(当然，管理也更高效)</p><ul><li>硬件千差万别（不同型号 <code>CPU</code> &#x2F;硬盘），但通过统一描述（如 <code>PCB</code>、<code>inode</code>），操作系统<strong>屏蔽底层差异</strong>，向上提供一致接口</li><li>机制（<code>Mechanism</code>）：用数据结构组织资源（如用链表存 <code>PCB</code>）</li><li>策略（<code>Policy</code>）：调度算法决定谁先运行（如时间片轮转&#x2F;优先级调度）</li></ul><p>举个🌰，以图书馆管理书籍为例</p><p>原始图书馆（无“描述+组织”），所有书堆在大厅，管理员老王凭记忆找书，这样的缺点显然易见</p><ul><li>用户问：“《三体》在哪？” → 老王翻找半小时（<strong>检索效率O(n)</strong>）</li><li>新书入库？随意塞角落 → 半年后彻底消失（<strong>资源丢失</strong>）</li><li>两人借同一本书？冲突争吵（<strong>资源竞争</strong>）</li></ul><blockquote><p>❌ <strong>本质</strong>：资源无结构化描述，管理依赖人脑——如同裸机直接操作硬件</p></blockquote><p>这时拿出杀手锏”先描述，再组织”</p><p><strong>先描述—给每本书“发身份证”</strong><br>管理员给每本书添加<strong>元数据标签</strong>（描述）：</p><figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">《三体》的描述卡：</span><br><span class="line"><span class="bullet">-</span> 书名：三体  </span><br><span class="line"><span class="bullet">-</span> ISBN：9787536692930  </span><br><span class="line"><span class="bullet">-</span> 分类：科幻小说 → TF类  </span><br><span class="line"><span class="bullet">-</span> 位置：3F-A区-2排-5架  </span><br><span class="line"><span class="bullet">-</span> 状态：可借阅  </span><br></pre></td></tr></table></figure><p><strong>意义</strong>：</p><ol><li>解耦物理位置：书可移动，只需更新位置字段</li><li>精准定位：通过 <code>ISBN</code> 唯一标识</li></ol><p><strong>再组织—构建数据结构网络</strong><br><strong>1. 按分类组织：树形目录（文件系统）</strong></p><!-- ![1749300632266](image/进程概念/1749300632266.png) --><img src="/2025/11/22/%E5%88%9D%E8%AF%86%E8%BF%9B%E7%A8%8B-%E6%A6%82%E5%BF%B5/1749300632266.png" class=""><ul><li><strong>查找路径</strong>：科学 → 计算机 → 操作系统 → 目标书（<strong>路径解析</strong>）</li></ul><p><strong>2. 按状态组织：借阅队列（进程调度）</strong></p><table><thead><tr><th><strong>队列类型</strong></th></tr></thead><tbody><tr><td>可借阅队列</td></tr><tr><td>借出中队列</td></tr><tr><td>预约等待队列</td></tr></tbody></table><p>这样的处理方式为管理带来了很大的方便</p><p><strong>场景1：用户借阅《三体》</strong></p><ol><li><strong>查询</strong>：系统用 <code>ISBN</code> 在<strong>可借阅队列</strong>锁定位置</li><li><strong>状态更新</strong>：<ul><li>书状态 → “借出中”</li><li>用户借书证链表加入记录</li></ul></li><li><strong>冲突处理</strong>：若书已被借走 → 加入<strong>预约队列</strong></li></ol><p><strong>场景2：书籍盘点</strong></p><ul><li><strong>问题</strong>：书架有“幽灵书”（状态可借阅，实际丢失）</li><li><strong>解决</strong>：<ol><li>扫描所有物理书 → 生成实际书集 <strong>A</strong></li><li>比对系统记录书集 <strong>B</strong></li><li><strong>差集 B-A &#x3D; 需删除的记录</strong></li></ol></li></ul><p><strong>场景3：热门书籍调度</strong></p><ul><li>监测到《三体》月借阅量 &gt; 100次</li><li><strong>自动操作</strong>：<ol><li>从 <code>3F</code> 深库区移至 <code>1F</code> 热门区</li><li>复制3本副本 → 避免排队</li></ol></li></ul><p><strong>映射操作系统核心机制</strong></p><table><thead><tr><th><strong>图书馆操作</strong></th><th><strong>操作系统对应</strong></th><th><strong>底层思想</strong></th></tr></thead><tbody><tr><td>书籍元数据标签</td><td>文件控制块（<code>inode</code>&#x2F;<code>FCB</code>）</td><td><strong>描述资源属性</strong></td></tr><tr><td>分类树目录</td><td>文件系统目录树</td><td><strong>组织资源层次</strong></td></tr><tr><td>借阅状态队列</td><td>进程就绪&#x2F;阻塞队列</td><td><strong>动态调度依据</strong></td></tr><tr><td>热门书移至1楼</td><td>内存页面置换算法（<code>LRU</code>）</td><td><strong>局部性原理优化</strong></td></tr><tr><td><code>ISBN</code> 查书</td><td>虚拟地址→物理地址转换</td><td><strong>抽象定位资源</strong></td></tr></tbody></table><p>想象图书馆是计算机：</p><ul><li><strong>书籍&#x3D;硬件资源</strong>（<code>CPU</code> 时间&#x2F;内存&#x2F;磁盘）</li><li><strong>读者&#x3D;应用程序</strong>（需要资源完成任务）</li><li><strong>管理员&#x3D;操作系统</strong>（用描述+组织高效分配资源）</li></ul><h4 id="2-4-系统调用和库函数"><a href="#2-4-系统调用和库函数" class="headerlink" title="2.4 系统调用和库函数"></a>2.4 系统调用和库函数</h4><ul><li>在开发角度，操作系统会对外表现为一个整体，但是会暴露自己的部分接口，供上层开发使用，这部分<strong>由操作系统提供的接口，叫做系统调用</strong></li><li>系统调用在使用上，功能比较基础，对用户的要求也相对较高，所以，有心的开发者就可以<strong>对部分系统调用进行适度封装</strong>，从而形成了库，有了库，有很利于上层用户或开发者进行二次开发</li></ul><h3 id="3-进程"><a href="#3-进程" class="headerlink" title="3. 进程"></a>3. 进程</h3><h4 id="3-1-基本概念"><a href="#3-1-基本概念" class="headerlink" title="3.1 基本概念"></a>3.1 基本概念</h4><p>进程是操作系统进行资源分配和调度的<strong>基本单位</strong></p><h5 id="3-1-1-描述进程—PCB"><a href="#3-1-1-描述进程—PCB" class="headerlink" title="3.1.1 描述进程—PCB"></a>3.1.1 描述进程—PCB</h5><p><strong>基本概念</strong></p><ul><li>进程信息被放在一个叫做进程控制块的数据结构中，可以理解为进程属性的集合</li><li>这个集合被称为 <code>PCB(Process Control Block)</code>，<code>Linux</code> 系统下的PCB的：<code>task_struct</code></li></ul><p><strong>task_struct是PCB的一种</strong></p><ul><li>在 <code>Linux</code> 中描述进程的结构体叫做 <code>task_struct</code></li><li><code>task_struct</code> 是 <code>Linux</code> 内核的一种数据结构，它会被装在到 <code>RAM</code> (内存)里并包含着进程的信息</li></ul><h5 id="3-1-2-task-struct"><a href="#3-1-2-task-struct" class="headerlink" title="3.1.2 task_struct"></a>3.1.2 task_struct</h5><p><strong>内容分类</strong></p><ul><li>标识符：描述本进程的唯一标识符</li><li>状态：任务状态、退出代码、退出信号等</li><li>优先级：相对于其他进程的优先级</li><li>程序计数器：程序中即将被执行的下一条指令的地址</li><li>内存指针：包括程序代码和进程相关数据的指针，还有和其他进程共享的内存块的指针</li><li>上下文数据：进程执行时处理器的寄存器中的数据</li><li><code>I/O</code> 状态信息：包括显示的 <code>I/O</code> 请求，分配给进程的 <code>I/O</code> 设备和被进程使用的文件列表</li><li>记账信息：包括处理器的时间总和，使用的时钟数，时间限制，记账号等</li><li>其他信息</li></ul><h5 id="3-1-3-组织进程"><a href="#3-1-3-组织进程" class="headerlink" title="3.1.3 组织进程"></a>3.1.3 组织进程</h5><p>在 <code>Linux</code> 系统中，运行在系统中的进程都以 <code>task_struct</code> 链表的形式存储在内核里</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> *<span class="title">next</span>, *<span class="title">prev</span>;</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><!-- ![1749170125226](image/进程概念/1749170125226.png) --><img src="/2025/11/22/%E5%88%9D%E8%AF%86%E8%BF%9B%E7%A8%8B-%E6%A6%82%E5%BF%B5/1749170125226.png" class=""><h5 id="3-1-4-查看进程"><a href="#3-1-4-查看进程" class="headerlink" title="3.1.4 查看进程"></a>3.1.4 查看进程</h5><p><strong>进程的信息可以通过 <code>/proc</code> 系统文件夹查看</strong><br>   <!-- ![1749170829348](image/进程概念/1749170829348.png) --><br>   <img src="/2025/11/22/%E5%88%9D%E8%AF%86%E8%BF%9B%E7%A8%8B-%E6%A6%82%E5%BF%B5/1749170829348.png" class=""></p><p><strong><code>top</code> 和 <code>ps</code></strong><br><strong><code>ps</code> (Process Status):</strong> 提供<strong>静态的、瞬时的</strong>进程信息快照。你运行一次 <code>ps</code>，它就显示<em>那一刻</em>的进程状态</p><ul><li><strong>常用命令形式：</strong><ul><li><strong><code>ps aux</code>：</strong> 最常用组合之一<ul><li><code>a</code>： 显示终端上所有用户的进程（包括其他用户的）</li><li><code>u</code>： 以面向用户的格式显示（显示用户名、<code>CPU%</code>、<code>MEM%</code> 等）</li><li><code>x</code>： 显示没有控制终端的进程（通常是守护进程&#x2F;后台服务）</li><li><strong>输出列详解 (常见列)：</strong><ul><li><code>USER</code>: 进程所有者</li><li><code>PID</code>: 进程的唯一 <code>ID</code></li><li><code>%CPU</code>: 进程使用的 <code>CPU</code> 时间百分比</li><li><code>%MEM</code>: 进程使用的物理内存百分比</li><li><code>VSZ</code>: 虚拟内存大小 (<code>KiB</code>)</li><li><code>RSS</code>: 驻留集大小，即实际使用的、未被换出的物理内存大小 (<code>KiB</code>)</li><li><code>TTY</code>: 进程关联的终端。<code>?</code> 表示没有控制终端</li><li><code>STAT</code>: 进程状态码 (非常重要！见下文)</li><li><code>START</code>: 进程启动时间</li><li><code>TIME</code>: 进程累计使用的 <code>CPU</code> 时间 (分钟:秒)</li><li><code>COMMAND</code>: 启动进程的命令行</li></ul></li></ul></li></ul></li><li><strong>常用场景：</strong><ul><li>查找特定进程的 <code>PID</code>：<code>ps aux | grep nginx</code></li><li>查看进程的完整命令行：<code>ps -ef | grep java</code> 或 <code>ps auxww</code> (显示非常宽的 <code>COMMAND</code> 列)</li><li>查看进程树关系：<code>ps -ef --forest</code> 或 <code>ps auxf</code></li><li>查看特定用户的进程：<code>ps -u username</code></li><li>查看进程的环境变量：<code>ps e -p PID</code> (查看指定 <code>PID</code> 的环境变量)</li></ul></li></ul><p><strong><code>top</code> (Table of Processes):</strong> 提供<strong>动态的、实时的、交互式的</strong>进程信息视图。它像系统资源的仪表盘，会持续更新（默认每几秒刷新一次），让你看到进程状态和资源占用的变化</p><ul><li><strong><code>top</code> 界面：</strong><ol><li><strong>顶部系统摘要区：</strong><ul><li>第一行 (<code>top - ...</code>): 系统当前时间、运行时间、登录用户数、系统负载 (1分钟, 5分钟, 15分钟平均值)</li><li>第二行 (<code>Tasks:</code>): 总进程数、运行中 (<code>running</code>)、休眠中 (<code>sleeping</code>)、停止 (<code>stopped</code>)、僵尸 (<code>zombie</code>) 的数量</li><li>第三行 (<code>%Cpu(s):</code>): <strong>CPU 使用率详细分解</strong><ul><li><code>us</code>: 用户空间进程占用百分比</li><li><code>sy</code>: 内核空间 (系统) 进程占用百分比</li><li><code>ni</code>: 调整过优先级 (<code>nice</code>) 的用户进程占用百分比</li><li><code>id</code>: 空闲百分比</li><li><code>wa</code>: 等待 <code>I</code>&#x2F;<code>O</code> 完成的百分比 (高可能表示 <code>I</code>&#x2F;<code>O</code> 瓶颈)</li><li><code>hi</code>: 处理硬件中断的百分比</li><li><code>si</code>: 处理软件中断的百分比</li><li><code>st</code>: 被虚拟机偷走的时间百分比 (在虚拟机中运行时重要)</li></ul></li><li>第四行 (<code>KiB Mem:</code>): 物理内存使用情况 (总量、已用、空闲、缓冲区 <code>buffers</code>)</li><li>第五行 (<code>KiB Swap:</code>): 交换空间使用情况 (总量、已用、空闲、缓存 <code>cached</code>)</li></ul></li><li><strong>进程列表区：</strong> 列的含义与 <code>ps aux</code> 非常相似，默认包含：<ul><li><code>PID</code>, <code>USER</code>, <code>PR</code> (优先级), <code>NI</code> (<code>Nice</code> 值), <code>VIRT</code> (同 VSZ), <code>RES</code> (同 <code>RSS</code>), <code>SHR</code> (共享内存大小), <code>S</code> (状态), <code>%CPU</code>, <code>%MEM</code>, <code>TIME+</code> (累计 <code>CPU</code> 时间), <code>COMMAND</code></li></ul></li></ol></li><li><strong>常用交互命令 (在 <code>top</code> 运行时按)：</strong><ul><li><code>P</code> : 按 <code>%CPU</code> 使用率排序 <strong>(默认)</strong></li><li><code>M</code> : 按 <code>%MEM</code> (<code>RES</code>) 使用率排序</li><li><code>T</code> : 按 <code>TIME+</code> (累计 <code>CPU</code> 时间) 排序</li><li><code>N</code> : 按 <code>PID</code> 排序</li><li><code>k</code> : 杀死进程 (输入 <code>PID</code> 后按回车)</li><li><code>r</code> : 调整进程优先级 (<code>Renice</code>) (输入 <code>PID</code> 后输入新的 <code>Nice</code> 值)</li><li><code>1</code> : 切换显示所有 <code>CPU</code> 核心的使用情况 (汇总显示 <code>vs</code> 每个核心单独显示)</li><li><code>u</code> : 只显示指定用户的进程 (输入用户名)</li><li><code>f</code> &#x2F; <code>F</code> : 进入字段管理界面，可以添加、移除、排序显示的列</li><li><code>h</code> &#x2F; <code>?</code> : 显示帮助信息</li><li><code>s</code> : 改变刷新间隔 (秒)</li><li><code>q</code> : 退出 <code>top</code></li><li><code>W</code> : 将当前配置写入 <code>~/.toprc</code> 文件 (保存个性化设置)</li></ul></li></ul><!-- ![1749170929499](image/进程概念/1749170929499.png) --><img src="/2025/11/22/%E5%88%9D%E8%AF%86%E8%BF%9B%E7%A8%8B-%E6%A6%82%E5%BF%B5/1749170929499.png" class=""><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">while</span> :; <span class="keyword">do</span> ps ajx | <span class="built_in">head</span> -1 &amp;&amp; ps axj | grep <span class="string">&#x27;进程名&#x27;</span> | grep -v grep ; <span class="built_in">sleep</span> 1; <span class="keyword">done</span></span><br><span class="line"><span class="comment"># 监控进程小脚本</span></span><br></pre></td></tr></table></figure><h5 id="3-1-5-获取进程标识符"><a href="#3-1-5-获取进程标识符" class="headerlink" title="3.1.5 获取进程标识符"></a>3.1.5 获取进程标识符</h5><p>在操作系统中，<strong>每个进程都有一个独一无二的进程标识符(Process Identifier，PID)</strong>，它就像进程的”身份证号”</p><ul><li>进程 <code>id</code>(<code>PID</code>)</li><li>父进程 <code>id</code>(<code>PPID</code>)</li></ul><p><code>pid</code>&#x2F;<code>ppid</code>可以通过 <code>getpid</code> 和 <code>getppid</code> 函数调用获取</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">getpid</span><span class="params">(<span class="type">void</span>)</span>;</span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">getppid</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cat</span> main.c</span><br><span class="line"><span class="comment">#include&lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment">#include&lt;unistd.h&gt;</span></span><br><span class="line">int <span class="function"><span class="title">main</span></span>()</span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Pid:%d\n&quot;</span>,getpid());</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Ppid:%d\n&quot;</span>,getppid());</span><br><span class="line">    <span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br><span class="line">$ ./main</span><br><span class="line">Pid:1461527</span><br><span class="line">Ppid:1459442</span><br></pre></td></tr></table></figure><h5 id="3-1-6-创建进程—初识fork"><a href="#3-1-6-创建进程—初识fork" class="headerlink" title="3.1.6 创建进程—初识fork"></a>3.1.6 创建进程—初识fork</h5><p><code>fork()</code> 是 <code>Unix/Linux</code> 系统中最重要的系统调用之一，用于创建新进程，其特点是[ 一次调用，两次返回 ]</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="type">pid_t</span> <span class="title function_">fork</span><span class="params">(<span class="type">void</span>)</span>;</span><br></pre></td></tr></table></figure><p>📊 <strong>返回值</strong></p><table><thead><tr><th>返回值</th><th>含义</th><th>接收进程</th><th>典型处理</th></tr></thead><tbody><tr><td><code>&gt;0</code></td><td><strong>子进程的 PID</strong></td><td>父进程</td><td>记录子进程ID，用于后续管理</td></tr><tr><td><code>0</code></td><td><strong>标识当前是子进程</strong></td><td>子进程</td><td>执行子进程专属任务</td></tr><tr><td><code>&lt;0</code></td><td><strong>创建失败</strong></td><td>父进程</td><td>错误处理（内存不足&#x2F;进程数达上限等）</td></tr></tbody></table><p>当进程调用 <code>fork()</code> 时，操作系统会<strong>复制整个当前进程</strong>（包括代码、数据、堆栈、打开文件等），生成一个几乎完全相同的子进程</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#include&lt;stdio.h&gt;</span></span><br><span class="line"><span class="comment">#include&lt;unistd.h&gt;</span></span><br><span class="line"></span><br><span class="line">int <span class="function"><span class="title">main</span></span>()</span><br><span class="line">&#123;</span><br><span class="line">    int pid = fork();</span><br><span class="line">    <span class="keyword">if</span>(pid &lt; 0)</span><br><span class="line">    &#123;</span><br><span class="line">        fprintf(stderr,<span class="string">&quot;Fork error\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(pid == 0)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;I&#x27;m child process, my pid is:%d, ppid is:%d\n&quot;</span>,getpid(),getppid());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;I&#x27;m parent process, my pid is:%d\n&quot;</span>,getpid());</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>执行结果</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ ./main </span><br><span class="line">I<span class="string">&#x27;m parent process, my pid is:1465424</span></span><br><span class="line"><span class="string">I&#x27;</span>m child process, my pid is:1465425, ppid is:1465424 </span><br></pre></td></tr></table></figure><p><strong>执行流程</strong>：</p><ol><li>父进程执行 <code>fork()</code> 系统调用</li><li>内核创建子进程（复制父进程上下文）</li><li><strong>两个进程同时被调度执行</strong></li><li><strong>每个进程各获得一个返回值</strong>：<ul><li>父进程获得：<strong>子进程的 PID（&gt;0）</strong></li><li>子进程获得：<strong>0</strong></li></ul></li></ol><p><strong>执行结果给人一种 “一个变量同时满足两个判断”的错觉？</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> pid = fork();  <span class="comment">// 关键点在这！</span></span><br></pre></td></tr></table></figure><p>当执行到这一行时，系统分裂成两个进程：</p><ol><li><strong>父进程</strong>：<ul><li>获得子进程的真实 <code>PID</code>（正整数）</li><li>执行 <code>else</code> 分支（因为 <code>pid &gt; 0</code>）</li><li>输出：<code>I&#39;m parent process...</code></li></ul></li><li><strong>子进程</strong>：<ul><li>获得返回值 <code>0</code></li><li>执行 <code>else if (pid == 0)</code> 分支</li><li>输出：<code>I&#39;m child process...</code></li></ul></li></ol><p><strong>注意</strong>⚡</p><ol><li><strong>不是同一个变量</strong>：<ul><li>父子进程有各自独立的 <code>pid</code> 变量副本</li><li>父进程的 <code>pid</code> 存储子进程的真实 <code>ID</code></li><li>子进程的 <code>pid</code> 存储值 <code>0</code></li></ul></li><li><strong>不是同时执行</strong>：<ul><li>两个进程是并发执行，可能：<ul><li>父进程先运行</li><li>子进程先运行</li><li>交替运行（由内核调度器决定）</li></ul></li><li>输出顺序不固定</li></ul></li><li><strong>代码共享但数据独立</strong>：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 验证数据独立性</span></span><br><span class="line"><span class="type">int</span> counter = <span class="number">0</span>;</span><br><span class="line"><span class="type">pid_t</span> pid = fork();</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (pid == <span class="number">0</span>) &#123;</span><br><span class="line">    counter = <span class="number">100</span>;  <span class="comment">// 只修改子进程的counter</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Child counter: %d\n&quot;</span>, counter);</span><br><span class="line">&#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    sleep(<span class="number">1</span>);  <span class="comment">// 确保子进程先执行</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Parent counter: %d\n&quot;</span>, counter); <span class="comment">// 仍然是0</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></li><li><strong>注意</strong><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误理解：认为fork()返回两次值到同一个变量</span></span><br><span class="line"><span class="type">int</span> pid = fork(); <span class="comment">// 不是同时设置0和正数！</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确理解：</span></span><br><span class="line"><span class="comment">//   - 父进程上下文：pid = 子进程ID</span></span><br><span class="line"><span class="comment">//   - 子进程上下文：pid = 0</span></span><br></pre></td></tr></table></figure></li><li><strong>为什么有两个返回值？</strong><br>关键原因在于：<strong><code>fork()</code> 调用成功后，系统中会同时存在两个独立的进程（父进程和子进程），它们都从 <code>fork()</code> 返回点继续执行</strong>。类似于平行宇宙，<code>fork</code> 是个分叉机器</li></ol><h4 id="3-2-进程状态"><a href="#3-2-进程状态" class="headerlink" title="3.2 进程状态"></a>3.2 进程状态</h4><p>在 <code>kernel</code> 源代码中的定义</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">static</span> <span class="type">const</span> <span class="type">char</span> * <span class="type">const</span> task_state_array[] = &#123;</span><br><span class="line">    <span class="string">&quot;R (running)&quot;</span>,<span class="comment">/*   0 */</span></span><br><span class="line">    <span class="string">&quot;S (sleeping)&quot;</span>,<span class="comment">/*   1 */</span></span><br><span class="line">    <span class="string">&quot;D (disk sleep)&quot;</span>,<span class="comment">/*   2 */</span></span><br><span class="line">    <span class="string">&quot;T (stopped)&quot;</span>,<span class="comment">/*   4 */</span></span><br><span class="line">    <span class="string">&quot;t (tracing stop)&quot;</span>,<span class="comment">/*   8 */</span></span><br><span class="line">    <span class="string">&quot;Z (zombie)&quot;</span>,<span class="comment">/*  16 */</span></span><br><span class="line">    <span class="string">&quot;X (dead)&quot;</span>,<span class="comment">/*  32 */</span></span><br><span class="line">    <span class="string">&quot;x (dead)&quot;</span>,<span class="comment">/*  64 */</span></span><br><span class="line">    <span class="string">&quot;K (wakekill)&quot;</span>,<span class="comment">/* 128 */</span></span><br><span class="line">    <span class="string">&quot;W (waking)&quot;</span>,<span class="comment">/* 256 */</span></span><br><span class="line">    <span class="string">&quot;P (parked)&quot;</span>,<span class="comment">/* 512 */</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><table><thead><tr><th><strong>状态标识</strong></th><th><strong>状态名称</strong></th><th><strong>状态值</strong></th><th><strong>描述</strong></th></tr></thead><tbody><tr><td><strong>R (running)</strong></td><td>运行中</td><td>0</td><td>进程正在 <code>CPU</code> 执行或在运行队列中等待调度</td></tr><tr><td><strong>S (sleeping)</strong></td><td>可中断睡眠</td><td>1</td><td>进程等待事件（如 <code>I</code>&#x2F;<code>O</code> 完成），可被信号唤醒</td></tr><tr><td><strong>D (disk sleep)</strong></td><td>不可中断睡眠</td><td>2</td><td>进程等待磁盘 <code>I</code>&#x2F;<code>O</code> 完成，<strong>不响应任何信号</strong>（包括SIGKILL）</td></tr><tr><td><strong>T (stopped)</strong></td><td>暂停状态</td><td>4</td><td>进程被信号（<code>SIGSTOP</code>&#x2F;<code>SIGTSTP</code>）暂停执行</td></tr><tr><td><strong>t (tracing stop)</strong></td><td>跟踪暂停</td><td>8</td><td>进程被调试器（如 <code>gdb</code>）暂停，是特殊的停止状态</td></tr><tr><td><strong>Z (zombie)</strong></td><td>僵尸状态</td><td>16</td><td>进程已终止，但父进程尚未回收资源（<code>PCB</code> 未释放）</td></tr><tr><td><strong>X (dead)</strong></td><td>完全死亡</td><td>32</td><td>进程最终死亡状态（资源已回收），<strong>用户空间不可见</strong></td></tr><tr><td><strong>x (dead)</strong></td><td>扩展死亡状态</td><td>64</td><td>进程组死亡状态，用于进程组终止场景</td></tr><tr><td><strong>K (wakekill)</strong></td><td>唤醒终止</td><td>128</td><td>进程因致命信号（<code>SIGKILL</code>）被强制唤醒</td></tr><tr><td><strong>W (waking)</strong></td><td>唤醒中</td><td>256</td><td>进程正在被唤醒，准备投入运行</td></tr><tr><td><strong>P (parked)</strong></td><td>停放状态</td><td>512</td><td>内核线程专用状态，暂时移出调度队列</td></tr></tbody></table><!-- ![1749255713909](image/进程概念/1749255713909.png) --><img src="/2025/11/22/%E5%88%9D%E8%AF%86%E8%BF%9B%E7%A8%8B-%E6%A6%82%E5%BF%B5/1749255713909.png" class=""><p>看下面 <code>ps aux</code> 的输出👇</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">$ ps aux</span><br><span class="line">USER         PID %CPU %MEM    VSZ   RSS TTY      STAT START   TIME COMMAND</span><br><span class="line">root           1  0.0  0.5  22344 10440 ?        Ss   May05   1:06 /usr/lib/systemd/systemd --system --deserialize=20 noibrs</span><br><span class="line">root           3  0.0  0.0      0     0 ?        S    May05   0:00 [pool_workqueue_release]</span><br><span class="line">root           4  0.0  0.0      0     0 ?        I&lt;   May05   0:00 [kworker/R-rcu_g]</span><br><span class="line">root          15  0.0  0.0      0     0 ?        I    May05   0:00 [rcu_tasks_trace_kthread]</span><br><span class="line">root          35  0.0  0.0      0     0 ?        I&lt;   May05   0:00 [kworker/R-write]</span><br><span class="line">root          37  0.0  0.0      0     0 ?        SN   May05   0:00 [ksmd]</span><br><span class="line">message+     702  0.0  0.1   9996  2944 ?        Ss   May05   0:09 @dbus-daemon --system --address=systemd: --nofork --nopidfile --systemd-activatio</span><br><span class="line">root         718  0.0  0.2  18104  4352 ?        Ss   May05   0:04 /usr/lib/systemd/systemd-logind</span><br><span class="line">root         734  0.0  0.3 333748  6784 ?        Ssl  May05   0:12 /usr/sbin/NetworkManager --no-daemon</span><br><span class="line">root         737  0.0  0.0  17376  1664 ?        Ss   May05   0:11 /usr/sbin/wpa_supplicant -u -s -O DIR=/run/wpa_supplicant GROUP=netdev</span><br><span class="line">root        1140  0.0  0.0   5720   256 ttyS0    Ss+  May05   0:00 /sbin/agetty -o -p -- \u --keep-baud 115200,57600,38400,9600 - vt220</span><br><span class="line">root        1148  0.0  0.0   6104   256 tty1     Ss+  May05   0:00 /sbin/agetty -o -p -- \u --noclear - linux</span><br><span class="line">root        1472  0.0  0.0      0     0 ?        I&lt;   May05   0:00 [kworker/R-tls-s]</span><br><span class="line">root       47804  0.0  3.7 124188 67292 ?        S&lt;s  May06   2:04 /usr/lib/systemd/systemd-journald</span><br><span class="line">root     1496109  0.0  0.4  14972  8360 ?        Ss   08:16   0:00 sshd: wyf [priv]</span><br><span class="line">root     1496112  0.0  0.0      0     0 ?        S    08:16   0:00 [psimon]</span><br><span class="line">wyf      1496114  0.0  0.6  20224 11264 ?        Ss   08:16   0:00 /usr/lib/systemd/systemd --user</span><br><span class="line">wyf      1496206  0.0  0.3  15132  7096 ?        S    08:16   0:00 sshd: wyf@pts/0</span><br><span class="line">wyf      1496207  0.0  0.3   8768  5504 pts/0    Ss   08:16   0:00 -bash</span><br><span class="line">wyf      1496444  0.0  0.2  10884  4480 pts/0    R+   08:24   0:00 ps aux</span><br></pre></td></tr></table></figure><table><thead><tr><th>符号</th><th>状态</th><th>含义</th></tr></thead><tbody><tr><td><strong>R</strong></td><td>运行中</td><td>进程正在运行或就绪（在运行队列中）</td></tr><tr><td><strong>S</strong></td><td>可中断睡眠</td><td>等待事件完成（如 <code>I</code>&#x2F;<code>O</code> 操作），可被信号唤醒</td></tr><tr><td><strong>D</strong></td><td>不可中断睡眠</td><td>等待磁盘 <code>I</code>&#x2F;<code>O</code>，<strong>不响应任何信号</strong>（<code>kill -9</code> 无效）</td></tr><tr><td><strong>I</strong></td><td>空闲内核线程</td><td><strong>新增状态</strong>，表示内核线程处于空闲状态（<code>Linux 4.0+</code> 引入）</td></tr><tr><td><strong>Z</strong></td><td>僵尸进程</td><td>进程已终止但资源未回收</td></tr><tr><td><strong>T</strong></td><td>暂停状态</td><td>被信号（<code>SIGSTOP</code>）暂停</td></tr><tr><td><strong>t</strong></td><td>跟踪暂停</td><td>被调试器暂停</td></tr><tr><td><strong>&lt;</strong></td><td>高优先级</td><td>进程优先级高（<code>nice</code> 值 &lt; 0）</td></tr><tr><td><strong>N</strong></td><td>低优先级</td><td>进程优先级低（<code>nice</code> 值 &gt; 0）</td></tr><tr><td><strong>s</strong></td><td>会话领导者</td><td>进程是会话的首进程（如 <code>shell</code>）</td></tr><tr><td><strong>l</strong></td><td>多线程</td><td>进程包含多个线程（小写 <code>L</code>）</td></tr><tr><td><strong>+</strong></td><td>前台进程</td><td>进程属于前台进程组（与终端关联）</td></tr></tbody></table><ol><li><strong><code>I</code> 状态（空闲内核线程）</strong></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root           4  0.0  0.0      0     0 ?        I&lt;   May05   0:00 [kworker/R-rcu_g]</span><br><span class="line">root          13  0.0  0.0      0     0 ?        I    May05   0:00 [rcu_tasks_kthread]</span><br></pre></td></tr></table></figure><ul><li><strong>I</strong>：内核线程的空闲状态（<code>Linux 4.0+</code> 新增）</li><li><strong>特点</strong>：<ul><li>不消耗 CPU 资源</li><li>可随时被内核唤醒处理任务</li><li>仅出现在内核线程（方括号内的进程名）</li></ul></li></ul><ol start="2"><li><strong><code>&lt;</code> 符号（高优先级）</strong></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">root           4  0.0  0.0      0     0 ?        I&lt;   May05   0:00 [kworker/R-rcu_g]</span><br><span class="line">root          55  0.0  0.0      0     0 ?        I&lt;   May05   0:07 [kworker/0:1H-kblockd]</span><br></pre></td></tr></table></figure><ul><li><strong>&lt;</strong>：高优先级进程（nice 值 &lt; 0）</li></ul><ol start="3"><li><strong><code>+</code> 符号（前台进程）</strong></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">wyf      1496444  0.0  0.2  10884  4480 pts/0    R+   08:24   0:00 ps aux</span><br></pre></td></tr></table></figure><ul><li><strong>+</strong>：进程属于<strong>前台进程组</strong></li><li><strong>特点</strong>：<ul><li>可接收终端信号（如 <code>Ctrl+C</code> 发送 <code>SIGINT</code>）</li><li>与终端关联的交互式进程</li><li>示例：<code>ps aux</code> 在终端前台运行</li></ul></li></ul><ol start="4"><li><strong>组合状态</strong></li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">root           1  0.0  0.5  22344 10440 ?        Ss   May05   1:06 /usr/lib/systemd/systemd</span><br></pre></td></tr></table></figure><ul><li><strong>Ss</strong>：<ul><li><code>S</code>：可中断睡眠（等待事件）</li><li><code>s</code>：会话领导者（所有进程的祖先）</li></ul></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">syslog     47852  0.0  0.2 222508  5376 ?        Ssl  May06   0:23 /usr/sbin/rsyslogd</span><br></pre></td></tr></table></figure><ul><li><strong>Ssl</strong>：<ul><li><code>S</code>：可中断睡眠</li><li><code>s</code>：会话领导者</li><li><code>l</code>：多线程</li></ul></li></ul><p><strong>补充—孤儿进程</strong><br><strong>孤儿进程（Orphan Process）</strong> 是指其<strong>父进程已经终止（退出）</strong>，但自身仍在运行的子进程。当一个进程变成孤儿时，操作系统会将其<strong>托管给一个特殊的父进程（通常是 <code>init</code> 或 <code>systemd</code>，进程 ID 为 1）</strong>，由这个新父进程负责后续的管理和资源回收</p><ul><li><strong>与僵尸进程的区别</strong>：| <strong>孤儿进程</strong>             | <strong>僵尸进程</strong>                         |<br>| —————————— | —————————————— |<br>| 父进程已终止，子进程仍在运行   | 子进程已终止，但父进程未调用 <code>wait()</code>    |<br>| 由 <code>init</code> 接管并负责回收资源 | 占用进程表项，需父进程处理或 <code>init</code> 接管 |<br>| <strong>无资源泄漏风险</strong>       | 可能导致资源泄漏（如 <code>PID</code> 耗尽）            |</li></ul><p><strong>创建僵尸进程</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// zombie.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pid_t</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span>(pid &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;Fork error&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(pid == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Child[%d] is going to turn into Zombie\n&quot;</span>,getpid());</span><br><span class="line">        sleep(<span class="number">5</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Parent[%d] is sleeping...\n&quot;</span>,getpid());</span><br><span class="line">        sleep(<span class="number">30</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行结果</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ ./zombie </span><br><span class="line">Parent[1503955] is sleeping...</span><br><span class="line">Child[1503956] is going to turn into Zombie</span><br><span class="line">$ </span><br></pre></td></tr></table></figure><p><strong>监控进程状态</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="keyword">while</span> :; <span class="keyword">do</span> ps ajx | <span class="built_in">head</span> -1 &amp;&amp; ps axj | grep <span class="string">&#x27;zombie&#x27;</span> | grep -v grep ; <span class="built_in">sleep</span> 1; <span class="keyword">done</span></span><br><span class="line">   PPID     PID    PGID     SID TTY        TPGID STAT   UID   TIME COMMAND</span><br><span class="line">1499202 1500253 1500253 1499202 pts/1    1500253 S+    1000   0:00 ./zombie</span><br><span class="line">1500253 1500254 1500253 1499202 pts/1    1500253 S+    1000   0:00 ./zombie</span><br><span class="line">……</span><br><span class="line">   PPID     PID    PGID     SID TTY        TPGID STAT   UID   TIME COMMAND</span><br><span class="line">1499202 1500253 1500253 1499202 pts/1    1500253 S+    1000   0:00 ./zombie</span><br><span class="line">1500253 1500254 1500253 1499202 pts/1    1500253 Z+    1000   0:00 [zombie] &lt;defunct&gt;</span><br><span class="line">……</span><br><span class="line">   PPID     PID    PGID     SID TTY        TPGID STAT   UID   TIME COMMAND</span><br><span class="line">1499202 1500253 1500253 1499202 pts/1    1500253 S+    1000   0:00 ./zombie</span><br><span class="line">1500253 1500254 1500253 1499202 pts/1    1500253 Z+    1000   0:00 [zombie] &lt;defunct&gt;</span><br></pre></td></tr></table></figure><!-- ![1749262895599](image/进程概念/1749262895599.png) --><img src="/2025/11/22/%E5%88%9D%E8%AF%86%E8%BF%9B%E7%A8%8B-%E6%A6%82%E5%BF%B5/1749262895599.png" class=""><p><strong>创建孤儿进程</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//orphan.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/wait.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">pid_t</span> child_pid = fork();</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> (child_pid &lt; <span class="number">0</span>) &#123;</span><br><span class="line">        perror(<span class="string">&quot;Fork error&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">  </span><br><span class="line">    <span class="keyword">if</span> (child_pid &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Parent PID: %d\n&quot;</span>, getpid());</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Created child with PID: %d\n&quot;</span>, child_pid);</span><br><span class="line">        <span class="comment">// 父进程立即退出，使子进程成为孤儿</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Parent exiting...\n&quot;</span>);</span><br><span class="line">        <span class="built_in">exit</span>(EXIT_SUCCESS);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        sleep(<span class="number">2</span>);  <span class="comment">// 确保父进程先退出</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\nChild process became orphan:\n&quot;</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;  PID: %d\n&quot;</span>, getpid());</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;  PPID: %d (now init/systemd)\n&quot;</span>, getppid());</span><br><span class="line">        <span class="comment">// 模拟孤儿进程继续工作</span></span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Orphan process continues running...\n&quot;</span>);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">5</span>; i &gt; <span class="number">0</span>; i--) &#123;</span><br><span class="line">            <span class="built_in">printf</span>(<span class="string">&quot;Countdown: %d\n&quot;</span>, i);</span><br><span class="line">            sleep(<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Orphan process exiting\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行结果</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">$ ./orphan </span><br><span class="line">Parent PID: 1503593</span><br><span class="line">Created child with PID: 1503594</span><br><span class="line">Parent exiting...</span><br><span class="line">$ <span class="comment"># ？ 父进程退出会让shell认为进程结束，所以会打印一次提示符</span></span><br><span class="line">Child process became orphan:</span><br><span class="line">  PID: 1503594</span><br><span class="line">  PPID: 1 (now init/systemd)</span><br><span class="line">Orphan process continues running...</span><br><span class="line">Countdown: 5</span><br><span class="line">Countdown: 4</span><br><span class="line">Countdown: 3</span><br><span class="line">Countdown: 2</span><br><span class="line">Countdown: 1</span><br><span class="line">Orphan process exiting</span><br><span class="line">$ </span><br></pre></td></tr></table></figure><p><strong>监控进程状态</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="keyword">while</span> :; <span class="keyword">do</span> ps ajx | <span class="built_in">head</span> -1 &amp;&amp; ps axj | grep <span class="string">&#x27;orphan&#x27;</span> | grep -v grep ; <span class="built_in">sleep</span> 1; <span class="keyword">done</span></span><br><span class="line">   PPID     PID    PGID     SID TTY        TPGID STAT   UID   TIME COMMAND</span><br><span class="line">      1 1503594 1503593 1499202 pts/1    1499202 S     1000   0:00 ./orphan</span><br><span class="line">   PPID     PID    PGID     SID TTY        TPGID STAT   UID   TIME COMMAND</span><br><span class="line">      1 1503594 1503593 1499202 pts/1    1499202 S     1000   0:00 ./orphan</span><br><span class="line">   PPID     PID    PGID     SID TTY        TPGID STAT   UID   TIME COMMAND</span><br><span class="line">      1 1503594 1503593 1499202 pts/1    1499202 S     1000   0:00 ./orphan</span><br><span class="line">   PPID     PID    PGID     SID TTY        TPGID STAT   UID   TIME COMMAND</span><br><span class="line">      1 1503594 1503593 1499202 pts/1    1499202 S     1000   0:00 ./orphan</span><br><span class="line">   PPID     PID    PGID     SID TTY        TPGID STAT   UID   TIME COMMAND</span><br><span class="line">      1 1503594 1503593 1499202 pts/1    1499202 S     1000   0:00 ./orphan</span><br><span class="line">   PPID     PID    PGID     SID TTY        TPGID STAT   UID   TIME COMMAND</span><br><span class="line">      1 1503594 1503593 1499202 pts/1    1499202 S     1000   0:00 ./orphan</span><br><span class="line">   PPID     PID    PGID     SID TTY        TPGID STAT   UID   TIME COMMAND</span><br><span class="line">      1 1503594 1503593 1499202 pts/1    1499202 S     1000   0:00 ./orphan</span><br></pre></td></tr></table></figure><!-- ![1749262965332](image/进程概念/1749262965332.png) --><img src="/2025/11/22/%E5%88%9D%E8%AF%86%E8%BF%9B%E7%A8%8B-%E6%A6%82%E5%BF%B5/1749262965332.png" class=""><p>打印一次提示符👇</p><!-- ![1749264166542](image/进程概念/1749264166542.png) --><img src="/2025/11/22/%E5%88%9D%E8%AF%86%E8%BF%9B%E7%A8%8B-%E6%A6%82%E5%BF%B5/1749264166542.png" class=""><h4 id="3-3-进程优先级"><a href="#3-3-进程优先级" class="headerlink" title="3.3 进程优先级"></a>3.3 进程优先级</h4><h5 id="3-3-1-基本概念"><a href="#3-3-1-基本概念" class="headerlink" title="3.3.1 基本概念"></a>3.3.1 基本概念</h5><ul><li><code>CPU</code> 资源分配的先后顺序，就是指进程的优先级</li><li>优先级高的进程有优先执行的权利。配置进程优先级在多任务环境的 <code>Linux</code> 很有用，可以改善系统的性能</li><li>还可以将进程运行到指定 <code>CPU</code> 上，这样一来，把不重要的进程安排到某个 <code>CPU</code> 上，可以大大的改善系统整体性能</li><li>竞争性：系统进程数目众多，而 <code>CPU</code> 资源少，甚至只有一个，所以进程之间是具有竞争属性的。为了高效完成任务，更合理的竞争资源，便具有了优先级</li><li>独立性：多进程运行，需要独享各种资源，多进程运行期间互不干扰</li><li>并行 (<code>Parallelism</code>)；多个任务<strong>真正同时执行</strong>，需要多核&#x2F;多处理器硬件支持</li><li>并发 (<code>Concurrency</code>)：多个任务在重叠的时间段内执行（但不一定是同时执行），通过<strong>快速切换</strong>任务创造”同时进行”的错觉（单核也能实现）</li></ul><h5 id="3-3-2-查看系统进程"><a href="#3-3-2-查看系统进程" class="headerlink" title="3.3.2 查看系统进程"></a>3.3.2 查看系统进程</h5><p><code>ps -l</code> 输出内容</p><!-- ![1749201965694](image/进程概念/1749201965694.png) --><img src="/2025/11/22/%E5%88%9D%E8%AF%86%E8%BF%9B%E7%A8%8B-%E6%A6%82%E5%BF%B5/1749201965694.png" class=""><p>其中</p><ul><li><code>UID</code>：代表执行者的身份</li><li><code>PID</code>：进程 <code>ID</code></li><li><code>PPID</code>：父进程 <code>ID</code></li><li><code>PRI</code>：该进程的可被执行的优先级，越小优先级越高</li><li><code>NI</code>：进程的 <code>nice</code> 值</li></ul><h5 id="3-3-2-PRI和NI"><a href="#3-3-2-PRI和NI" class="headerlink" title="3.3.2 PRI和NI"></a>3.3.2 PRI和NI</h5><ul><li><code>PRI</code> 就是进程的优先级，也就是进程被 <code>CPU</code> 执行的先后顺序</li><li><code>NI</code> 也叫 <code>nice</code> 值，其表示进程可以被执行的优先级的修正数值</li><li><code>PRI(new) = PRI(old) + nice</code></li><li>当 <code>nice</code> 值为负值的时候，那么该进程的优先级会变小，其优先级会变高，也就越快被执行</li><li>因此，在 <code>Linux</code> 下，调整进程优先级，就是调整进程 <code>nice</code> 值</li><li><code>nice</code> 取值范围是 <code>-20~19</code>，一共 <code>40</code> 个级别</li><li>注意：进程 <code>nice</code> 值并不是进程的优先级，而是进程优先级的一个修正数据</li></ul><ol><li><strong><code>nice</code> 命令：</strong><ul><li><p><strong>用途：</strong> <strong>启动</strong>一个新进程，并为其指定一个初始的 <code>nice</code> 值（不同于默认的 0）</p></li><li><p><strong>语法：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">nice</span> [-n N] <span class="built_in">command</span> [arguments]</span><br></pre></td></tr></table></figure><ul><li><code>-n N</code>：指定一个 <strong>增量</strong> N。新的 <code>nice</code> 值 &#x3D; 当前 <code>shell</code> 的 <code>nice</code> 值 + <code>N</code></li><li><code>N</code> 的范围通常是 <code>-20</code> 到 <code>19</code>。如果省略 <code>-n</code>，默认增量是 <code>10</code>（即启动一个 <code>nice</code> 值为 <code>当前值+10</code> 的低优先级进程）</li></ul></li><li><p><strong>示例：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">nice</span> -n 10 ./cpu_intensive_job.sh  <span class="comment"># 启动一个低优先级(+10)的任务</span></span><br><span class="line"><span class="built_in">nice</span> -n -5 ./critical_task        <span class="comment"># (需要root) 启动一个较高优先级(-5)的任务</span></span><br></pre></td></tr></table></figure></li></ul></li><li><strong><code>renice</code> 命令：</strong><ul><li><p><strong>用途：</strong> <strong>修改</strong>一个或多个<strong>已经在运行</strong>的进程的 <code>nice</code> 值</p></li><li><p><strong>语法：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">renice [-n] N [-g|-p|-u] ID ...</span><br></pre></td></tr></table></figure><ul><li><code>-n N</code>：直接指定<strong>新的绝对 <code>nice</code> 值</strong> <code>N</code>（范围 <code>-20</code> 到 <code>19</code>）</li><li>指定目标方式：<ul><li><code>-g GID</code>：修改属于指定<strong>组 <code>ID</code> (<code>GID</code>)</strong> 的所有进程</li><li><code>-p PID</code>：修改指定<strong>进程 <code>ID</code> (<code>PID</code>)</strong> 的进程（这是默认方式）</li><li><code>-u USER</code>：修改属于指定**用户名或 <code>UID</code>**的所有进程</li></ul></li><li><code>ID ...</code>：一个或多个 <code>GID</code>、<code>PID</code> 或 <code>USER</code></li></ul></li><li><p><strong>示例：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">renice -n 5 1234               <span class="comment"># 将PID 1234的nice值改为5</span></span><br><span class="line">renice -n -10 -u apache        <span class="comment"># (需要root) 将所有属于用户&#x27;apache&#x27;的进程优先级提到最高(-10)</span></span><br><span class="line">renice -n 15 -g developers     <span class="comment"># (需要root) 将所有属于组&#x27;developers&#x27;的进程优先级降到最低(+15)</span></span><br></pre></td></tr></table></figure></li></ul></li></ol><p><strong>底层系统调用</strong><br>命令 <code>nice</code> 和 <code>renice</code> 最终是通过 <code>Linux</code> 内核提供的系统调用来实现功能的。主要涉及两个系统调用：</p><ol><li><strong><code>setpriority(int which, id_t who, int prio)</code>：</strong><ul><li><strong>功能：</strong> 设置进程、进程组或用户的 <code>nice</code> 值。这是 <code>renice</code> 命令的核心实现方式，功能最强大</li><li><strong>参数：</strong><ul><li><code>which</code>：指定 <code>who</code> 参数的含义。取值：<ul><li><code>PRIO_PROCESS</code>：<code>who</code> 是进程 <code>ID</code> (<code>PID</code>)。设置单个进程</li><li><code>PRIO_PGRP</code>：<code>who</code> 是进程组 <code>ID</code> (<code>PGID</code>)。设置整个进程组</li><li><code>PRIO_USER</code>：<code>who</code> 是用户 <code>ID</code> (<code>UID</code>)。设置属于该用户的所有进程</li></ul></li><li><code>who</code>：与 <code>which</code> 对应的 <code>ID</code>。如果 <code>who</code> 为 <code>0</code>，表示当前进程、当前进程组或当前用户（取决于 <code>which</code>）</li><li><code>prio</code>：要设置的<strong>新的 <code>nice</code> 值</strong>（范围 <code>-20</code> 到 <code>19</code>）</li></ul></li><li><strong>返回值：</strong> 成功返回 <code>0</code>，失败返回 <code>-1</code> 并设置 <code>errno</code>（常见错误：<code>EPERM</code> 权限不足，<code>EINVAL</code> 无效参数，<code>ESRCH</code> 找不到目标）</li><li><strong>权限要求：</strong> 与 <code>renice</code> 命令相同。非特权用户只能增加 <code>nice</code> 值（降低优先级）</li></ul></li><li><strong><code>nice(int inc)</code>：</strong><ul><li><strong>功能：</strong> <strong>增加</strong>当前调用进程的 <code>nice</code> 值。<code>nice()</code> 只能修改<strong>当前进程</strong>的优先级，并且只能<strong>增加</strong> <code>nice</code> 值（降低优先级）</li><li><strong>参数：</strong><ul><li><code>inc</code>：要<strong>增加</strong>的 <code>nice</code> 值增量。例如，<code>inc = 5</code> 会让当前进程的 <code>nice</code> 值增加 <code>5</code>（优先级降低）</li></ul></li><li><strong>返回值：</strong> 成功时返回<strong>新的 <code>nice</code> 值</strong>（范围 <code>-20</code> 到 <code>19</code>）。失败时返回 <code>-1</code> 并设置 <code>errno</code>（常见错误：<code>EPERM</code> 尝试增加负数 <code>inc</code> 以提高优先级但没有权限）</li><li><strong>权限要求：</strong> 非特权用户只能传递 <code>inc &gt;= 0</code>。特权用户可以传递任意 <code>inc</code>（包括负数），但新 <code>nice</code> 值仍必须在 <code>-20</code> 到 <code>19</code> 范围内</li><li><strong>与 <code>setpriority()</code> 的关系：</strong> <code>nice(inc)</code> 本质上等价于：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> newprio = getpriority(PRIO_PROCESS, <span class="number">0</span>) + inc;</span><br><span class="line">setpriority(PRIO_PROCESS, <span class="number">0</span>, newprio);</span><br><span class="line"><span class="keyword">return</span> newprio; <span class="comment">// (实际实现有原子性和错误处理差异)</span></span><br></pre></td></tr></table></figure><code>getpriority()</code> 系统调用用于获取 <code>nice</code> 值</li></ul></li></ol><p><strong>总结</strong></p><ul><li><strong><code>nice</code>：</strong> 用于<strong>启动</strong>一个具有特定初始 <code>nice</code> 值的新进程</li><li><strong><code>renice</code>：</strong> 用于<strong>修改</strong>已运行进程的 <code>nice</code> 值（按 <code>PID</code>, <code>PGID</code> 或 <code>UID</code>）</li><li><strong><code>setpriority()</code>：</strong> 核心系统调用，实现 <code>renice</code> 的功能，可以按进程、进程组或用户设置 <code>nice</code> 值</li><li><strong><code>nice()</code>：</strong> 较老的系统调用，只能增加当前进程的 <code>nice</code> 值（降低其优先级）。功能是 <code>setpriority()</code> 的子集</li></ul><h4 id="3-4-进程切换"><a href="#3-4-进程切换" class="headerlink" title="3.4 进程切换"></a>3.4 进程切换</h4><p>进程切换（<code>Process Switching</code>），也称为上下文切换（<code>Context Switch</code>），是操作系统在多任务环境中实现<strong>并发执行</strong>的核心机制。当操作系统决定暂停当前运行的进程并开始执行另一个进程时，就会发生进程切换</p><p>实际含义就是任务切换，或者 <code>CPU</code> 寄存器切换。当多任务内核决定运行另外的任务时，它保存正在运行的当前状态，也就是 <code>CPU</code> 寄存器中的全部内容。这些内容被保存在任务自己的堆栈中，入栈工作完成后把下一个要运行的任务的当前状况从该任务的栈中重新装入 <code>CPU</code> 寄存器，并开始下一个任务的运行，这个一过程就是 <code>Context Switch</code></p><!-- ![1749210243601](image/进程概念/1749210243601.png) --><img src="/2025/11/22/%E5%88%9D%E8%AF%86%E8%BF%9B%E7%A8%8B-%E6%A6%82%E5%BF%B5/1749210243601.png" class=""><!-- ![1749211604064](image/进程概念/1749211604064.png) --><img src="/2025/11/22/%E5%88%9D%E8%AF%86%E8%BF%9B%E7%A8%8B-%E6%A6%82%E5%BF%B5/1749211604064.png" class=""><blockquote><p>时间片：当代计算机都是分时操作系统，每个进程都有它适合的时间片(其实就是一个计数器)。时间片到达，进程就被操作系统从CPU上剥离下来</p></blockquote><!-- ![1749266599423](image/进程概念/1749266599423.png) --><img src="/2025/11/22/%E5%88%9D%E8%AF%86%E8%BF%9B%E7%A8%8B-%E6%A6%82%E5%BF%B5/1749266599423.png" class=""><h5 id="3-4-1-内核调度队列"><a href="#3-4-1-内核调度队列" class="headerlink" title="3.4.1 内核调度队列"></a>3.4.1 内核调度队列</h5><!-- ![1749266699139](image/进程概念/1749266699139.png) --><img src="/2025/11/22/%E5%88%9D%E8%AF%86%E8%BF%9B%E7%A8%8B-%E6%A6%82%E5%BF%B5/1749266699139.png" class=""><h5 id="3-4-2-runqueue"><a href="#3-4-2-runqueue" class="headerlink" title="3.4.2 runqueue"></a>3.4.2 runqueue</h5><p><code>runqueue</code>（运行队列）是操作系统中的核心数据结构，主要用于管理所有可运行的任务（进程或线程），实现负载均衡，在 <code>Linux</code> 内核中定义为 <code>struct rq</code>(不同版本稍有区别)</p><h5 id="3-4-3-优先级"><a href="#3-4-3-优先级" class="headerlink" title="3.4.3 优先级"></a>3.4.3 优先级</h5><ul><li>普通优先级(数值越大优先级越低) <code>100~139</code><ul><li>适合于桌面&#x2F;服务器应用</li></ul></li><li>实时优先级(数值越大优先级越高) <code>1~99</code><ul><li>适合于工业控制&#x2F;音视频处理</li></ul></li></ul><h5 id="3-4-4-活动队列-active-queue"><a href="#3-4-4-活动队列-active-queue" class="headerlink" title="3.4.4 活动队列 active queue"></a>3.4.4 活动队列 active queue</h5><ul><li>时间片还没有结束的所有进程都按照优先级放在活动队列中</li><li><code>nr_active</code>：总共有多少个运行状态的进程</li><li><code>queue[140]</code>：一个元素就是一个进程队列，相同优先级的进程按照 <code>FIFO</code> 规则进行排队调度，可以理解为数组下标就是优先级</li><li>在该结构中选取进程<ol><li>从 <code>0</code> 下标开始遍历 <code>queue[140]</code></li><li>找到第一个非空队列，开始运行，调度完成</li><li>遍历 <code>queue[140]</code> 时间复杂度是常数，但是还是太低效</li></ol></li><li><code>bitmap[5]</code>：一共 <code>140</code> 个优先级，一共 <code>140</code> 个进程队列，为了提高查找非空队列的效率，就可以用 <code>5*32</code> 个比特位表示队列是否为空，这样，可以大大的提高查找效率(相比较于遍历，直接用下标更高效)<!-- ![1749277110985](image/进程概念/1749277110985.png) --><img src="/2025/11/22/%E5%88%9D%E8%AF%86%E8%BF%9B%E7%A8%8B-%E6%A6%82%E5%BF%B5/1749277110985.png" class=""></li></ul><h5 id="3-4-5-过期队列-expired-queue"><a href="#3-4-5-过期队列-expired-queue" class="headerlink" title="3.4.5 过期队列 expired queue"></a>3.4.5 过期队列 expired queue</h5><ul><li>过期队列和活动队列结构一模一样</li><li>过期队列上防止的进程，都是时间片耗尽的进程</li><li>当活动队列上的进程都被处理完毕之后，对过期队列的进程进行时间片重新计算</li></ul><h5 id="3-4-6-active指针和expired指针"><a href="#3-4-6-active指针和expired指针" class="headerlink" title="3.4.6 active指针和expired指针"></a>3.4.6 active指针和expired指针</h5><ul><li><code>active</code> 指针指向活动队列</li><li><code>expired</code> 指针指向过期队列</li><li>随着活动队列上的进程越来越少，过期队列上的进程越来越多，在合适的时候，需要交换 <code>active</code>指针和 <code>expired</code> 指针指向的内容</li></ul><h5 id="3-4-7-总结"><a href="#3-4-7-总结" class="headerlink" title="3.4.7 总结"></a>3.4.7 总结</h5><!-- ![1749277860278](image/进程概念/1749277860278.png) --><img src="/2025/11/22/%E5%88%9D%E8%AF%86%E8%BF%9B%E7%A8%8B-%E6%A6%82%E5%BF%B5/1749277860278.png" class=""><p>在系统中查找一个最合适调度的进程的时间复杂度是一个常数，不随着进程的增多而导致时间成本的增加，称之为 <code>O(1)</code> 调度算法</p><h5 id="3-4-8-补充"><a href="#3-4-8-补充" class="headerlink" title="3.4.8 补充"></a>3.4.8 补充</h5><p><code>O(1)</code> 在 <code>2003</code> 年 <code>2.5</code> 内核引入，<code>2007</code> 年 <code>2.6.23</code> 被 <code>CFS(Completely Fair Scheduler)</code> 取代。转折点在于 <code>Ingo Molnar</code> 提交的 <code>CFS</code> 补丁(多核处理器普及暴露了 <code>O(1)</code> 负载均衡的缺陷)</p><blockquote><p>正如 Linus Torvalds 所言：<br><em>“CFS 的成功在于它用简洁的模型解决了复杂的公平性问题——这是对‘完美即简单’的最佳诠释”</em><br>当前 CFS已服务 Linux 超15年，其设计仍持续引领操作系统调度器的发展方向</p></blockquote><h3 id="4-环境变量"><a href="#4-环境变量" class="headerlink" title="4. 环境变量"></a>4. 环境变量</h3><h4 id="4-1-基本概念"><a href="#4-1-基本概念" class="headerlink" title="4.1 基本概念"></a>4.1 基本概念</h4><p>环境变量（<code>Environment Variables</code>）是操作系统和应用程序用于动态配置行为的关键机制，它们以<strong>键值对</strong>的形式存在，允许程序在运行时获取系统信息、用户偏好和配置参数</p><ul><li>比如我们在编写 <code>C/C++</code> 代码的时候，链接这一过程，我们并没有指定动静态库在哪里，但是照样可以链接成功，生成可执行程序，就是因为相关环境变量帮助编译器查找</li><li>环境变量在系统中具有全局特性，通常有特殊用途</li></ul><!-- ![1752671100625](image/进程概念/1752671100625.png) --><img src="/2025/11/22/%E5%88%9D%E8%AF%86%E8%BF%9B%E7%A8%8B-%E6%A6%82%E5%BF%B5/1752671100625.png" class=""><h4 id="4-2-常见环境变量"><a href="#4-2-常见环境变量" class="headerlink" title="4.2 常见环境变量"></a>4.2 常见环境变量</h4><ol><li><p>系统级基础变量</p><table><thead><tr><th>变量名</th><th>作用</th><th>典型值示例</th></tr></thead><tbody><tr><td><strong>PATH</strong></td><td>可执行文件搜索路径</td><td><code>/usr/bin:/bin:/usr/local/bin</code></td></tr><tr><td><strong>HOME</strong></td><td>当前用户主目录</td><td><code>/home/username</code></td></tr><tr><td><strong>USER</strong></td><td>当前用户名</td><td><code>john</code></td></tr><tr><td><strong>LANG</strong></td><td>系统默认语言</td><td><code>en_US.UTF-8</code></td></tr><tr><td><strong>PWD</strong></td><td>当前工作目录</td><td><code>/home/projects</code></td></tr><tr><td><strong>SHELL</strong></td><td>默认 <code>Shell</code> 程序路径</td><td><code>/bin/bash</code></td></tr><tr><td><strong>TMPDIR</strong></td><td>临时文件目录</td><td><code>/tmp</code></td></tr></tbody></table></li><li><p>开发相关变量</p><table><thead><tr><th>变量名</th><th>作用</th><th>示例值</th></tr></thead><tbody><tr><td><strong>LD_LIBRARY_PATH</strong></td><td>动态库搜索路径</td><td><code>/usr/local/lib</code></td></tr><tr><td><strong>JAVA_HOME</strong></td><td><code>Java</code> 安装路径</td><td><code>/usr/lib/jvm/java-11</code></td></tr><tr><td><strong>PYTHONPATH</strong></td><td><code>Python</code> 模块搜索路径</td><td><code>/home/user/python_libs</code></td></tr><tr><td><strong>GOPATH</strong></td><td><code>Go</code> 工作区路径</td><td><code>/home/user/go</code></td></tr><tr><td><strong>NODE_PATH</strong></td><td><code>Node.js</code> 模块路径</td><td><code>/usr/lib/node_modules</code></td></tr></tbody></table></li><li><p>应用配置变量</p><table><thead><tr><th>变量名</th><th>作用</th><th>示例值</th></tr></thead><tbody><tr><td><strong>EDITOR</strong></td><td>默认文本编辑器</td><td><code>vim</code></td></tr><tr><td><strong>BROWSER</strong></td><td>默认浏览器</td><td><code>firefox</code></td></tr><tr><td><strong>HTTP_PROXY</strong></td><td><code>HTTP</code> 代理地址</td><td><code>http://proxy:8080</code></td></tr><tr><td><strong>NO_PROXY</strong></td><td>跳过代理的地址</td><td><code>localhost,127.0.0.1</code></td></tr><tr><td><strong>DEBUG</strong></td><td>启用调试模式</td><td><code>1</code></td></tr></tbody></table></li></ol><h4 id="4-3-环境变量操作"><a href="#4-3-环境变量操作" class="headerlink" title="4.3 环境变量操作"></a>4.3 环境变量操作</h4><h5 id="4-3-1-命令行操作"><a href="#4-3-1-命令行操作" class="headerlink" title="4.3.1 命令行操作"></a>4.3.1 命令行操作</h5><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看所有变量</span></span><br><span class="line"><span class="built_in">printenv</span></span><br><span class="line"><span class="built_in">env</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看特定变量</span></span><br><span class="line"><span class="built_in">echo</span> <span class="variable">$PATH</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置临时变量（仅当前会话）</span></span><br><span class="line"><span class="built_in">export</span> API_KEY=<span class="string">&quot;secret123&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 设置持久变量（写入配置文件）</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;export JAVA_HOME=&quot;/opt/jdk&quot;&#x27;</span> &gt;&gt; ~/.bashrc</span><br><span class="line"></span><br><span class="line"><span class="comment"># 删除变量</span></span><br><span class="line"><span class="built_in">unset</span> TEMP_VAR</span><br><span class="line"></span><br><span class="line"><span class="comment"># 临时修改变量执行程序</span></span><br><span class="line">PATH=<span class="string">&quot;/custom/bin:<span class="variable">$PATH</span>&quot;</span> myapp</span><br></pre></td></tr></table></figure><h5 id="4-3-2-系统调用"><a href="#4-3-2-系统调用" class="headerlink" title="4.3.2 系统调用"></a>4.3.2 系统调用</h5><p><strong><code>putenv</code> <code>VS</code> <code>setenv</code></strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">setenv_safe</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> var[] = <span class="string">&quot;TEST_VAR_SET=TestSetenv&quot;</span>; </span><br><span class="line">    setenv(<span class="string">&quot;TEST_VAR_SET&quot;</span>, <span class="string">&quot;TestSetenv&quot;</span>, <span class="number">1</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;setenv: %s\n&quot;</span>, getenv(<span class="string">&quot;TEST_VAR_SET&quot;</span>));</span><br><span class="line">    <span class="comment">// 函数返回后，栈内存被回收，但环境变量仍然有效</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">void</span> <span class="title function_">putenv_deadly</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="type">char</span> var[] = <span class="string">&quot;TEST_VAR_PUT=TestPutenv&quot;</span>;</span><br><span class="line">    putenv(var);                         <span class="comment">// 引用栈内存</span></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;putenv: %s\n&quot;</span>, getenv(<span class="string">&quot;TEST_VAR_PUT&quot;</span>)); <span class="comment">// 暂时能访问</span></span><br><span class="line">    <span class="comment">// 函数返回后，栈内存被回收 -&gt; 环境变量指向无效地址！</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    setenv_safe();</span><br><span class="line">    putenv_deadly();</span><br><span class="line">    </span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n函数返回后：\n&quot;</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;setenv 设置: %s\n&quot;</span>, getenv(<span class="string">&quot;TEST_VAR_SET&quot;</span>)); <span class="comment">// 仍然有效</span></span><br><span class="line">    </span><br><span class="line">    <span class="comment">// 访问 putenv 设置的环境变量 -&gt; 未定义行为！</span></span><br><span class="line">    <span class="type">char</span> *deadly = getenv(<span class="string">&quot;TEST_VAR_PUT&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span>(deadly) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;putenv 设置: %s\n&quot;</span>, deadly);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;TestPutenv 不存在\n&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行结果</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ ./env</span><br><span class="line">setenv: TestSetenv</span><br><span class="line">putenv: TestPutenv</span><br><span class="line"></span><br><span class="line">函数返回后：</span><br><span class="line">setenv 设置: TestSetenv</span><br><span class="line">TestPutenv 不存在</span><br></pre></td></tr></table></figure><h4 id="4-4-环境变量组织方式"><a href="#4-4-环境变量组织方式" class="headerlink" title="4.4 环境变量组织方式"></a>4.4 环境变量组织方式</h4><!-- ![1752671201352](image/进程概念/1752671201352.png) --><img src="/2025/11/22/%E5%88%9D%E8%AF%86%E8%BF%9B%E7%A8%8B-%E6%A6%82%E5%BF%B5/1752671201352.png" class=""><!-- ![1749279850085](image/进程概念/1749279850085.png) --><img src="/2025/11/22/%E5%88%9D%E8%AF%86%E8%BF%9B%E7%A8%8B-%E6%A6%82%E5%BF%B5/1749279850085.png" class=""><p>每个程序都会收到一张环境变量表，环境变量表是一个字符指针数组，每个指针指向一个以 <code>&#39;\0&#39;</code> 结尾的环境字符串</p><h4 id="4-5-获取环境变量"><a href="#4-5-获取环境变量" class="headerlink" title="4.5 获取环境变量"></a>4.5 获取环境变量</h4><ul><li><code>main</code> 函数三个参数<ol><li><code>int argv</code> 参数计数</li><li><code>char *argv</code> 参数向量</li><li><code>char *envp/environ</code> 环境变量(非标准)</li></ol></li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[], <span class="type">char</span> *env[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (; env[i]; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, env[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li>通过第三方变量 <code>environ</code> 获取</li></ul><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="keyword">extern</span> <span class="type">char</span> **environ;</span><br><span class="line">    <span class="type">int</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (; environ[i]; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, environ[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><blockquote><p>libc中定义的全局变量environ指向环境变量表，environ没有包含在任何头文件中，所以在使用时要注意用extern声明</p></blockquote><h4 id="4-6-环境变量的全局属性"><a href="#4-6-环境变量的全局属性" class="headerlink" title="4.6 环境变量的全局属性"></a>4.6 环境变量的全局属性</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">char</span> *env = getenv(<span class="string">&quot;MYENV&quot;</span>);</span><br><span class="line">    <span class="keyword">if</span> (env)</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, env);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行结果</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ ./test</span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$MYENV</span></span><br><span class="line">$ </span><br></pre></td></tr></table></figure><p>可以看到，该环境变量 <code>MYENV</code> 根本不存在，原因也很简单，因为我们的程序只是读取这个环境变量 <code>MYENV</code>，但是并没有设置这个环境变量<br>只需要在运行程序之前设置环境变量就可以看到其真容了</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">export</span> MYENV=<span class="string">&quot;Hello World!&quot;</span></span><br><span class="line">$ ./test</span><br><span class="line">Hello World!</span><br><span class="line">$ <span class="built_in">echo</span> <span class="variable">$MYENV</span></span><br><span class="line">Hello World!</span><br></pre></td></tr></table></figure><p>在 <code>Shell</code> 中设置环境变量，再运行程序，就能得到 <code>Shell</code> 父进程设置的环境变量，这也从侧面敲击出环<strong>境变量具有全局属性</strong>(注意子进程设置的环境变量不会影响到父进程)</p><ul><li>全局属性<ul><li>环境变量存储在进程空间的全局区域</li><li>任何函数都可以直接访问</li></ul></li><li>继承属性<ul><li>每个进程创建时，会继承父进程的环境变量副本</li><li><code>Shell</code> → 我们的程序：环境变量自动传递</li></ul></li></ul><!-- ![1752671336378](image/进程概念/1752671336378.png) --><img src="/2025/11/22/%E5%88%9D%E8%AF%86%E8%BF%9B%E7%A8%8B-%E6%A6%82%E5%BF%B5/1752671336378.png" class=""><h3 id="5-程序地址空间"><a href="#5-程序地址空间" class="headerlink" title="5. 程序地址空间"></a>5. 程序地址空间</h3><blockquote><p>研究平台-&gt;Kernel 2.6.32(32位平台)</p></blockquote><h4 id="5-1-程序地址空间回顾"><a href="#5-1-程序地址空间回顾" class="headerlink" title="5.1 程序地址空间回顾"></a>5.1 程序地址空间回顾</h4><p>在学习 <code>C</code> 语言的时候，遇到过这样的空间布局</p><!-- ![1749285228110](image/进程概念/1749285228110.png) --><img src="/2025/11/22/%E5%88%9D%E8%AF%86%E8%BF%9B%E7%A8%8B-%E6%A6%82%E5%BF%B5/1749285228110.png" class=""><p>可以通过代码观察分布情况</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> g_un_val;</span><br><span class="line"><span class="type">int</span> g_val = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc, <span class="type">char</span> *argv[], <span class="type">char</span> *env[])</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">const</span> <span class="type">char</span> *str = <span class="string">&quot;Hello world\n&quot;</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Code address: %p\n&quot;</span>, main);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Initial global address: %p\n&quot;</span>, &amp;g_val);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Uninitialized global address: %p\n&quot;</span>, &amp;g_un_val);</span><br><span class="line"></span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> st = <span class="number">10</span>;</span><br><span class="line">    <span class="type">char</span> *heap1 = (<span class="type">char</span> *)<span class="built_in">malloc</span>(<span class="number">10</span>);</span><br><span class="line">    <span class="type">char</span> *heap2 = (<span class="type">char</span> *)<span class="built_in">malloc</span>(<span class="number">4</span>);</span><br><span class="line">    <span class="type">char</span> *heap3 = (<span class="type">char</span> *)<span class="built_in">malloc</span>(<span class="number">7</span>);</span><br><span class="line">    <span class="type">char</span> *heap4 = (<span class="type">char</span> *)<span class="built_in">malloc</span>(<span class="number">15</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Heap address: %p\n&quot;</span>, heap1);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Heap address: %p\n&quot;</span>, heap2);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Heap address: %p\n&quot;</span>, heap3);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Heap address: %p\n&quot;</span>, heap4);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Static address:%p\n&quot;</span>, &amp;st);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Stack address:%p\n&quot;</span>, &amp;heap1);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Stack address:%p\n&quot;</span>, &amp;heap2);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Stack address:%p\n&quot;</span>, &amp;heap3);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Stack address:%p\n&quot;</span>, &amp;heap4);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Read only address:%p\n&quot;</span>, str);</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; argc; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;argv[%d]: %p\n&quot;</span>, i, (<span class="type">void</span>*)argv[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; env[i]; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;env[%d]: %p\n&quot;</span>, i, (<span class="type">void</span>*)env[i]);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行结果</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line">$ gcc address.c -o address</span><br><span class="line">$ ./address </span><br><span class="line">Code address: 0x56b7a8fb0189</span><br><span class="line">Initial global address: 0x56b7a8fb3010</span><br><span class="line">Uninitialized global address: 0x56b7a8fb301c</span><br><span class="line">Heap address: 0x56b7aabf16b0</span><br><span class="line">Heap address: 0x56b7aabf16d0</span><br><span class="line">Heap address: 0x56b7aabf16f0</span><br><span class="line">Heap address: 0x56b7aabf1710</span><br><span class="line">Static address:0x56b7a8fb3014</span><br><span class="line">Stack address:0x7ffd62793970</span><br><span class="line">Stack address:0x7ffd62793978</span><br><span class="line">Stack address:0x7ffd62793980</span><br><span class="line">Stack address:0x7ffd62793988</span><br><span class="line">Read only address:0x56b7a8fb1008</span><br><span class="line">argv[0]: 0x7ffd6279425e</span><br><span class="line"><span class="built_in">env</span>[0]: 0x7ffd62794268</span><br><span class="line"><span class="built_in">env</span>[1]: 0x7ffd62794278</span><br><span class="line"><span class="built_in">env</span>[2]: 0x7ffd6279428c</span><br><span class="line"><span class="built_in">env</span>[3]: 0x7ffd627942a9</span><br><span class="line"><span class="built_in">env</span>[4]: 0x7ffd627942b7</span><br><span class="line"><span class="built_in">env</span>[5]: 0x7ffd627942d1</span><br><span class="line"><span class="built_in">env</span>[6]: 0x7ffd627942e8</span><br><span class="line"><span class="built_in">env</span>[7]: 0x7ffd627942f4</span><br><span class="line"><span class="built_in">env</span>[8]: 0x7ffd62794309</span><br><span class="line"><span class="built_in">env</span>[9]: 0x7ffd62794382</span><br><span class="line"><span class="built_in">env</span>[10]: 0x7ffd62794391</span><br><span class="line"><span class="built_in">env</span>[11]: 0x7ffd627943a2</span><br><span class="line"><span class="built_in">env</span>[12]: 0x7ffd62794abb</span><br><span class="line"><span class="built_in">env</span>[13]: 0x7ffd62794adb</span><br><span class="line"><span class="built_in">env</span>[14]: 0x7ffd62794b62</span><br><span class="line"><span class="built_in">env</span>[15]: 0x7ffd62794b95</span><br><span class="line"><span class="built_in">env</span>[16]: 0x7ffd62794bb4</span><br><span class="line"><span class="built_in">env</span>[17]: 0x7ffd62794bd6</span><br><span class="line"><span class="built_in">env</span>[18]: 0x7ffd62794bed</span><br><span class="line"><span class="built_in">env</span>[19]: 0x7ffd62794c01</span><br><span class="line"><span class="built_in">env</span>[20]: 0x7ffd62794c21</span><br><span class="line"><span class="built_in">env</span>[21]: 0x7ffd62794c2a</span><br><span class="line"><span class="built_in">env</span>[22]: 0x7ffd62794c6a</span><br><span class="line"><span class="built_in">env</span>[23]: 0x7ffd62794c72</span><br><span class="line"><span class="built_in">env</span>[24]: 0x7ffd62794c86</span><br><span class="line"><span class="built_in">env</span>[25]: 0x7ffd62794ca5</span><br><span class="line"><span class="built_in">env</span>[26]: 0x7ffd62794cc9</span><br><span class="line"><span class="built_in">env</span>[27]: 0x7ffd62794cea</span><br><span class="line"><span class="built_in">env</span>[28]: 0x7ffd62794d19</span><br><span class="line"><span class="built_in">env</span>[29]: 0x7ffd62794db1</span><br><span class="line"><span class="built_in">env</span>[30]: 0x7ffd62794df2</span><br><span class="line"><span class="built_in">env</span>[31]: 0x7ffd62794e6d</span><br><span class="line"><span class="built_in">env</span>[32]: 0x7ffd62794f40</span><br><span class="line"><span class="built_in">env</span>[33]: 0x7ffd62794f76</span><br><span class="line"><span class="built_in">env</span>[34]: 0x7ffd62794f8a</span><br><span class="line"><span class="built_in">env</span>[35]: 0x7ffd62794fe2</span><br></pre></td></tr></table></figure><h4 id="5-2-虚拟地址"><a href="#5-2-虚拟地址" class="headerlink" title="5.2 虚拟地址"></a>5.2 虚拟地址</h4><p>来这样一段代码引入</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> g_val = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pid_t</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;Fork error&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Child[%d]  address:%p\n&quot;</span>, getpid(), &amp;g_val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Parent[%d] address:%p\n&quot;</span>, getpid(), &amp;g_val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行结果</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ ./test </span><br><span class="line">Parent[1518857] address:0x5fdd891b2010</span><br><span class="line">Child[1518858]  address:0x5fdd891b2010 </span><br></pre></td></tr></table></figure><p>为什么地址是相同的呢？</p><ul><li>子进程通过 <code>fork()</code> 创建时，<strong>会继承父进程的完整的虚拟内存地址空间</strong></li><li>父子进程的虚拟地址布局相同，所以显示相同的地址值</li></ul><p>修改一下变量会不会导致地址不同呢?🤔</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;sys/types.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> g_val = <span class="number">6</span>;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">pid_t</span> pid = fork();</span><br><span class="line">    <span class="keyword">if</span> (pid &lt; <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        perror(<span class="string">&quot;Fork error&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span> (pid == <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        g_val = <span class="number">666</span>;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Child[%d]  [g_val:%d] address:%p\n&quot;</span>, getpid(), g_val, &amp; g_val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">    &#123;</span><br><span class="line">        sleep(<span class="number">2</span>);</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Parent[%d] [g_val:%d]   address:%p\n&quot;</span>, getpid(), g_val, &amp;g_val);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>运行结果</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ ./test </span><br><span class="line">Child[1519153]  [g_val:666] address:0x6034485e1010</span><br><span class="line">Parent[1519152] [g_val:6]   address:0x6034485e1010</span><br></pre></td></tr></table></figure><p>输出的变量值不一样，但是地址却是一样的😮</p><ul><li>变量既然值不相同，所以父子进程输出的变量<strong>绝对不是同一个变量</strong></li><li>说明我们看到的地址<strong>肯定不是物理地址</strong><br>在 <code>Linux</code> 下，这种地址叫做<strong>虚拟地址</strong>。我们<strong>使用 <code>C/C++</code> 时候所看到的地址，全都是虚拟地址!</strong>，物理地址，用户一般看不到，由操作系统管理</li></ul><h4 id="5-3-进程地址空间"><a href="#5-3-进程地址空间" class="headerlink" title="5.3 进程地址空间"></a>5.3 进程地址空间</h4><p>学到进程之后，说程序地址空间可能没有那么的准确，准确的说应该是 进程地址空间，如下图👇</p><!-- ![1749293043608](image/进程概念/1749293043608.png) --><img src="/2025/11/22/%E5%88%9D%E8%AF%86%E8%BF%9B%E7%A8%8B-%E6%A6%82%E5%BF%B5/1749293043608.png" class=""><ul><li>同一个变量，地址相同，其实是虚拟地址相同，内容不同是因为映射到了不同的物理地址</li></ul><h4 id="5-4-初识虚拟内存"><a href="#5-4-初识虚拟内存" class="headerlink" title="5.4 初识虚拟内存"></a>5.4 初识虚拟内存</h4><p><strong>虚拟内存的核心概念</strong></p><ol><li><p>基本定义</p><ul><li>虚拟内存（<code>Virtual Memory</code>）是计算机系统内存管理的一种技术，它<strong>使得应用程序认为它拥有连续可用的内存</strong>（一个连续完整的地址空间,这个空间通常比实际物理内存大得多），而实际上，它通常是被分隔成多个物理内存碎片，还有部分暂时存储在外部磁盘存储器上，在需要时进行数据交换</li><li>虚拟内存的主要目的是提供比物理内存更大的地址空间，并且提供<strong>内存保护</strong>和<strong>多任务隔离</strong></li></ul></li><li><p>核心组件</p><ul><li><strong>虚拟地址 (VA)</strong>：进程使用的地址</li><li><strong>物理地址 (PA)</strong>：实际内存硬件中的地址</li><li><strong>内存管理单元 (MMU)</strong>：硬件组件，负责将虚拟地址转换为物理地址</li><li><strong>页表 (Page Table)</strong>：操作系统维护的数据结构，存储虚拟页到物理页框的映射</li></ul></li><li><p>地址空间划分<br>虚拟内存通常划分为固定大小的块：</p><ul><li><strong>页 (Page)</strong>：虚拟内存中的块（通常<code>4KB</code>）</li><li><strong>页框 (Frame)</strong>：物理内存中的块（大小与页相同）</li></ul></li></ol><p><strong>虚拟内存的关键特性</strong></p><ol><li><p>内存隔离与保护</p><ul><li>每个进程有独立的地址空间</li><li>防止进程意外访问其他进程的内存</li><li>通过页表权限位实现只读、可执行等保护</li></ul></li><li><p>写时复制 (<code>Copy-On-Write</code>)</p><ul><li><code>fork()</code>创建子进程时不复制内存</li><li>父子进程共享物理页</li><li>当任一进程尝试写入时，才复制该页</li><li>极大提高进程创建效率</li></ul></li><li><p>内存映射文件</p><ul><li>文件可以直接映射到虚拟地址空间</li><li>访问文件就像访问内存一样</li><li>操作系统负责按需加载文件内容</li></ul></li></ol><p><code>Linux</code> 下进程的地址空间的所有信息的结构体是 <code>mm_struct</code> (内存描述符)。每个进程只有一个 <code>mm_struct</code> 结构，在每个进程的 <code>task_struct</code> 结构中，有一个指向该进程的结构</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">task_struct</span> &#123;</span></span><br><span class="line"><span class="comment">/*……*/</span></span><br><span class="line">   <span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">mm</span>, // 对于普通用户进程来说该字段指向其虚拟地址空间的用户空间部分，对于内核线程来说这部分为 <span class="title">NULL</span></span></span><br><span class="line"><span class="class">   <span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">active_mm</span>;</span><span class="comment">// 该字段是内核线程使用的。当该进程是内核线程时，其 mm 字段为 NULL，表示没有内存地址空间，但也不是真的没有，因为所有进程关于内核的映射都是一样的，内核线程可以使用任意进程的地址空间</span></span><br><span class="line"><span class="comment">/*……*/</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以说 <code>mm_struct</code> 是对整个用户空间的描述。每一个进程都有自己独立的 <code>mm_struct</code>，这样每一个进程都有自己独立的地址空间，互不干扰</p><!-- ![1749295970051](image/进程概念/1749295970051.png) --><img src="/2025/11/22/%E5%88%9D%E8%AF%86%E8%BF%9B%E7%A8%8B-%E6%A6%82%E5%BF%B5/1749295970051.png" class=""><p><code>mm_struct</code> 在内核源码中所在的文件是 <code>mm_types.h</code></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> &#123;</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> * <span class="title">mmap</span>;</span><span class="comment">// 指向虚拟区间(VMA)链表</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_root</span> <span class="title">mm_rb</span>;</span><span class="comment">// 红黑树</span></span><br><span class="line">   <span class="type">unsigned</span> <span class="type">long</span> task_size; <span class="comment">// 具有该结构体的进程的虚拟地址空间的大小</span></span><br><span class="line"><span class="comment">/*……*/</span></span><br><span class="line">   <span class="comment">// 代码段、数据段、堆栈段、参数段以及环境段的起始和结束地址</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> start_code, end_code, start_data, end_data;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> start_brk, brk, start_stack;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> arg_start, arg_end, env_start, env_end;</span><br><span class="line"><span class="comment">/*……*/</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><p>每个进程都有自己独立的 <code>mm_struct</code>，操作系统肯定要将这么多的进程的 <code>mm_struct</code> 组织起来，再进行统一的管理，组织的方式有两种👇</p><ol><li>当虚拟区较少时采用单链表，由 <code>mmap</code> 指针指向这个链表</li><li>当虚拟区较多时采用红黑树，由 <code>mm_rb</code> 指向这棵树</li></ol><p><code>Linux</code> 内核使用 <code>vm_area_struct</code> 结构体来表示一个独立的虚拟内存区域(<code>VMA</code>)，由于不同的虚拟内存区域功能和内部机制都不同，因此一个进程使用多个 <code>vm_area_struct</code> 结构来分别表示不同类型的虚拟内存区域。上面提到的两种组织方式使用的就是 <code>vm_area_struct</code> 结构来连接各个 <code>VMA</code>，方便进程进行快速访问</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> &#123;</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> vm_start;<span class="comment">// 开始处</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> vm_end;<span class="comment">// 结束处</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">vm_area_struct</span> *<span class="title">vm_next</span>, *<span class="title">vm_prev</span>;</span><span class="comment">// 前后指针</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> <span class="title">vm_rb</span>;</span><span class="comment">// 红黑树中的位置</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> rb_subtree_gap;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">mm_struct</span> *<span class="title">vm_mm</span>;</span><span class="comment">// 所属的 mm_struct</span></span><br><span class="line">    <span class="type">pgprot_t</span> vm_page_prot;</span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> vm_flags;<span class="comment">// 标志位</span></span><br><span class="line">   <span class="class"><span class="keyword">union</span> &#123;</span></span><br><span class="line">        <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">            <span class="class"><span class="keyword">struct</span> <span class="title">rb_node</span> <span class="title">rb</span>;</span></span><br><span class="line">            <span class="type">unsigned</span> <span class="type">long</span> rb_subtree_last;</span><br><span class="line">        &#125; linear;</span><br><span class="line">        <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">nonlinear</span>;</span></span><br><span class="line">    &#125; shared;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">list_head</span> <span class="title">anon_vma_chain</span>;</span> </span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">anon_vma</span> *<span class="title">anon_vma</span>;</span></span><br><span class="line">    <span class="type">const</span> <span class="class"><span class="keyword">struct</span> <span class="title">vm_operations_struct</span> *<span class="title">vm_ops</span>;</span><span class="comment">//vma对应的实际操作</span></span><br><span class="line">    <span class="type">unsigned</span> <span class="type">long</span> vm_pgoff;<span class="comment">//文件映射的偏移量</span></span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">file</span> * <span class="title">vm_file</span>;</span><span class="comment">//映射的文件</span></span><br><span class="line">    <span class="type">void</span> * vm_private_data;<span class="comment">//私有数据</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure><!-- ![1749298979318](image/进程概念/1749298979318.png) --><img src="/2025/11/22/%E5%88%9D%E8%AF%86%E8%BF%9B%E7%A8%8B-%E6%A6%82%E5%BF%B5/1749298979318.png" class=""><h4 id="5-5-为什么要有虚拟地址空间"><a href="#5-5-为什么要有虚拟地址空间" class="headerlink" title="5.5 为什么要有虚拟地址空间"></a>5.5 为什么要有虚拟地址空间</h4><p>不妨想一想如果没有虚拟地址空间，程序直接可以操作物理内存会发生上什么?🤔</p><p>1️⃣ <strong>内存安全问题（恶意访问）</strong></p><ul><li>任何程序可以随意读写整个物理内存</li><li>恶意程序可以：<ul><li>窃取其他进程的密码、加密密钥等敏感数据</li><li>篡改操作系统内核代码</li><li>破坏其他关键程序的内存数据</li></ul></li><li>比如：银行程序的内存被恶意程序直接读取，客户账户信息全部泄露</li></ul><p>2️⃣ <strong>系统稳定性崩溃</strong></p><ul><li>单个程序的指针错误会导致全系统崩溃：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> *ptr = (<span class="type">int</span>*)<span class="number">0x12345678</span>; <span class="comment">// 随意指向物理地址</span></span><br><span class="line">*ptr = <span class="number">42</span>; <span class="comment">// 可能覆盖操作系统关键数据结构</span></span><br></pre></td></tr></table></figure></li><li>结果：整个系统蓝屏&#x2F;死机，需要重启</li><li>据统计，这类错误在早期 <code>DOS</code> 系统中导致 &gt; <code>40%</code> 的系统崩溃</li></ul><p>3️⃣ <strong>内存碎片化灾难</strong></p><ul><li>物理内存分配示意图：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[程序A][空闲][程序B][程序C][空闲][程序D]</span><br></pre></td></tr></table></figure></li><li>当程序B退出后：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[程序A][空闲][空闲][程序C][空闲][程序D]</span><br></pre></td></tr></table></figure></li><li>新程序E需要连续内存：即使总空闲足够，但因不连续无法加载</li><li>最终导致：<strong>内存明明有空闲却无法使用</strong>的窘境</li></ul><p>4️⃣ <strong>多进程协作不可能</strong></p><ul><li>所有程序必须使用<strong>绝对物理地址</strong></li><li>冲突示例：<ul><li>程序1认为自己的数据在<code>0x1000</code></li><li>程序2也认为自己的数据在<code>0x1000</code></li><li>操作系统无法同时满足两个程序</li></ul></li><li>结果：每次只能运行一个程序（如早期的 <code>DOS</code> 系统）</li></ul><p>5️⃣ <strong>安全隔离机制失效</strong></p><ul><li>用户程序可直接修改内核内存：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 普通用户程序</span></span><br><span class="line"><span class="type">void</span> *kernel_mem = (<span class="type">void</span>*)<span class="number">0x80000000</span>; </span><br><span class="line"><span class="built_in">memset</span>(kernel_mem, <span class="number">0</span>, <span class="number">1024</span>); <span class="comment">// 清除内核数据结构</span></span><br></pre></td></tr></table></figure></li><li>后果：权限系统形同虚设，普通用户可获取 <code>root</code> 权限</li></ul><p>6️⃣ <strong>内存浪费严重</strong></p><ul><li>每个程序需要加载完整副本：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">程序A：加载libc.so → 物理地址0x100000-0x200000</span><br><span class="line">程序B：加载libc.so → 物理地址0x300000-0x400000</span><br></pre></td></tr></table></figure></li><li>相同库在内存中有多份拷贝</li><li>研究显示：这种冗余会浪费 <code>40%-60%</code> 的物理内存</li></ul><p>7️⃣ <strong>开发复杂度剧增</strong></p><ul><li>程序员必须：<ul><li>手动管理内存地址冲突😱</li><li>知道所有硬件的物理地址映射😱</li><li>为每个部署环境重写地址相关代码😱</li></ul></li><li>示例代码：<figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不同机器需要不同地址</span></span><br><span class="line"><span class="meta">#<span class="keyword">ifdef</span> MACHINE_A</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> VIDEO_MEM 0xB8000</span></span><br><span class="line"><span class="meta">#<span class="keyword">else</span> </span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> VIDEO_MEM 0xA0000</span></span><br><span class="line"><span class="meta">#<span class="keyword">endif</span></span></span><br></pre></td></tr></table></figure></li><li>结果：开发效率降低10倍以上</li></ul><p><strong>虚拟地址空间如何解决这些问题</strong></p><p><strong>内存安全沙箱</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 在现代系统中</span></span><br><span class="line"><span class="built_in">printf</span>(<span class="string">&quot;变量地址：%p\n&quot;</span>, &amp;var); <span class="comment">// 输出虚拟地址0x7ffe3b5a8f3c</span></span><br></pre></td></tr></table></figure><ul><li>实际物理地址对程序不可见</li><li>每次访问都经过 <code>MMU</code> 转换：<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">进程A：虚拟地址0x1000 → 物理地址0x2000</span><br><span class="line">进程B：虚拟地址0x1000 → 物理地址0x3000</span><br></pre></td></tr></table></figure></li></ul><p><strong>连续虚拟空间 vs 分散物理内存</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">虚拟地址空间：</span><br><span class="line">0x400000-0x401000: 代码段</span><br><span class="line">0x600000-0x601000: 堆 ← 连续地址</span><br><span class="line">0x7ffe0000-0x7ffe1000: 栈</span><br><span class="line"></span><br><span class="line">物理内存：</span><br><span class="line">代码段 → 帧1023</span><br><span class="line">堆部分1 → 帧2012</span><br><span class="line">堆部分2 → 帧3015</span><br><span class="line">栈 → 帧1522</span><br></pre></td></tr></table></figure><p><strong>共享内存优化</strong></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">进程A：虚拟地址0x400000 → 物理帧1000 (libc)</span><br><span class="line">进程B：虚拟地址0x400000 → 物理帧1000 (相同libc)</span><br><span class="line">进程C：虚拟地址0x400000 → 物理帧1000 (相同libc)</span><br></pre></td></tr></table></figure><p>正如计算机科学家 <code>David Wheeler</code> 所言：</p><blockquote><p><strong>“在计算机科学中，没有什么问题是不能通过增加一个中间层来解决的，但这通常会产生新问题”</strong></p></blockquote><p>在虚拟内存带来便利的同时，同样也产生了新的挑战(比如性能开销、内存占用、复杂性、确定性等)</p><blockquote><p><strong>“所有问题都可以通过增加一个间接层来解决，除了太多间接层的问题—Fred Brooks《人月神话》”</strong></p></blockquote><p><strong>在简洁与复杂、安全与效率、抽象与具体之间，寻找精妙的平衡点。而每一次这样的平衡，都推动计算科学向前迈进一大步</strong></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Shell运行原理</title>
      <link href="/2025/11/21/Shell%E8%BF%90%E8%A1%8C%E5%8E%9F%E7%90%86/"/>
      <url>/2025/11/21/Shell%E8%BF%90%E8%A1%8C%E5%8E%9F%E7%90%86/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h2 id="Shell"><a href="#Shell" class="headerlink" title="Shell"></a>Shell</h2><h3 id="1-什么是-Shell？"><a href="#1-什么是-Shell？" class="headerlink" title="1. 什么是 Shell？"></a>1. 什么是 Shell？</h3><p><strong>Shell</strong> 是用户与操作系统内核(<code>Kernel</code>)之间的接口，负责接收用户输入的命令，解释并执行这些命令。常见的 <code>Shell</code> 包括 <code>Bash</code>(<code>Bourne-Again Shell</code>)、<code>Zsh</code>(<code>Z Shell</code>)、<code>Fish</code> 等。它的核心功能包括：</p><ul><li><strong>命令解释</strong>：将用户输入的命令转换为系统调用</li><li><strong>脚本编程</strong>：支持编写自动化脚本</li><li><strong>环境管理</strong>：管理环境变量、进程、输入输出等</li></ul><!-- ![alt text](Shell运行原理.png) --><img src="/2025/11/21/Shell%E8%BF%90%E8%A1%8C%E5%8E%9F%E7%90%86/Shell%E8%BF%90%E8%A1%8C%E5%8E%9F%E7%90%86.png" class=""><h3 id="2-Shell-的基础语法"><a href="#2-Shell-的基础语法" class="headerlink" title="2. Shell 的基础语法"></a>2. Shell 的基础语法</h3><p><code>Shell</code> 语法与其他编程语言类似，但更专注于命令执行和文本处理。以下是基础要点：</p><h4 id="2-1-变量"><a href="#2-1-变量" class="headerlink" title="2.1 变量"></a>2.1 <strong>变量</strong></h4><ul><li>定义变量：<code>变量名=值</code>(等号两侧不能有空格)</li><li>使用变量：<code>$变量名</code> 或 <code>$&#123;变量名&#125;</code></li><li>只读变量：<code>readonly 变量名</code></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">name=<span class="string">&quot;Alice&quot;</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;Hello, <span class="variable">$name</span>&quot;</span>  <span class="comment"># 输出：Hello, Alice</span></span><br></pre></td></tr></table></figure><h4 id="2-2-命令执行"><a href="#2-2-命令执行" class="headerlink" title="2.2 命令执行"></a>2.2 命令执行</h4><ul><li>直接执行命令：<code>命令 参数</code>(如 <code>ls -l</code>)</li><li>将命令输出赋值给变量：<code>变量名=$(命令)</code> 或 <code>变量名=\</code>命令`&#96;</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">current_dir=$(<span class="built_in">pwd</span>)</span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;当前目录：<span class="variable">$current_dir</span>&quot;</span></span><br></pre></td></tr></table></figure><h4 id="2-3-控制结构"><a href="#2-3-控制结构" class="headerlink" title="2.3 控制结构"></a>2.3 控制结构</h4><ul><li><strong>条件判断</strong>：<code>if-then-elif-else-fi</code></li><li><strong>循环</strong>：<code>for</code>、<code>while</code>、<code>until</code></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 条件判断</span></span><br><span class="line"><span class="keyword">if</span> [ <span class="variable">$num</span> -gt 10 ]; <span class="keyword">then</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;大于10&quot;</span></span><br><span class="line"><span class="keyword">else</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;小于等于10&quot;</span></span><br><span class="line"><span class="keyword">fi</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 循环</span></span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> &#123;1..5&#125;; <span class="keyword">do</span></span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;数字：<span class="variable">$i</span>&quot;</span></span><br><span class="line"><span class="keyword">done</span></span><br></pre></td></tr></table></figure><h4 id="2-4-函数"><a href="#2-4-函数" class="headerlink" title="2.4 函数"></a>2.4 函数</h4><ul><li>定义函数：<code>函数名() &#123; 命令 &#125;</code></li><li>调用函数：<code>函数名 参数</code></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">greet</span></span>() &#123;</span><br><span class="line">    <span class="built_in">echo</span> <span class="string">&quot;Hello, <span class="variable">$1</span>!&quot;</span></span><br><span class="line">&#125;</span><br><span class="line">greet <span class="string">&quot;Bob&quot;</span>  <span class="comment"># 输出：Hello, Bob!</span></span><br></pre></td></tr></table></figure><h4 id="2-5-输入输出重定向"><a href="#2-5-输入输出重定向" class="headerlink" title="2.5 输入输出重定向"></a>2.5 输入输出重定向</h4><ul><li>重定向输出：<code>&gt;</code>(覆盖)、<code>&gt;&gt;</code>(追加)</li><li>重定向输入：<code>&lt;</code></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;内容&quot;</span> &gt; file.txt   <span class="comment"># 覆盖写入文件</span></span><br><span class="line"><span class="built_in">cat</span> file.txt            <span class="comment"># 读取文件内容</span></span><br></pre></td></tr></table></figure><h4 id="2-6-管道-Pipe"><a href="#2-6-管道-Pipe" class="headerlink" title="2.6 管道(Pipe)"></a>2.6 管道(Pipe)</h4><ul><li>将前一个命令的输出作为后一个命令的输入：<code>|</code></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ls</span> | grep <span class="string">&quot;.txt&quot;</span>  <span class="comment"># 列出当前目录下所有.txt文件</span></span><br></pre></td></tr></table></figure><h4 id="2-7-引号"><a href="#2-7-引号" class="headerlink" title="2.7 引号"></a>2.7 引号</h4><ul><li>单引号 <code>&#39;&#39;</code>：禁止变量替换</li><li>双引号 <code>&quot;&quot;</code>：允许变量替换</li><li>反引号 <code>` `</code> 或 <code>$()</code>：执行命令</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&#x27;$PATH&#x27;</span>    <span class="comment"># 输出：$PATH</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;<span class="variable">$PATH</span>&quot;</span>    <span class="comment"># 输出：环境变量PATH的值</span></span><br><span class="line"><span class="built_in">echo</span> $(<span class="built_in">date</span>)    <span class="comment"># 输出：当前日期</span></span><br></pre></td></tr></table></figure><h4 id="2-8-脚本执行"><a href="#2-8-脚本执行" class="headerlink" title="2.8 脚本执行"></a>2.8 脚本执行</h4><ul><li>添加 Shebang：<code>#!/bin/bash</code> 指定解释器</li><li>赋予执行权限：<code>chmod +x script.sh</code></li><li>运行脚本：<code>./script.sh</code> 或 <code>bash script.sh</code></li></ul><h3 id="3-Shell-的独特语法特性"><a href="#3-Shell-的独特语法特性" class="headerlink" title="3. Shell 的独特语法特性"></a>3. Shell 的独特语法特性</h3><p><code>Shell</code> 的设计目标是高效处理系统命令，因此有一些独特语法：</p><ol><li><p><strong>通配符(Wildcards)</strong>：</p><ul><li><code>*</code> 匹配任意字符，<code>?</code> 匹配单个字符，<code>[a-z]</code> 匹配范围</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ls</span> *.txt      <span class="comment"># 列出所有.txt文件</span></span><br></pre></td></tr></table></figure></li><li><p><strong>命令替换</strong>：</p><ul><li>使用 <code>$(命令)</code> 或 <code>`命令`</code> 将命令输出嵌入到其他命令中</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;今天是 <span class="subst">$(date)</span>&quot;</span></span><br></pre></td></tr></table></figure></li><li><p><strong>环境变量</strong>：</p><ul><li>通过 <code>export</code> 设置全局变量，影响子进程</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">export</span> PATH=<span class="variable">$PATH</span>:/my/custom/path</span><br></pre></td></tr></table></figure></li><li><p><strong>子 Shell(Subshell)</strong>：</p><ul><li>使用 <code>()</code> 创建一个子 Shell 执行命令，环境变量不影响父 Shell</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="built_in">cd</span> /tmp &amp;&amp; <span class="built_in">ls</span>)  <span class="comment"># 在子Shell中切换目录</span></span><br></pre></td></tr></table></figure></li><li><p><strong>别名(Alias)</strong>：</p><ul><li>简化常用命令：<code>alias 别名=&quot;命令&quot;</code></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">alias</span> ll=<span class="string">&quot;ls -alF&quot;</span></span><br></pre></td></tr></table></figure></li></ol><h3 id="4-Shell-如何运行命令？"><a href="#4-Shell-如何运行命令？" class="headerlink" title="4. Shell 如何运行命令？"></a>4. Shell 如何运行命令？</h3><p><code>Shell</code> 将命令分为两类：<strong>内建命令</strong>和<strong>外部命令</strong></p><h4 id="4-1-内建命令-Built-in-Commands"><a href="#4-1-内建命令-Built-in-Commands" class="headerlink" title="4.1 内建命令(Built-in Commands)"></a>4.1 <strong>内建命令(Built-in Commands)</strong></h4><ul><li><strong>定义</strong>：直接内置于 <code>Shell</code> 中，无需启动新进程</li><li><strong>特点</strong>：<ul><li>执行速度快(无进程创建开销)</li><li>可修改 <code>Shell</code> 自身环境(如 <code>cd</code> 改变当前目录)</li></ul></li><li><strong>常见命令</strong>：<code>cd</code>, <code>echo</code>, <code>export</code>, <code>read</code>, <code>exit</code> 等。</li></ul><h4 id="4-2-外部命令-External-Commands"><a href="#4-2-外部命令-External-Commands" class="headerlink" title="4.2 外部命令(External Commands)"></a>4.2 <strong>外部命令(External Commands)</strong></h4><ul><li><strong>定义</strong>：独立的可执行文件(如 <code>/bin/ls</code>、<code>/usr/bin/grep</code>)</li><li><strong>执行过程</strong>：<ol><li><strong>查找路径</strong>：<code>Shell</code> 通过 <code>PATH</code> 环境变量搜索命令的位置</li><li><strong>创建子进程</strong>：使用 <code>fork()</code> 创建子进程，在子进程中通过 <code>exec()</code> 执行命令</li><li><strong>等待完成</strong>：父进程(<code>Shell</code>)等待子进程结束</li></ol></li></ul><h4 id="4-3-示例流程："><a href="#4-3-示例流程：" class="headerlink" title="4.3 示例流程："></a>4.3 示例流程：</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 外部命令：执行 /bin/ls</span></span><br><span class="line"><span class="built_in">ls</span> -l</span><br><span class="line"><span class="comment"># 1. Shell 解析命令，检查是否为内建命令。</span></span><br><span class="line"><span class="comment"># 2. 发现是外部命令，搜索 PATH 找到 /bin/ls。</span></span><br><span class="line"><span class="comment"># 3. 创建子进程运行 /bin/ls -l。</span></span><br></pre></td></tr></table></figure><h4 id="4-4-混合场景"><a href="#4-4-混合场景" class="headerlink" title="4.4 混合场景"></a>4.4 <strong>混合场景</strong></h4><ul><li>通过 <code>type</code> 命令 可判断命令类型：</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">type</span> <span class="built_in">cd</span>     <span class="comment"># 输出：cd is a shell builtin</span></span><br><span class="line"><span class="built_in">type</span> <span class="built_in">ls</span>     <span class="comment"># 输出：ls is /bin/ls</span></span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Linux权限</title>
      <link href="/2025/11/20/Linux%E6%9D%83%E9%99%90/"/>
      <url>/2025/11/20/Linux%E6%9D%83%E9%99%90/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h1 id="Linux权限"><a href="#Linux权限" class="headerlink" title="Linux权限"></a>Linux权限</h1><h2 id="1-Linux权限相关概念"><a href="#1-Linux权限相关概念" class="headerlink" title="1. Linux权限相关概念"></a>1. Linux权限相关概念</h2><p><strong><code>Linux</code> 下有两种用户：超级用户(<code>root</code>)、普通用户</strong></p><ul><li>超级用户：可以在系统下做任何事情，不受限制</li><li>普通用户：受到权限限制<blockquote><p>超级用户的命令提示符是’#’，普通用户的命令行提示符是’$’</p></blockquote></li></ul><p><strong>理解权限</strong></p><!-- ![alt text](image/Linux权限/权限.png) --><img src="/2025/11/20/Linux%E6%9D%83%E9%99%90/%E6%9D%83%E9%99%90.png" class=""><h2 id="2-Linux权限相关命令"><a href="#2-Linux权限相关命令" class="headerlink" title="2. Linux权限相关命令"></a>2. Linux权限相关命令</h2><h3 id="2-1-su-——-用户切换"><a href="#2-1-su-——-用户切换" class="headerlink" title="2.1 su —— 用户切换"></a>2.1 su —— 用户切换</h3><p><strong>命令</strong> <code>su [用户名]</code><br><strong>功能</strong> 切换用户</p><ul><li><code>su root</code> 的时候，<code>root</code> 可以省略</li></ul><h3 id="2-2-adduser-userdel-——新增用户-删除用户"><a href="#2-2-adduser-userdel-——新增用户-删除用户" class="headerlink" title="2.2 adduser&#x2F;userdel ——新增用户&#x2F;删除用户"></a>2.2 adduser&#x2F;userdel ——新增用户&#x2F;删除用户</h3><p>在 <code>root</code> 用户下，可以新增其他用户，并设置密码，也可以删除用户(建议日常练习时新建一个自己的用户，不要使用 <code>root</code> 用户练习!!!)</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">[root@hcss-ecs-0be3 /]# adduser xm</span><br><span class="line"><span class="comment"># 为xm用户设置密码，输入密码的时候是不会回显的!!!</span></span><br><span class="line">[root@hcss-ecs-0be3 /]# passwd xm</span><br><span class="line">Changing password <span class="keyword">for</span> user xm.</span><br><span class="line">New password: </span><br><span class="line">Retype new password: </span><br><span class="line">passwd: all authentication tokens updated successfully.</span><br><span class="line"><span class="comment"># 用户添加成功后在home目录下可以看到</span></span><br><span class="line">[root@hcss-ecs-0be3 /]# ll /home</span><br><span class="line">total 12</span><br><span class="line">drwx------  2 VS  VS  4096 Feb 26 21:13 VS</span><br><span class="line">drwx------ 15 wyf wyf 4096 Apr 11 20:52 wyf</span><br><span class="line">drwx------  2 xm  xm  4096 Apr 12 14:08 xm</span><br><span class="line"><span class="comment"># 进入xm用户下</span></span><br><span class="line">[root@hcss-ecs-0be3 /]# su xm</span><br><span class="line">[xm@hcss-ecs-0be3 /]$ <span class="built_in">cd</span></span><br><span class="line">[xm@hcss-ecs-0be3 ~]$ <span class="built_in">ls</span></span><br><span class="line">[xm@hcss-ecs-0be3 ~]$ <span class="built_in">exit</span></span><br><span class="line"><span class="comment"># 删除xm用户</span></span><br><span class="line">[root@hcss-ecs-0be3 /]# userdel xm</span><br><span class="line"><span class="comment"># 虽然xm目录还在，但是已经失效了，没有xm这个用户了</span></span><br><span class="line"><span class="comment"># 这是Linux的默认安全策略，防止误删重要数据，删了用户之后还能找回数据</span></span><br><span class="line"><span class="comment"># userdel xm，不会删除xm用户的文件和目录</span></span><br><span class="line"><span class="comment"># userdel -r xm，删除用户时连带删除家目录</span></span><br><span class="line">[root@hcss-ecs-0be3 /]# <span class="built_in">ls</span> -al /home</span><br><span class="line">total 20</span><br><span class="line">drwxr-xr-x.  5 root root 4096 Apr 12 14:08 .</span><br><span class="line">dr-xr-xr-x. 19 root root 4096 Mar 30 18:56 ..</span><br><span class="line">drwx------   2 VS   VS   4096 Feb 26 21:13 VS</span><br><span class="line">drwx------  15 wyf  wyf  4096 Apr 11 20:52 wyf</span><br><span class="line">drwx------   2 1002 1002 4096 Apr 12 14:09 xm</span><br><span class="line"><span class="comment"># 进入xm用户家目录时会出错</span></span><br><span class="line">[root@hcss-ecs-0be3 /]# su xm</span><br><span class="line">su: user xm does not exist</span><br><span class="line">[root@hcss-ecs-0be3 /]# <span class="built_in">cd</span> /home</span><br><span class="line">[root@hcss-ecs-0be3 home]# ll</span><br><span class="line">total 12</span><br><span class="line">drwx------  2 VS   VS   4096 Feb 26 21:13 VS</span><br><span class="line">drwx------ 15 wyf  wyf  4096 Apr 11 20:52 wyf</span><br><span class="line">drwx------  2 1002 1002 4096 Apr 12 14:09 xm</span><br><span class="line">[root@hcss-ecs-0be3 home]# <span class="built_in">rm</span> -rf xm</span><br><span class="line">[root@hcss-ecs-0be3 home]# ll</span><br><span class="line">total 8</span><br><span class="line">drwx------  2 VS  VS  4096 Feb 26 21:13 VS</span><br><span class="line">drwx------ 15 wyf wyf 4096 Apr 11 20:52 wyf</span><br><span class="line">[root@hcss-ecs-0be3 home]# </span><br></pre></td></tr></table></figure><h3 id="2-3-sudo"><a href="#2-3-sudo" class="headerlink" title="2.3 sudo"></a>2.3 sudo</h3><p><strong>语法</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">sudo</span> [选项] 命令</span><br></pre></td></tr></table></figure><p><strong>功能</strong> <code>sudo</code>(<code>SuperUser Do</code>)允许 授权用户以其他用户身份(通常是 <code>root</code>)执行特权命令，无需直接切换用户或共享 <code>root</code> 密码。比如安装软件时，只有 <code>root</code> 才能安装，普通用户配置好配置文件之后<code>sudo</code>一下就能安装软件了</p><ul><li>所有 <code>sudo</code> 操作会被记录到日志中(<code>centos:/var/log/secure</code>)</li></ul><p><strong>常用选项</strong></p><ul><li><code>-u</code> 用户以指定用户身份执行命令(默认 <code>root</code>)</li><li><code>-l</code>列出当前用户可执行的命令权限</li><li><code>-k</code>强制重新输入密码(清除缓存的身份验证状态)</li><li><code>-v</code>刷新 <code>sudo</code> 密码有效期(延长默认 <code>5</code> 分钟的免密窗口)</li><li><code>-b</code>在后台运行命令</li></ul><h4 id="sudo的配置文件-etc-sudoers"><a href="#sudo的配置文件-etc-sudoers" class="headerlink" title="sudo的配置文件 /etc/sudoers"></a><code>sudo</code>的配置文件 <code>/etc/sudoers</code></h4><p>类似于一张用户白名单<br>有详细的配置语法规则，平时使用的时候，打开<code>/etc/sudoers</code>，添加下面一行就可满足使用<br><code>用户名     ALL=(ALL)       ALL</code></p><!-- ![1744448201450](image/Linux权限/1744448201450.png) --><img src="/2025/11/20/Linux%E6%9D%83%E9%99%90/1744448201450.png" class=""><h3 id="2-4-umask-——-控制默认权限"><a href="#2-4-umask-——-控制默认权限" class="headerlink" title="2.4 umask —— 控制默认权限"></a>2.4 umask —— 控制默认权限</h3><p><strong>功能</strong> 定义新创建文件&#x2F;目录的默认权限</p><ul><li>查看当前 <code>umask</code></li><li>修改 <code>umask</code></li></ul><p><strong>起始权限</strong></p><ul><li>文件：<code>666 - umask</code></li><li>目录：<code>777 - umask</code></li></ul><p><strong>最终权限(默认) &#x3D; 起始权限 &amp; (~umask)</strong></p><h3 id="2-5-chomod-——-修改权限"><a href="#2-5-chomod-——-修改权限" class="headerlink" title="2.5 chomod —— 修改权限"></a>2.5 chomod —— 修改权限</h3><p><strong>语法</strong><br><code>chmod [选项] 权限模式 文件/目录</code><br><strong>功能</strong> 修改文件权限<br><strong>常用选项</strong></p><ul><li><code>-R</code> 递归修改目录及其子文件权限<br><strong>示例</strong></li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 查看umask</span></span><br><span class="line">[wyf@hcss-ecs-0be3 per]$ <span class="built_in">umask</span></span><br><span class="line">0002</span><br><span class="line"><span class="comment"># 数字表示方式修改文件的权限为 rwx r-x r-x</span></span><br><span class="line"><span class="comment"># 最终修改的权限为755 &amp; ~002</span></span><br><span class="line"><span class="comment">#  755-&gt;111 101 101</span></span><br><span class="line"><span class="comment"># ~002-&gt;111 111 101</span></span><br><span class="line"><span class="comment">#       111 101 101-&gt;775</span></span><br><span class="line">[wyf@hcss-ecs-0be3 per]$ <span class="built_in">chmod</span> 755 test.txt </span><br><span class="line">[wyf@hcss-ecs-0be3 per]$ ll</span><br><span class="line">total 4</span><br><span class="line">-rwxr-xr-x 1 wyf wyf 12 Apr 12 16:15 test.txt</span><br><span class="line">[wyf@hcss-ecs-0be3 per]$ <span class="built_in">chmod</span> 666 test.txt </span><br><span class="line">[wyf@hcss-ecs-0be3 per]$ ll</span><br><span class="line">total 4</span><br><span class="line">-rw-rw-rw- 1 wyf wyf 12 Apr 12 16:15 test.txt</span><br><span class="line"><span class="comment"># 字符表示方式移除其他用户的写权限</span></span><br><span class="line">[wyf@hcss-ecs-0be3 per]$ <span class="built_in">chmod</span> o-w test.txt </span><br><span class="line">[wyf@hcss-ecs-0be3 per]$ ll</span><br><span class="line">total 4</span><br><span class="line">-rw-rw-r-- 1 wyf wyf 12 Apr 12 16:15 test.txt</span><br><span class="line"><span class="comment"># 给所有人加上读、写、执行权限</span></span><br><span class="line">[wyf@hcss-ecs-0be3 per]$ <span class="built_in">chmod</span> a+rwx test.txt </span><br><span class="line">[wyf@hcss-ecs-0be3 per]$ ll</span><br><span class="line">total 4</span><br><span class="line">-rwxrwxrwx 1 wyf wyf 12 Apr 12 16:15 test.txt</span><br><span class="line">[wyf@hcss-ecs-0be3 per]$ </span><br></pre></td></tr></table></figure><h3 id="2-6-chown-——-修改文件所有者"><a href="#2-6-chown-——-修改文件所有者" class="headerlink" title="2.6 chown —— 修改文件所有者"></a>2.6 chown —— 修改文件所有者</h3><p><strong>语法</strong><br><code>chown [选项] 用户:组 文件/目录</code><br><strong>功能</strong> 修改文件的所有者<br><strong>示例</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[wyf@hcss-ecs-0be3 per]$ <span class="built_in">sudo</span> <span class="built_in">chown</span> root test.txt </span><br><span class="line">[wyf@hcss-ecs-0be3 per]$ ll</span><br><span class="line">total 4</span><br><span class="line">-rw-rw-r-- 1 root wyf 12 Apr 12 16:32 test.txt</span><br><span class="line">[wyf@hcss-ecs-0be3 per]$ <span class="built_in">sudo</span> <span class="built_in">chown</span> wyf test.txt </span><br><span class="line">[wyf@hcss-ecs-0be3 per]$ ll</span><br><span class="line">total 4</span><br><span class="line">-rw-rw-r-- 1 wyf wyf 12 Apr 12 16:32 test.txt</span><br><span class="line">[wyf@hcss-ecs-0be3 per]$ </span><br></pre></td></tr></table></figure><h3 id="2-7-chgrp-——-修改文件所属组"><a href="#2-7-chgrp-——-修改文件所属组" class="headerlink" title="2.7 chgrp —— 修改文件所属组"></a>2.7 chgrp —— 修改文件所属组</h3><p><strong>语法</strong><br><code>chgrp [选项] 组名 文件/目录</code><br><strong>功能</strong> 修改文件所属组<br><strong>示例</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">[wyf@hcss-ecs-0be3 per]$ ll</span><br><span class="line">total 4</span><br><span class="line">-rw-rw-r-- 1 wyf wyf 12 Apr 12 16:32 test.txt</span><br><span class="line">[wyf@hcss-ecs-0be3 per]$ <span class="built_in">sudo</span> <span class="built_in">chgrp</span> root test.txt </span><br><span class="line">[wyf@hcss-ecs-0be3 per]$ ll</span><br><span class="line">total 4</span><br><span class="line">-rw-rw-r-- 1 wyf root 12 Apr 12 16:32 test.txt</span><br><span class="line">[wyf@hcss-ecs-0be3 per]$ <span class="built_in">sudo</span> <span class="built_in">chgrp</span> wyf test.txt </span><br><span class="line">[wyf@hcss-ecs-0be3 per]$ ll</span><br><span class="line">total 4</span><br><span class="line">-rw-rw-r-- 1 wyf wyf 12 Apr 12 16:32 test.txt</span><br><span class="line">[wyf@hcss-ecs-0be3 per]$ </span><br></pre></td></tr></table></figure><h2 id="3-粘滞位"><a href="#3-粘滞位" class="headerlink" title="3. 粘滞位"></a>3. 粘滞位</h2><h3 id="粘滞位概念"><a href="#粘滞位概念" class="headerlink" title="粘滞位概念"></a>粘滞位概念</h3><p>粘滞位是一种 <strong>目录级权限控制机制</strong>，主要解决多用户环境下共享目录的安全问题</p><ul><li>当一个目录设置了粘滞位后，只有以下用户有权删除或重命名该目录中的文件：<ol><li>文件的所有者（<code>User Owner</code>）</li><li>目录的所有者（<code>Directory Owner</code>）</li><li><code>root</code> 用户</li></ol></li><li>粘滞位仅控制文件删除或重命名，不影响文件内容的读写</li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># / 根目录下对于other用户是没有w权限的，也就不能新建目录/文件，只有root账户可以</span></span><br><span class="line">[wyf@hcss-ecs-0be3 /]$ <span class="built_in">ls</span> -ld /</span><br><span class="line">dr-xr-xr-x. 20 root root 4096 Apr 12 17:38 /</span><br><span class="line">[wyf@hcss-ecs-0be3 /]$ <span class="built_in">sudo</span> <span class="built_in">mkdir</span> share_dir</span><br><span class="line">[wyf@hcss-ecs-0be3 /]$ <span class="built_in">ls</span> -ld share_dir/</span><br><span class="line">drwxr-xr-x 2 root root 4096 Apr 12 17:38 share_dir/</span><br><span class="line">[wyf@hcss-ecs-0be3 /]$ <span class="built_in">cd</span> share_dir/</span><br><span class="line"><span class="comment"># 不对other用户开放w权限，就不能在这个目录下新建目录/文件</span></span><br><span class="line">[wyf@hcss-ecs-0be3 share_dir]$ <span class="built_in">echo</span> <span class="string">&quot;Hello&quot;</span> &gt; share.txt</span><br><span class="line">-bash: share.txt: Permission denied</span><br><span class="line">[wyf@hcss-ecs-0be3 share_dir]$ <span class="built_in">cd</span> ..</span><br><span class="line">[wyf@hcss-ecs-0be3 /]$ <span class="built_in">sudo</span> <span class="built_in">chmod</span> o+w share_dir/</span><br><span class="line">[wyf@hcss-ecs-0be3 /]$ <span class="built_in">cd</span> share_dir/</span><br><span class="line">[wyf@hcss-ecs-0be3 share_dir]$ <span class="built_in">echo</span> <span class="string">&quot;Hello&quot;</span> &gt; share.txt</span><br><span class="line">[wyf@hcss-ecs-0be3 share_dir]$ <span class="built_in">ls</span> -l</span><br><span class="line">total 4</span><br><span class="line">-rw-rw-r-- 1 wyf wyf 6 Apr 12 17:40 share.txt</span><br><span class="line"><span class="comment"># 将要让其共享文件的用户设置为grop用户，并且让other用户不能读写该文件</span></span><br><span class="line">[wyf@hcss-ecs-0be3 share_dir]$ <span class="built_in">sudo</span> <span class="built_in">chgrp</span> VS share.txt </span><br><span class="line">[wyf@hcss-ecs-0be3 share_dir]$ <span class="built_in">chmod</span> o-rwx share.txt </span><br><span class="line">[wyf@hcss-ecs-0be3 share_dir]$ <span class="built_in">ls</span> -l</span><br><span class="line">total 4</span><br><span class="line">-rw-rw---- 1 wyf VS 10 Apr 12 17:41 share.txt</span><br><span class="line"><span class="comment"># 切换成对应的用户后依然能够共享文件</span></span><br><span class="line">[wyf@hcss-ecs-0be3 share_dir]$ su VS</span><br><span class="line">Password: </span><br><span class="line">[VS@hcss-ecs-0be3 share_dir]$ <span class="built_in">cat</span> share.txt </span><br><span class="line">Hello</span><br><span class="line">[VS@hcss-ecs-0be3 share_dir]$ <span class="built_in">echo</span> <span class="string">&quot;Hey&quot;</span> &gt;&gt; share.txt </span><br><span class="line">[VS@hcss-ecs-0be3 share_dir]$ <span class="built_in">exit</span></span><br><span class="line"><span class="comment"># 再次打开文件都能看到双方写入的内容</span></span><br><span class="line">[wyf@hcss-ecs-0be3 share_dir]$ <span class="built_in">cat</span> share.txt </span><br><span class="line">Hello</span><br><span class="line">Hey</span><br><span class="line"><span class="comment"># 切换成other用户，不能看也不能写，但却可以删除</span></span><br><span class="line">[wyf@hcss-ecs-0be3 share_dir]$ su zs</span><br><span class="line">Password: </span><br><span class="line">[zs@hcss-ecs-0be3 share_dir]$ <span class="built_in">cat</span> share.txt </span><br><span class="line"><span class="built_in">cat</span>: share.txt: Permission denied</span><br><span class="line">[zs@hcss-ecs-0be3 share_dir]$ <span class="built_in">echo</span> &gt;&gt; <span class="string">&quot;hello&quot;</span> &gt;&gt; share.txt </span><br><span class="line">bash: share.txt: Permission denied</span><br><span class="line">[zs@hcss-ecs-0be3 share_dir]$ <span class="built_in">rm</span> share.txt </span><br><span class="line"><span class="built_in">rm</span>: remove write-protected regular file ‘share.txt’? y</span><br><span class="line">[zs@hcss-ecs-0be3 share_dir]$ ll</span><br><span class="line">total 0</span><br><span class="line">[zs@hcss-ecs-0be3 share_dir]$ <span class="built_in">exit</span></span><br><span class="line">[wyf@hcss-ecs-0be3 share_dir]$ ll</span><br><span class="line">total 0</span><br><span class="line">[wyf@hcss-ecs-0be3 share_dir]$ <span class="built_in">cd</span> ..</span><br><span class="line">[wyf@hcss-ecs-0be3 /]$ <span class="built_in">ls</span> -ld share_dir/</span><br><span class="line">drwxr-xrwx 2 root root 4096 Apr 12 17:44 share_dir/</span><br><span class="line">[wyf@hcss-ecs-0be3 /]$ tree share_dir/</span><br><span class="line">share_dir/</span><br><span class="line"></span><br><span class="line">0 directories, 0 files</span><br><span class="line">[wyf@hcss-ecs-0be3 /]$ </span><br></pre></td></tr></table></figure><h3 id="3-2-设置粘滞位"><a href="#3-2-设置粘滞位" class="headerlink" title="3.2 设置粘滞位"></a>3.2 设置粘滞位</h3><p><strong>符号模式</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">chmod</span> +t /shared_dir      <span class="comment"># 添加粘滞位</span></span><br><span class="line"><span class="built_in">chmod</span> -t /shared_dir      <span class="comment"># 移除粘滞位</span></span><br></pre></td></tr></table></figure><p><strong>数字模式</strong><br>粘滞位对应的八进制值为 <code>1</code>(如 <code>1777</code>)</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">chmod</span> 1777 /shared_dir    <span class="comment"># 设置粘滞位 + 所有人可读写执行</span></span><br></pre></td></tr></table></figure><ul><li><code>t</code> 或 <code>T</code>：表示已设置粘滞位。<ul><li>小写 <code>t</code>：粘滞位 + 其他用户有执行权限(如 <code>rwxrwxrwt</code>)</li><li>大写 <code>T</code>：粘滞位 + 其他用户无执行权限(如 <code>rwxrwx--T</code>)</li></ul></li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">[wyf@hcss-ecs-0be3 /]$ <span class="built_in">sudo</span> <span class="built_in">mkdir</span> share</span><br><span class="line"><span class="comment"># 让other用户共享该目录</span></span><br><span class="line">[wyf@hcss-ecs-0be3 /]$ <span class="built_in">sudo</span> <span class="built_in">chmod</span> o+w share</span><br><span class="line"><span class="comment"># 给share文件设置粘滞位</span></span><br><span class="line">[wyf@hcss-ecs-0be3 /]$ <span class="built_in">sudo</span> <span class="built_in">chmod</span> +t share</span><br><span class="line">[wyf@hcss-ecs-0be3 /]$ <span class="built_in">ls</span> -ld share</span><br><span class="line">drwxr-xrwt 2 root root 4096 Apr 12 18:03 share</span><br><span class="line">[wyf@hcss-ecs-0be3 /]$ <span class="built_in">cd</span> share</span><br><span class="line">[wyf@hcss-ecs-0be3 share]$ <span class="built_in">echo</span> <span class="string">&quot;Hello&quot;</span> &gt; share.txt</span><br><span class="line">[wyf@hcss-ecs-0be3 share]$ ll</span><br><span class="line">total 4</span><br><span class="line">-rw-rw-r-- 1 wyf wyf 6 Apr 12 18:05 share.txt</span><br><span class="line">[wyf@hcss-ecs-0be3 share]$ <span class="built_in">sudo</span> <span class="built_in">chgrp</span> VS share.txt</span><br><span class="line">[wyf@hcss-ecs-0be3 share]$ <span class="built_in">chmod</span> o-rwx share.txt </span><br><span class="line">[wyf@hcss-ecs-0be3 share]$ ll</span><br><span class="line">total 4</span><br><span class="line">-rw-rw---- 1 wyf VS 6 Apr 12 18:05 share.txt</span><br><span class="line">[wyf@hcss-ecs-0be3 share]$ su VS</span><br><span class="line">Password: </span><br><span class="line">[VS@hcss-ecs-0be3 share]$ <span class="built_in">echo</span> <span class="string">&quot;Hey&quot;</span> &gt;&gt; share.txt </span><br><span class="line">[VS@hcss-ecs-0be3 share]$ <span class="built_in">cat</span> share.txt </span><br><span class="line">Hello</span><br><span class="line">Hey</span><br><span class="line">[VS@hcss-ecs-0be3 share]$ <span class="built_in">exit</span></span><br><span class="line">[wyf@hcss-ecs-0be3 share]$ su zs</span><br><span class="line">Password: </span><br><span class="line"><span class="comment"># 不能读</span></span><br><span class="line">[zs@hcss-ecs-0be3 share]$ <span class="built_in">cat</span> share.txt </span><br><span class="line"><span class="built_in">cat</span>: share.txt: Permission denied</span><br><span class="line"><span class="comment"># 不能写</span></span><br><span class="line">[zs@hcss-ecs-0be3 share]$ <span class="built_in">echo</span> <span class="string">&quot;hello&quot;</span> &gt;&gt; share.txt </span><br><span class="line">bash: share.txt: Permission denied</span><br><span class="line"><span class="comment"># 不能删除</span></span><br><span class="line">[zs@hcss-ecs-0be3 share]$ <span class="built_in">rm</span> -rf share.txt </span><br><span class="line"><span class="built_in">rm</span>: cannot remove ‘share.txt’: Operation not permitted</span><br><span class="line">[zs@hcss-ecs-0be3 share]$ <span class="built_in">rm</span>  share.txt </span><br><span class="line"><span class="built_in">rm</span>: remove write-protected regular file ‘share.txt’? y</span><br><span class="line"><span class="built_in">rm</span>: cannot remove ‘share.txt’: Operation not permitted</span><br><span class="line">[zs@hcss-ecs-0be3 share]$ <span class="built_in">exit</span></span><br><span class="line"><span class="comment"># 只能由所有者删除</span></span><br><span class="line">[wyf@hcss-ecs-0be3 share]$ <span class="built_in">rm</span> share.txt </span><br><span class="line">[wyf@hcss-ecs-0be3 share]$ ll</span><br><span class="line">total 0</span><br><span class="line">[wyf@hcss-ecs-0be3 share]$ </span><br></pre></td></tr></table></figure>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Linux基础开发工具</title>
      <link href="/2025/11/19/Linux%E5%9F%BA%E7%A1%80%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/"/>
      <url>/2025/11/19/Linux%E5%9F%BA%E7%A1%80%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h2 id="基础开发工具"><a href="#基础开发工具" class="headerlink" title="基础开发工具"></a>基础开发工具</h2><h3 id="1-软件包管理器"><a href="#1-软件包管理器" class="headerlink" title="1. 软件包管理器"></a>1. 软件包管理器</h3><h4 id="1-1-Linux软件安装发展过程"><a href="#1-1-Linux软件安装发展过程" class="headerlink" title="1.1 Linux软件安装发展过程"></a>1.1 Linux软件安装发展过程</h4><ul><li>最初，开源社区完全依赖手动编译源码的方式获取软件，用户需自行下载压缩包、解决依赖关系并执行编译安装，这种方式虽高度灵活却效率低下，尤其在处理复杂的依赖链时举步维艰(现在使用的 <code>Makefile</code> 就是当时的遗留痕迹)</li><li>随着 <code>Linux</code> 发行版的兴起，<code>1990</code> 年代中期诞生的静态软件包（如 <code>Debian</code> 的 <code>deb</code> 和 <code>Red Hat</code> 的 <code>rpm</code>）首次引入元数据概念，通过预编译二进制文件和基础依赖描述简化了安装流程，但依赖冲突问题仍未彻底解决</li><li><code>1998</code> 年 <code>APT</code> 与 <code>2003</code> 年 <code>YUM</code> 等智能包管理器的出现，标志着依赖解析技术的突破，它们通过算法自动下载所需依赖包，并建立本地软件数据库，实现了软件安装、升级、卸载的全生命周期管理</li><li>进入21世纪后，软件生态的复杂化催生了容器化革命，<code>Docker</code> 等工具通过封装应用及其完整运行环境，以镜像形式实现跨平台的标准化部署，彻底解决了”在我机器上能运行”的经典难题</li></ul><h4 id="1-2-软件包和软件包管理器"><a href="#1-2-软件包和软件包管理器" class="headerlink" title="1.2 软件包和软件包管理器"></a>1.2 软件包和软件包管理器</h4><p><strong>软件包</strong>：预编译的应用程序及其数据，包括：二进制文件、配置文件、安装&#x2F;卸载脚本等。常见的软件包格式有 </p><ul><li>Debian&#x2F;Ubuntu：<code>.deb</code></li><li>RHEL&#x2F;Fedora：<code>.rpm</code></li><li>Arch Linux：<code>.pkg</code><br><strong>软件包管理器</strong>：类似于手机上的应用商店，具有自动处理软件包之间的依赖关系、支持多版本共存与升级回滚、验证软件包来源等功能。常见的软件包管理器有：</li><li><code>Debian</code>&#x2F;<code>Ubuntu</code>：<code>APT</code>(<code>Advanced Package Tool</code>)</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">apt update                  <span class="comment"># 刷新仓库索引</span></span><br><span class="line">apt install nginx           <span class="comment"># 安装软件包</span></span><br><span class="line">apt remove --purge nginx    <span class="comment"># 完全卸载</span></span><br><span class="line">apt-cache show nginx        <span class="comment"># 查看包信息</span></span><br></pre></td></tr></table></figure><ul><li><code>RHEL</code>&#x2F;<code>Fedora</code>：<code>DNF</code>&#x2F;<code>YUM</code></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dnf makecache               <span class="comment"># 生成元数据缓存</span></span><br><span class="line">dnf install httpd           <span class="comment"># 安装软件包</span></span><br><span class="line">yum install httpd</span><br><span class="line">yum update</span><br></pre></td></tr></table></figure><ul><li><code>Arch Linux</code>：<code>Pacman</code></li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pacman -Syu                 <span class="comment"># 升级全部软件包</span></span><br><span class="line">pacman -Qs ^linux           <span class="comment"># 正则搜索本地包</span></span><br><span class="line">pacman -U package.pkg.tar.zst <span class="comment"># 手动安装本地包</span></span><br></pre></td></tr></table></figure><p>查看软件包(<code>lrzsz</code> 是一个方便 <code>Linux</code> 服务器与本地之间进行小文件传输的工具)</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ apt search lrzsz</span><br><span class="line">Sorting... Done</span><br><span class="line">Full Text Search... Done</span><br><span class="line">cutecom/noble 0.51.0-1build2 amd64</span><br><span class="line">  Graphical serial terminal, like minicom</span><br><span class="line"></span><br><span class="line">lrzsz/noble,now 0.12.21-11build1 amd64 [installed]</span><br><span class="line">  Tools <span class="keyword">for</span> zmodem/xmodem/ymodem file transfer</span><br><span class="line"></span><br><span class="line">$ </span><br></pre></td></tr></table></figure><p>注：</p><ul><li><code>yum</code>&#x2F;<code>apt</code> 安装软件时只能一个装完再装另一个，正在 <code>yum</code>&#x2F;<code>apt</code> 安装软件时，在尝试使用 <code>yum</code>&#x2F;<code>apt</code> 安装另一个软件会报错</li></ul><h4 id="1-3-安装源"><a href="#1-3-安装源" class="headerlink" title="1.3 安装源"></a>1.3 安装源</h4><p><strong>安装源</strong>（软件仓库&#x2F;软件源）是操作系统获取软件包的核心渠道。不同发行版使用不同的包管理工具和配置文件，但核心逻辑类似</p><p>安装源类型</p><ul><li>官方仓库：由发行版维护，稳定性高(如 <code>Ubuntu</code> 的 <code>main</code>、<code>CentOS</code> 的 <code>base</code>)</li><li>第三方仓库：<code>PPA</code>(<code>Ubuntu</code>)：个人打包的软件集合(<code>ppa</code>:<code>user</code>&#x2F;<code>repo</code>)、<code>EPEL</code>(<code>CentOS</code>)：扩展包仓库</li><li>本地仓库：通过 <code>ISO</code> 镜像或本地路径安装(适用于无网络环境)</li><li>网络镜像：加速下载的镜像站点(如清华、中科大镜像源)<br> <code>Ubuntu</code> 下的 <code>APT</code> 安装源配置文件</li></ul><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cat</span> /etc/apt/sources.list.d/ubuntu.sources </span><br><span class="line">Types: deb</span><br><span class="line">URIs: http://repo.huaweicloud.com/ubuntu</span><br><span class="line">Suites: noble noble-updates noble-backports</span><br><span class="line">Components: main restricted universe multiverse</span><br><span class="line">Signed-By: /usr/share/keyrings/ubuntu-archive-keyring.gpg</span><br><span class="line"></span><br><span class="line">Types: deb</span><br><span class="line">URIs: http://repo.huaweicloud.com/ubuntu</span><br><span class="line">Suites: noble-security</span><br><span class="line">Components: main restricted universe multiverse</span><br><span class="line">Signed-By: /usr/share/keyrings/ubuntu-archive-keyring.gpg</span><br><span class="line">$ </span><br></pre></td></tr></table></figure><h3 id="2-编辑器vim"><a href="#2-编辑器vim" class="headerlink" title="2. 编辑器vim"></a>2. 编辑器vim</h3><p><code>Vim(Vi IMproved)</code> 是一款高度可定制、跨平台的文本编辑器，是经典 <code>Unix</code> 编辑器 <code>Vi</code> 的增强版</p><p><code>Vim</code>（<strong>Vi IMproved</strong>）是一款高度可定制、跨平台的文本编辑器，是经典 <code>Unix</code> 编辑器 <strong><code>Vi</code></strong> 的增强版。它以<strong>键盘操作</strong>为核心，凭借高效的工作流和强大的扩展性，成为开发者、系统管理员等技术人员的常用工具</p><p><strong>核心特点</strong></p><ol><li><p><strong>模式化编辑</strong>：</p><ul><li><strong>普通模式（Normal Mode）</strong>：移动光标、执行命令（默认进入的模式）</li><li><strong>插入模式（Insert Mode）</strong>：输入文本（按 <code>i</code> 进入，<code>Esc</code> 返回普通模式）</li><li><strong>可视模式（Visual Mode）</strong>：选择文本块（按 <code>v</code> 进入）</li><li><strong>命令行模式（Command-line Mode）</strong>：执行保存、退出等命令（按 <code>:</code> 进入）</li></ul><!-- - ![1748252856439](image/基础开发工具/1748252856439.png) --><ul><li><img src="/2025/11/19/Linux%E5%9F%BA%E7%A1%80%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/1748252856439.png" class=""></li></ul></li><li><p><strong>跨平台支持</strong>：</p><ul><li>支持 <code>Linux</code>、<code>macOS</code>、<code>Windows</code> 等主流操作系统</li></ul></li><li><p><strong>高效操作</strong>：</p><ul><li>通过组合键（如 <code>d</code> + <code>w</code> 删除单词）实现快速编辑，减少鼠标依赖</li></ul></li><li><p><strong>可扩展性</strong>：</p><ul><li>支持插件（如代码补全、语法检查）和自定义配置（通过 <code>.vimrc</code> 文件）</li></ul></li></ol><h4 id="2-1-vim-的核心操作"><a href="#2-1-vim-的核心操作" class="headerlink" title="2.1 vim 的核心操作"></a>2.1 vim 的核心操作</h4><p>输入 <code>vim &lt;文件名&gt;</code>，就进入 <code>vim</code> 全屏编辑页面<br><code>vim text.txt</code></p><ul><li>进入 <code>vim</code> 之后，处于普通模式下，要切换到插入模式才能输入</li><li><strong>Esc 是万能钥匙：</strong> 在插入模式、视图模式、替换模式、命令行模式(取消输入时)下按 <code>Esc</code> 总是回到普通模式</li><li>退出 <code>vim</code> 时，输入 <code>:</code><ul><li><code>:w</code> 保存当前文件</li><li><code>:wq</code> 保存并退出 <code>vim</code></li><li><code>:q!</code> 不保存强制退出 <code>vim</code></li></ul></li></ul><h4 id="2-2-vim-命令"><a href="#2-2-vim-命令" class="headerlink" title="2.2 vim 命令"></a>2.2 vim 命令</h4><h5 id="2-2-1-模式转换"><a href="#2-2-1-模式转换" class="headerlink" title="2.2.1 模式转换"></a>2.2.1 模式转换</h5><p><strong>从普通模式 -&gt; 插入模式</strong></p><ul><li><code>i</code>: 在<strong>光标前</strong>插入 (<code>insert before cursor</code>)</li><li><code>a</code>: 在<strong>光标后</strong>插入 (<code>append after cursor</code>)</li><li><code>I</code>: 在<strong>行首</strong>插入 (<code>Insert at beginning of line</code>)</li><li><code>A</code>: 在<strong>行尾</strong>插入 (<code>Append at end of line</code>)</li><li><code>o</code>: 在<strong>当前行下方</strong>插入一个新行并进入插入模式 (<code>Open a new line below</code>)</li><li><code>O</code>: 在<strong>当前行上方</strong>插入一个新行并进入插入模式 (<code>Open a new line above</code>)</li><li><code>c</code> + <code>动作</code>： 更改文本（删除指定范围的文本并进入插入模式）。例如 <code>cw</code> 更改一个单词， <code>c$</code> 更改到行尾</li><li><code>s</code>: 删除<strong>当前字符</strong>并进入插入模式 (<code>substitute character</code>)</li><li><code>S</code>: 删除<strong>整行</strong>并进入插入模式 (<code>Substitute line</code>)</li><li><code>C</code>: 删除<strong>从光标到行尾</strong>的文本并进入插入模式 (<code>Change to end of line</code>)</li></ul><p><strong>普通模式  -&gt; 可视化选择模式</strong></p><ul><li><strong>字符视图模式 (Visual Mode):</strong> 按字符选择文本。按 <code>v</code> 进入。这是最常用的视图模式</li><li><strong>行视图模式 (Visual Line Mode):</strong> 按整行选择文本。按 <code>V</code> (大写) 进入。适合操作整行</li><li><strong>块视图模式 (Visual Block Mode):</strong> 按矩形块选择文本（列选择）。按 <code>Ctrl+v</code> 进入。非常适合在多行文本的相同位置进行编辑（例如同时注释多行代码）</li><li><strong>如何进入 (从普通模式)：</strong> <code>v</code>, <code>V</code>, <code>Ctrl+v</code></li><li><strong>如何操作：</strong> 进入后，使用<strong>移动命令</strong>（<code>h</code>, <code>j</code>, <code>k</code>, <code>l</code>, <code>w</code>, <code>b</code>, <code>&#125;</code>, <code>0</code>, <code>$</code>, <code>gg</code>, <code>G</code> 等）来扩展或缩小选择区域</li><li><strong>如何执行命令：</strong> 选择好文本后，按一个<strong>操作命令</strong>，<code>Vim</code> 会像在普通模式下一样执行该命令，但<strong>作用范围仅限于选中的文本</strong>。常用操作：<ul><li><code>d</code> &#x2F; <code>x</code>: 删除选中文本 (<code>Cut</code>)</li><li><code>y</code>: 复制选中文本 (<code>Yank</code>&#x2F;<code>Copy</code>)</li><li><code>c</code>: 更改选中文本（删除并进入插入模式）</li><li><code>&gt;</code>: 向右缩进选中文本</li><li><code>&lt;</code>: 向左缩进选中文本</li><li><code>~</code>: 切换选中文本的大小写</li><li><code>u</code>: 将选中文本转为小写</li><li><code>U</code>: 将选中文本转为大写</li><li><code>:</code>: 对选中文本执行命令行命令（例如 <code>:&#39;&lt;,&#39;&gt;s/old/new/g</code> 在选中范围内替换）</li></ul></li></ul><p><strong>普通模式  -&gt; 命令行模式</strong></p><ul><li><code>:</code> 按 <code>:</code> (冒号)。光标会移动到屏幕底部，出现 <code>:</code> 提示符</li><li>文件操作：<code>:w</code> (保存), <code>:w filename</code> (另存为), <code>:q</code> (退出), <code>:q!</code> (不保存强制退出), <code>:wq</code> 或 <code>:x</code> (保存并退出), <code>:e filename</code> (打开另一个文件)</li><li>搜索和替换：<code>:/pattern</code> (向下搜索), <code>:?pattern</code> (向上搜索), <code>:%s/old/new/g</code> (全局替换), <code>:%s/old/new/gc</code> (全局替换并确认)</li><li>设置选项：<code>:set number</code> (显示行号), <code>:set nonumber</code> (隐藏行号), <code>:set hlsearch</code> (高亮搜索结果), <code>:set nohlsearch</code> (取消高亮)</li><li>执行外部命令：<code>:!command</code> (如 <code>:!ls</code>, <code>:!gcc %</code> 编译当前文件)</li><li>其他高级操作：<code>:split</code> (水平分屏), <code>:vsplit</code> (垂直分屏), <code>:tabnew</code> (新建标签页), <code>:help</code> (查看帮助)</li></ul><p><strong>普通模式 -&gt; 替换模式 (Replace Mode)</strong></p><ul><li>一种特殊的插入模式</li><li><strong>作用：</strong> <strong>覆盖 (替换) 已有的文本</strong>，而不是插入新文本。按一个键，会<strong>删除光标下的字符</strong>，然后插入你按的字符</li><li><code>R</code>: 进入<strong>连续替换模式</strong>。之后输入的字符会逐个覆盖后面的原有字符</li><li><code>r</code>: 后跟<strong>一个字符</strong>。仅替换<strong>当前光标下的一个字符</strong>，然后<strong>自动回到普通模式</strong>（<code>r</code> 本身不是模式，是一个命令）</li></ul><h5 id="2-2-2-常见命令"><a href="#2-2-2-常见命令" class="headerlink" title="2.2.2   常见命令"></a>2.2.2   常见命令</h5><p><strong>主要在普通模式下(按下就会执行)</strong></p><ul><li><code>d</code> &#x2F; <code>x</code>: 删除选中文本 (<code>Cut</code>)</li><li><code>y</code>: 复制选中文本 (<code>Yank</code>&#x2F;<code>Copy</code>)</li><li><code>c</code>: 更改选中文本（删除并进入插入模式）</li><li><code>&gt;</code>: 向右缩进选中文本</li><li><code>&lt;</code>: 向左缩进选中文本</li><li><code>~</code>: 切换选中文本的大小写</li><li><code>u</code>: 将选中文本转为小写</li><li><code>U</code>: 将选中文本转为大写</li><li><code>:</code>: 对选中文本执行命令行命令（例如 <code>:&#39;&lt;,&#39;&gt;s/old/new/g</code> 在选中范围内替换）</li></ul><p><strong>移动 (Navigation):</strong></p><ul><li><code>h</code> &#x2F; <code>←</code>: 左移</li><li><code>j</code> &#x2F; <code>↓</code>: 下移一行</li><li><code>k</code> &#x2F; <code>↑</code>: 上移一行</li><li><code>l</code> &#x2F; <code>→</code>: 右移</li><li><code>w</code> &#x2F; <code>W</code>: 移动到下一个单词&#x2F;大词 (词首)</li><li><code>b</code> &#x2F; <code>B</code>: 移动到上一个单词&#x2F;大词 (词首)</li><li><code>e</code> &#x2F; <code>E</code>: 移动到下一个单词&#x2F;大词 (词尾)</li><li><code>0</code> &#x2F; <code>^</code> &#x2F; <code>$</code>: 移动到行首 &#x2F; 行首第一个非空白字符 &#x2F; 行尾</li><li><code>gg</code>: 移动到文件第一行</li><li><code>G</code>: 移动到文件最后一行</li><li><code>:[行号]</code> + <code>Enter</code>: 跳转到指定行号 (e.g, <code>:42</code> 跳到第 <code>42</code> 行)</li><li><code>Ctrl+f</code> &#x2F; <code>Page Down</code>: 向下翻一页</li><li><code>Ctrl+b</code> &#x2F; <code>Page Up</code>: 向上翻一页</li><li><code>Ctrl+d</code> &#x2F; <code>Ctrl+u</code>: 向下&#x2F;向上翻半页</li><li><code>%</code>: 在匹配的括号 (<code>()</code>, <code>&#123;&#125;</code>, <code>[]</code>) 间跳转</li><li><code>f[字符]</code> &#x2F; <code>F[字符]</code> &#x2F; <code>t[字符]</code> &#x2F; <code>T[字符]</code>: 在当前行查找字符并移动 (<code>f</code> 到字符上, <code>t</code> 到字符前, 大写表示反向)</li></ul><p><strong>编辑 (Editing):</strong></p><ul><li><code>i</code> &#x2F; <code>a</code> &#x2F; <code>o</code> &#x2F; <code>O</code> &#x2F; <code>I</code> &#x2F; <code>A</code> &#x2F; <code>s</code> &#x2F; <code>S</code> &#x2F; <code>c</code> &#x2F; <code>C</code>: 进入插入模式 (见上文)</li><li><code>x</code> &#x2F; <code>dl</code>: 删除光标下的字符 (相当于 <code>Del</code>)</li><li><code>X</code> &#x2F; <code>dh</code>: 删除光标前的字符 (相当于 <code>Backspace</code>)</li><li><code>d[动作]</code>: 删除 (<code>Cut</code>) 文本 (<code>e.g</code>, <code>dw</code> 删一个单词, <code>d$</code> &#x2F; <code>D</code> 删到行尾, <code>dd</code> 删整行, <code>dG</code> 删到文件尾)</li><li><code>y[动作]</code>: 复制 (<code>Yank</code>) 文本 (<code>e.g</code>, <code>yw</code> 复制一个单词, <code>y$</code> 复制到行尾, <code>yy</code> &#x2F; <code>Y</code> 复制整行, <code>yG</code> 复制到文件尾)</li><li><code>p</code>: 在光标<strong>后</strong>粘贴 (小写 <code>p</code>)</li><li><code>P</code>: 在光标<strong>前</strong>粘贴 (大写 <code>P</code>)</li><li><code>u</code>: 撤销 (<code>Undo</code>)</li><li><code>Ctrl+r</code>: 重做 (<code>Redo</code>) 撤销的操作</li><li><code>.</code> (点): <strong>重复上一个编辑操作 (非常强大！)</strong></li><li><code>r[字符]</code>: 替换当前光标下的一个字符 (单个字符替换命令)</li><li><code>R</code>: 进入替换模式 (连续替换)</li><li><code>~</code>: 切换当前光标下字符的大小写</li></ul><p><strong>搜索与替换 (Search &amp; Replace):</strong></p><ul><li><code>/pattern</code>: 向下搜索 <code>pattern</code> (正则表达式)</li><li><code>?pattern</code>: 向上搜索 <code>pattern</code></li><li><code>n</code>: 重复上一次搜索，相同方向</li><li><code>N</code>: 重复上一次搜索，相反方向</li><li><code>:%s/old/new/g</code>: 在整个文件中 (<code>%</code>) 将所有 <code>old</code> 替换为 <code>new</code> (<code>global</code>)</li><li><code>:%s/old/new/gc</code>: 同上，但每次替换前询问确认 (<code>confirm</code>)</li><li><code>:[行范围]s/old/new/g</code>: 在指定行范围内替换 (e.g., <code>:10,20s/foo/bar/g</code> 在 <code>10-20</code> 行替换)</li></ul><p><strong>文件与窗口 (File &amp; Window):</strong></p><ul><li><code>:w</code>: 保存文件</li><li><code>:w filename</code>: 另存为 <code>filename</code></li><li><code>:q</code>: 退出 <code>Vim</code> (如果文件未修改)</li><li><code>:q!</code>: 不保存强制退出</li><li><code>:wq</code> &#x2F; <code>:x</code> &#x2F; <code>ZZ</code> (普通模式): 保存并退出</li><li><code>:e filename</code>: 编辑另一个文件 <code>filename</code></li><li><code>:split</code> &#x2F; <code>:sp [filename]</code>: 水平分割窗口 (打开 <code>filename</code> 或当前文件)</li><li><code>:vsplit</code> &#x2F; <code>:vsp [filename]</code>: 垂直分割窗口</li><li><code>Ctrl+w</code> + <code>方向键</code> &#x2F; <code>h</code>&#x2F;<code>j</code>&#x2F;<code>k</code>&#x2F;<code>l</code>: 在窗口间切换</li><li><code>Ctrl+w</code> + <code>c</code>: 关闭当前窗口</li><li><code>:tabnew [filename]</code>: 在新标签页打开文件</li><li><code>gt</code> &#x2F; <code>gT</code>: 切换到下一个 &#x2F; 上一个标签页</li><li><code>:tabn</code> &#x2F; <code>:tabp</code>: 同上 (命令形式)</li></ul><p><strong>其他实用命令:</strong></p><ul><li><code>:set number</code> &#x2F; <code>:set nu</code>: 显示行号</li><li><code>:set nonumber</code> &#x2F; <code>:set nonu</code>: 隐藏行号</li><li><code>:set hlsearch</code> &#x2F; <code>:set hls</code>: 高亮所有搜索结果</li><li><code>:set nohlsearch</code> &#x2F; <code>:set nohls</code>: 关闭搜索结果高亮</li><li><code>:nohlsearch</code> &#x2F; <code>:noh</code>: 临时关闭当前搜索的高亮 (直到下次搜索)</li><li><code>:help [topic]</code>: 查看帮助 (<code>e.g</code>, <code>:help w</code>, <code>:help :w</code>)</li><li><code>Ctrl+g</code> &#x2F; <code>:f</code> &#x2F; <code>Ctrl+g</code>: 在底部显示当前文件名和光标位置信息</li><li><code>#</code> : <code>#</code> 表示一个数字，在冒号后输入一个数字，再回车，就会跳转到对应的行数</li></ul><h4 id="2-3-vim的简单配置"><a href="#2-3-vim的简单配置" class="headerlink" title="2.3 vim的简单配置"></a>2.3 vim的简单配置</h4><p><strong>步骤 1：创建配置文件</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Linux/macOS</span></span><br><span class="line"><span class="built_in">touch</span> ~/.vimrc</span><br></pre></td></tr></table></figure><p><strong>步骤 2：安装插件管理器 (vim-plug)</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Linux/macOS</span></span><br><span class="line">curl -fLo ~/.vim/autoload/plug.vim --create-dirs \</span><br><span class="line">https://raw.githubusercontent.com/junegunn/vim-plug/master/plug.vim</span><br></pre></td></tr></table></figure><p><strong>步骤 3：编辑配置文件</strong><br>打开 <code>~/.vimrc</code> (<code>Linux</code>&#x2F;<code>macOS</code>)，复制以下内容：</p><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">&quot; === 基础设置 ===</span></span><br><span class="line"><span class="keyword">set</span> <span class="keyword">number</span>              <span class="comment">&quot; 显示行号</span></span><br><span class="line"><span class="keyword">set</span> tabstop=<span class="number">4</span>           <span class="comment">&quot; Tab宽度=4空格</span></span><br><span class="line"><span class="keyword">set</span> expandtab           <span class="comment">&quot; Tab转空格</span></span><br><span class="line"><span class="keyword">syntax</span> <span class="keyword">on</span>               <span class="comment">&quot; 语法高亮</span></span><br><span class="line"><span class="keyword">set</span> mouse=<span class="keyword">a</span>             <span class="comment">&quot; 启用鼠标</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&quot; === 插件管理 ===</span></span><br><span class="line"><span class="keyword">call</span> plug#begin(<span class="string">&#x27;~/.vim/plugged&#x27;</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">&quot; 必备插件</span></span><br><span class="line">Plug <span class="string">&#x27;preservim/nerdtree&#x27;</span>        <span class="comment">&quot; 文件树</span></span><br><span class="line">Plug <span class="string">&#x27;vim-airline/vim-airline&#x27;</span>    <span class="comment">&quot; 状态栏</span></span><br><span class="line">Plug <span class="string">&#x27;tpope/vim-commentary&#x27;</span>       <span class="comment">&quot; 快速注释</span></span><br><span class="line">Plug <span class="string">&#x27;kien/ctrlp.vim&#x27;</span>             <span class="comment">&quot; 模糊搜索</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">call</span> plug#end()</span><br><span class="line"></span><br><span class="line"><span class="comment">&quot; === 插件配置 ===</span></span><br><span class="line"><span class="comment">&quot; NERDTree 文件树</span></span><br><span class="line"><span class="keyword">map</span> <span class="symbol">&lt;C-n&gt;</span> :NERDTreeToggle<span class="symbol">&lt;CR&gt;</span>     <span class="comment">&quot; Ctrl+n 开关</span></span><br><span class="line"><span class="keyword">let</span> NERDTreeShowHidden=<span class="number">1</span>           <span class="comment">&quot; 显示隐藏文件</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&quot; 快速注释</span></span><br><span class="line"><span class="keyword">nmap</span> gcc :Commentary<span class="symbol">&lt;CR&gt;</span>          <span class="comment">&quot; gcc 注释当前行</span></span><br><span class="line"><span class="keyword">vmap</span> gc :Commentary<span class="symbol">&lt;CR&gt;</span>           <span class="comment">&quot; 可视化模式注释选中行</span></span><br><span class="line"></span><br><span class="line"><span class="comment">&quot; CtrlP 模糊搜索</span></span><br><span class="line"><span class="keyword">let</span> <span class="variable">g:ctrlp_map</span> = <span class="string">&#x27;&lt;c-p&gt;&#x27;</span>          <span class="comment">&quot; Ctrl+p 搜索文件</span></span><br></pre></td></tr></table></figure><p><strong>步骤 4：安装插件</strong></p><ol><li>打开 <code>Vim</code></li><li>执行命令：</li></ol><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">:PlugInstall</span><br></pre></td></tr></table></figure><blockquote><p>等待插件安装完成（状态栏显示 “Done”）</p></blockquote><p><strong>步骤 5：常用操作</strong></p><table><thead><tr><th>功能</th><th>快捷键&#x2F;命令</th></tr></thead><tbody><tr><td>打开文件树</td><td><code>Ctrl + n</code></td></tr><tr><td>注释当前行</td><td><code>gcc</code></td></tr><tr><td>搜索文件</td><td><code>Ctrl + p</code></td></tr><tr><td>保存文件</td><td><code>:w</code></td></tr><tr><td>退出 Vim</td><td><code>:q</code></td></tr><tr><td>重载配置</td><td><code>:source ~/.vimrc</code></td></tr></tbody></table><p><strong>选择主题</strong></p><ol><li>在 <code>call plug#begin</code> 后添加：</li></ol><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Plug <span class="string">&#x27;joshdick/onedark.vim&#x27;</span>   <span class="comment">&quot; 主题插件</span></span><br></pre></td></tr></table></figure><ol><li>在文件末尾添加：</li></ol><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">colorscheme</span> onedark           <span class="comment">&quot; 使用主题</span></span><br><span class="line"><span class="keyword">set</span> background=dark            <span class="comment">&quot; 深色模式</span></span><br></pre></td></tr></table></figure><ol><li>重载配置并安装：</li></ol><figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">:<span class="keyword">source</span> %</span><br><span class="line">:PlugInstall</span><br></pre></td></tr></table></figure><p><strong>验证配置</strong><br>打开 <code>Vim</code> 测试：</p><ul><li>按 <code>Ctrl+n</code> 应出现文件树</li><li>输入文本后按 <code>gcc</code> 应注释当前行</li><li>按 <code>Ctrl+p</code> 应出现文件搜索框</li></ul><blockquote><p>遇到问题执行 :PlugStatus查看插件状态<br>更新插件用 :PlugUpdate</p></blockquote><h3 id="3-编译器gcc-g"><a href="#3-编译器gcc-g" class="headerlink" title="3. 编译器gcc &#x2F;g++"></a>3. 编译器gcc &#x2F;g++</h3><h4 id="3-1-GCC-G-是什么？"><a href="#3-1-GCC-G-是什么？" class="headerlink" title="3.1 GCC &#x2F; G++ 是什么？"></a>3.1 GCC &#x2F; G++ 是什么？</h4><ol><li><strong>GCC (GNU Compiler Collection):</strong></li></ol><ul><li><strong>定义：</strong> <code>GCC</code> 最初代表 “GNU C Compiler”，但随着其支持语言的扩展，现在代表 “<strong>GNU Compiler Collection</strong>“ (<code>GNU</code> 编译器套件)</li><li><strong>功能：</strong> 它是一个由 <code>GNU</code> 项目开发的、功能强大且广泛使用的<strong>编译器套件</strong>。它支持多种编程语言，最主要的是：<ul><li><strong>C (<code>gcc</code>):</strong> 编译 <code>C</code> 语言程序</li><li><strong>C++ (<code>g++</code>):</strong> 编译 <code>C++</code> 语言程序</li><li>其他：<code>Fortran</code> (<code>gfortran</code>), <code>Ada</code> (<code>gnat</code>), <code>Go</code> (<code>gccgo</code>), <code>D</code> (<code>gdc</code>), <code>Objective-C</code>, <code>Objective-C++</code> 等</li></ul></li><li><strong>跨平台：</strong> <code>GCC</code> 是<strong>跨平台</strong>的，可以在多种操作系统上运行，包括 <code>Linux</code>、<code>macOS</code> (通过 <code>Xcode Command Line Tools</code> 或 <code>Homebrew</code> 等)、<code>Windows</code> (通过 <code>MinGW</code>, <code>Cygwin</code>, <code>WSL</code> 等)</li><li><strong>开源：</strong> 它是<strong>自由开源软件</strong> (<code>FOSS</code>)，遵循 <code>GPL</code> 许可证</li><li><strong>核心作用：</strong> 将人类可读的<strong>高级语言源代码</strong> (如 <code>.c</code>, <code>.cpp</code> 文件) 转换成计算机可执行的<strong>机器码</strong>或中间代码</li></ul><ol><li><strong>G++:</strong></li></ol><ul><li><strong>定义：</strong> <code>g++</code> 是 <code>GCC</code> 编译器套件中专门用于编译 <strong>C++</strong> 源代码的程序</li><li><strong>与 <code>gcc</code> 的关系：</strong><ul><li><code>gcc</code> 和 <code>g++</code> 本质上是同一个<strong>驱动程序</strong> (<code>driver program</code>)。它们的主要区别在于<strong>默认行为</strong>和<strong>默认链接的库</strong></li><li>当调用 <code>gcc</code> 时：<ul><li>默认将文件视为 <strong><code>C</code></strong> 源代码</li><li>默认在链接阶段<strong>只链接标准 <code>C</code> 库 (<code>libc</code>)</strong>, 不链接 <code>C++</code> 标准库 (<code>libstdc++</code>)</li></ul></li><li>当调用 <code>g++</code> 时：<ul><li>默认将文件 (如 <code>.c</code>, <code>.cpp</code>, <code>.cc</code>, <code>.C</code>) 视为 <strong>C++</strong> 源代码 (遵循特定后缀规则)</li><li>默认在链接阶段<strong>链接 <code>C++</code> 标准库 (<code>libstdc++</code>)</strong>。这是编译 <code>C++</code> 程序所必需的</li></ul></li></ul></li></ul><h4 id="3-2-预处理-编译-汇编-链接"><a href="#3-2-预处理-编译-汇编-链接" class="headerlink" title="3.2 预处理 -&gt; 编译 -&gt; 汇编 -&gt; 链接"></a>3.2 预处理 -&gt; 编译 -&gt; 汇编 -&gt; 链接</h4><p>程序如何从文本变成可执行文件的过程可以分为：预处理 -&gt; 编译 -&gt; 汇编 -&gt; 链接。我们以一个简单的 <code>C</code> 程序 <code>hello.c</code> 为例：</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> GREETING <span class="string">&quot;Hello, World!&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%s\n&quot;</span>, GREETING);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>阶段 1：预处理 (Preprocessing)</strong></p><ul><li><strong>工具：</strong> <code>cpp</code> (<code>C Preprocessor</code>)，通常由 <code>gcc -E</code> 或 <code>g++ -E</code> 调用</li><li><strong>输入：</strong> 源代码文件 (<code>.c</code>, <code>.cpp</code>)</li><li><strong>输出：</strong> <strong>预处理后的源代码</strong> (<code>.i</code> 或 <code>.ii</code> 文件，或直接输出到标准输出)</li><li><strong>核心任务：</strong> 处理源代码中以 <code>#</code> 开头的<strong>预处理指令 (<code>preprocessor directives</code>)</strong>，对源代码进行<strong>文本级别</strong>的替换和修改</li><li><strong>主要操作：</strong><ul><li><strong>头文件包含 (<code>#include</code>)：</strong> 将被包含的文件（如 <code>stdio.h</code>）的内容<strong>复制并插入</strong>到 <code>#include</code> 指令所在的位置。这通常会导致代码量显著增加</li><li><strong>宏展开 (<code>#define</code>)：</strong> 将所有定义的宏（如 <code>GREETING</code>）替换为其定义的值（<code>&quot;Hello, World!&quot;</code>）</li><li><strong>条件编译 (<code>#ifdef</code>, <code>#ifndef</code>, <code>#if</code>, <code>#else</code>, <code>#elif</code>, <code>#endif</code>)：</strong> 根据给定的条件（通常是宏是否定义或表达式值）决定是否包含或排除某些代码块。这在编写跨平台代码或调试时非常有用</li><li><strong>删除注释：</strong> 移除所有注释 (<code>//</code>, <code>/* ... */</code>)</li><li><strong>处理特殊指令：</strong> 如 <code>#pragma</code>, <code>#line</code>, <code>#error</code> 等</li></ul></li><li><strong>目的：</strong> 产生一个“纯净”的、不含预处理指令、宏已展开、头文件已包含的源代码文件，供真正的编译器使用</li><li><strong>查看预处理结果：</strong>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">gcc -E hello.c -o hello.i  <span class="comment"># 输出到 hello.i</span></span><br><span class="line">g++ -E hello.cpp -o hello.ii <span class="comment"># C++ 通常用 .ii</span></span><br></pre></td></tr></table></figure>  打开 <code>hello.i</code>，你会看到 <code>#include &lt;stdio.h&gt;</code> 被替换成了 <code>stdio.h</code> 中大量的函数声明和宏定义，<code>GREETING</code> 被替换成了 <code>&quot;Hello, World!&quot;</code>，注释也被删除了</li></ul><p><strong>阶段 2：编译 (Compilation)</strong></p><ul><li><strong>工具：</strong> 真正的编译器核心 (如 <code>cc1 for C</code>, <code>cc1plus for C++</code>)，通常由 <code>gcc -S</code> 或 <code>g++ -S</code> 调用</li><li><strong>输入：</strong> 预处理后的源代码 (<code>.i</code> 或 <code>.ii</code> 文件，或直接来自上一步)</li><li><strong>输出：</strong> <strong>汇编语言源代码</strong> (<code>.s</code> 文件)</li><li><strong>核心任务：</strong> 将<strong>高级语言</strong> (<code>C</code>&#x2F;<code>C++</code>) 翻译成<strong>低级、与特定处理器架构相关的汇编语言</strong> (<code>Assembly Language</code>)</li><li><strong>主要操作：</strong><ul><li><strong>词法分析 (Lexical Analysis)：</strong> 将源代码字符流分解成有意义的词素 (<code>token</code>)，如关键字、标识符、常量、运算符等</li><li><strong>语法分析 (Syntax Analysis &#x2F; Parsing)：</strong> 根据语法规则检查词素序列的结构，构建抽象语法树 (<code>Abstract Syntax Tree</code>, <code>AST</code>)。检查语法错误</li><li><strong>语义分析 (Semantic Analysis)：</strong> 在 AST 上检查语义是否正确（如类型检查、变量声明检查、函数调用匹配等）。收集类型信息</li><li><strong>中间代码生成 (Intermediate Code Generation)：</strong> (可选但常见) 生成一种独立于具体硬件架构的中间表示 (如 <code>GIMPLE</code>, <code>RTL in GCC</code>)，便于优化</li><li><strong>优化 (Optimization)：</strong> 在中间代码或汇编代码级别进行各种优化，以提高程序的运行效率或减小其大小（如常量传播、死代码消除、循环优化、内联函数等）。优化级别可通过 <code>-O0</code> (不优化), <code>-O1</code>, <code>-O2</code>, <code>-O3</code>, <code>-Os</code> (优化大小) 等选项控制</li><li><strong>目标代码生成 (Code Generation)：</strong> 将优化后的中间代码或直接从 <code>AST</code> 生成特定 <code>CPU</code> 架构的<strong>汇编语言指令</strong></li></ul></li><li><strong>目的：</strong> 生成与机器指令一一对应的、人类（勉强）可读的低级表示（汇编代码）</li><li><strong>查看编译结果 (生成汇编)：</strong>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gcc -S hello.i -o hello.s  <span class="comment"># 从预处理文件编译</span></span><br><span class="line">gcc -S hello.c -o hello.s   <span class="comment"># gcc 会自动先预处理再编译</span></span><br><span class="line">g++ -S hello.cpp -o hello.s</span><br></pre></td></tr></table></figure>  打开 <code>hello.s</code>，你会看到类似 <code>movl</code>, <code>call</code>, <code>pushq</code>, <code>.section</code>, <code>.globl main</code> 等针对特定 <code>CPU</code> (如 <code>x86-64</code>) 的汇编指令</li></ul><p><strong>阶段 3：汇编 (Assembly)</strong></p><ul><li><strong>工具：</strong> <strong>汇编器 (Assembler)</strong>，如 <code>as</code></li><li><strong>输入：</strong> 汇编语言源代码 (<code>.s</code> 文件)</li><li><strong>输出：</strong> <strong>目标文件 (Object File)</strong> (<code>.o</code> 或 <code>.obj</code> 文件)</li><li><strong>核心任务：</strong> 将<strong>汇编语言指令</strong>逐条翻译成对应的、处理器能够直接理解和执行的<strong>机器指令 (二进制码)</strong>，并将结果打包成目标文件格式</li><li><strong>主要操作：</strong><ul><li><strong>指令翻译：</strong> 将汇编助记符 (如 <code>mov</code>, <code>add</code>, <code>call</code>) 翻译成二进制机器码 (<code>Opcode</code>)</li><li><strong>符号解析 (初步)：</strong> 记录代码中定义的符号（函数名、全局变量名）及其位置（地址），以及引用的外部符号（如 <code>printf</code>）</li><li><strong>生成目标文件：</strong> 生成特定格式（如 <code>Linux</code>&#x2F;<code>Unix</code> 上的 <code>ELF</code> - <code>Executable and Linkable</code> <code>Format</code>, <code>Windows</code> 上的 <code>PE/COFF</code>）的目标文件。目标文件包含：<ul><li>编译后的<strong>机器代码</strong> (<code> .text</code> 段)</li><li><strong>初始化了的全局&#x2F;静态变量数据</strong> (<code> .data</code> 段)</li><li><strong>未初始化 (或初始化为0) 的全局&#x2F;静态变量数据</strong> (<code> .bss</code> 段，在文件中只占位置标记，不占实际空间)</li><li><strong>符号表 (Symbol Table)：</strong> 记录本文件中定义和引用的符号信息（名称、类型、大小、地址等）</li><li><strong>重定位信息 (Relocation Information)：</strong> 记录文件中哪些位置在最终链接时需要用其他目标文件或库中符号的地址来修正</li><li>调试信息 (可选，编译时加 <code>-g</code> 选项)</li></ul></li></ul></li><li><strong>目的：</strong> 生成包含机器码和元数据的<strong>可重定位目标文件</strong>，为链接阶段做准备</li><li><strong>执行汇编：</strong>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gcc -c hello.s -o hello.o  <span class="comment"># 从汇编文件汇编</span></span><br><span class="line">gcc -c hello.c -o hello.o   <span class="comment"># gcc 会自动预处理-&gt;编译-&gt;汇编</span></span><br><span class="line">g++ -c hello.cpp -o hello.o</span><br></pre></td></tr></table></figure>  生成的 <code>hello.o</code> 是一个二进制文件，直接用文本编辑器打开是乱码。可以使用 <code>objdump -d hello.o</code> 或 <code>nm hello.o</code> 来查看其反汇编代码或符号表</li></ul><p><strong>阶段 4：链接 (Linking)</strong></p><ul><li><strong>工具：</strong> <strong>链接器 (Linker)</strong>，如 <code>ld</code>。<code>gcc</code>&#x2F;<code>g++</code> 驱动程序会调用 <code>ld</code>，并负责传递正确的库路径和库名</li><li><strong>输入：</strong> 一个或多个<strong>目标文件</strong> (<code>.o</code>) 和<strong>库文件</strong> (静态库 <code>.a</code> &#x2F; <code>.lib</code>, 动态库 <code>.so</code> &#x2F; <code>.dll</code> &#x2F; <code>.dylib</code>)</li><li><strong>输出：</strong> <strong>最终的可执行文件</strong> (Linux&#x2F;Unix 无后缀或 <code>.out</code>, Windows <code>.exe</code>) 或 <strong>共享库&#x2F;动态链接库</strong> (<code>.so</code>, <code>.dll</code>, <code>.dylib</code>)</li><li><strong>核心任务：</strong> 将多个独立编译的目标文件以及所需的库文件<strong>组合</strong>成一个单一的、完整的、可被操作系统加载执行的程序映像。解决<strong>符号引用</strong>问题</li><li><strong>主要操作：</strong><ul><li><strong>符号解析 (Symbol Resolution)：</strong><ul><li>链接器扫描所有输入的目标文件和库</li><li>为每个目标文件中“<strong>引用 (Reference)</strong>”的符号（如 <code>printf</code>）在输入文件中寻找其“<strong>定义 (Definition)</strong>”</li><li>确保每个符号引用都能找到一个且仅一个符号定义（避免未定义引用 <code>undefined reference</code> 或多重定义 <code>multiple definition</code> 错误）</li></ul></li><li><strong>重定位 (Relocation)：</strong><ul><li>合并所有输入目标文件的同类型段（如将所有 <code>.text</code> 段合并到输出文件的 <code>.text</code> 段，所有 <code>.data</code> 段合并到 <code>.data</code> 段）</li><li>计算每个定义的符号（函数、变量）在最终输出文件中的<strong>绝对内存地址</strong>（或相对于基址的相对地址）</li><li>根据计算出的新地址，<strong>修改</strong>所有引用这些符号的地方（机器指令中使用的地址或数据段中的指针），填入正确的地址值。这是利用汇编阶段生成的重定位信息来完成的</li></ul></li><li><strong>解析库依赖：</strong><ul><li>链接器按顺序处理输入文件（包括命令行上指定的库）</li><li>如果一个目标文件引用了库中的符号，链接器会从库中<strong>提取</strong>包含该符号定义的目标文件（模块），并将其加入链接过程。对于静态库，代码被<strong>复制</strong>到最终可执行文件中。对于动态库，只在可执行文件中<strong>记录</strong>库的名字和所需符号，运行时由操作系统加载</li></ul></li><li><strong>生成可执行文件：</strong> 将合并、重定位后的代码和数据，以及必要的头部信息（如程序入口点 <code>_start</code>，它负责初始化环境后调用 <code>main</code>）、段表等，按照操作系统要求的格式（如 <code>ELF</code>, <code>PE</code>）打包成最终的可执行文件或共享库</li></ul></li><li><strong>目的：</strong> 解决模块间依赖（符号引用），合并代码和数据，分配最终运行时地址，生成可直接加载运行的程序</li><li><strong>执行链接：</strong>  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">gcc hello.o -o hello        <span class="comment"># 链接单个目标文件 (自动链接C标准库)</span></span><br><span class="line">g++ hello.o -o hello       <span class="comment"># 链接单个目标文件 (自动链接C++和C标准库)</span></span><br><span class="line">gcc main.o utils.o -o myprog -lm <span class="comment"># 链接多个目标文件和数学库</span></span><br></pre></td></tr></table></figure></li></ul><h4 id="3-3-动态链接与静态链接"><a href="#3-3-动态链接与静态链接" class="headerlink" title="3.3 动态链接与静态链接"></a>3.3 动态链接与静态链接</h4><p>在实际开发中，不可能将所有代码放在一个源文件中，所以会出现多个源文件，而且多个源文件之间是独立的，且会存在多种依赖关系，如一个源文件可能要调用另一个源文件中定义的函数，这是最常用的场景了；但是每个源文件是独立编译的，每个 <code>.c</code> 文件都会形成一个 <code>.o</code> 文件，为了满足前面的依赖关系，则需要将这些源文件产生的目标文件进行链接，从而形成一个可以执行的从程序。这个链接的过程就是<strong>静态链接</strong>，其缺点很明显：</p><ul><li><strong>浪费空间</strong>：因为每个可执行程序中对所有需要的目标文件都要有一份副本，所以如果多个程序对同一个目标文件都有依赖，如多个程序中都调用了printf()函数，则这多个程序中都含有printf.o，所以同一个目标文件都在内存存在多个副本</li><li><strong>更新比较困难</strong>：因为每当库函数的代码修改了，这个时候就需要重新进行编译链接形成可执行程序。但是静态链接的优点就是，在可执行程序中已经具备了所有执行程序所需要的任何东西，在执行的时候运行速度快</li></ul><p>动态链接的出现解决了静态链接中给提到的问题，其思想是<strong>把程序按照模块拆分成各个相对独立的部分</strong>，在<strong>程序运行时才将它们链接到一起形成完整的可执行程序</strong>，而不是像静态链接一样把所有的程序模块都链接成一个单独的可执行文件<br>动态链接比较常用，<strong>默认情况下程序采用的都是动态链接</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$ ldd hello</span><br><span class="line">   linux-vdso.so.1 (0x00007ffc9bdb2000)</span><br><span class="line">   libc.so.6 =&gt; /lib/x86_64-linux-gnu/libc.so.6 (0x000079eb86800000)</span><br><span class="line">   /lib64/ld-linux-x86-64.so.2 (0x000079eb86aa1000)</span><br><span class="line">$ </span><br><span class="line"><span class="comment"># ldd 用于打印程序或者库文件所依赖的共享库列表</span></span><br></pre></td></tr></table></figure><p>在这里涉及到一个概念 <strong>库</strong> ，<br>在 <code>C</code> 程序中，并没有定义 <code>printf</code> 的函数实现，而且在预编译中包含的头文件 <code>stdio.h</code>，也只有该函数的声明，而没有定义函数的实现<br>真正的实现是在库中，<code>libc.so.6</code> 的库文件中，<strong>系统把这些函数都实现在库文件中</strong>。在没有指定路径的情况下，<code>gcc</code> 到系统默认的搜索路径下 <code>/usr/lib</code> 下进行查找，也就是链接到 <code>Libc.so.6</code> 库中，这样就能实现函数 <code>printf</code> 了，刚好这就是链接的作用</p><h4 id="3-4-gcc-常用选项"><a href="#3-4-gcc-常用选项" class="headerlink" title="3.4 gcc 常用选项"></a>3.4 gcc 常用选项</h4><p> <strong>基础控制选项</strong></p><table><thead><tr><th><strong>选项</strong></th><th><strong>功能</strong></th><th><strong>示例</strong></th></tr></thead><tbody><tr><td><code>-E</code></td><td>仅执行预处理</td><td><code>gcc -E main.c -o main.i</code></td></tr><tr><td><code>-S</code></td><td>仅编译到汇编</td><td><code>gcc -S main.c</code> → 生成 <code>main.s</code></td></tr><tr><td><code>-c</code></td><td>编译+汇编（不链接）</td><td><code>gcc -c main.c</code> → 生成 <code>main.o</code></td></tr><tr><td><code>-o &lt;file&gt;</code></td><td>指定输出文件名</td><td><code>gcc main.c -o myapp</code></td></tr><tr><td><code>-x &lt;语言&gt;</code></td><td>强制指定语言类型</td><td><code>gcc -x c++ foo.txt</code></td></tr><tr><td><code>-v</code></td><td>显示详细编译过程</td><td><code>gcc -v main.c</code></td></tr><tr><td><code>-###</code></td><td>显示命令但不执行</td><td><code>gcc -### main.c</code></td></tr></tbody></table><p><strong>目录与路径选项</strong></p><table><thead><tr><th><strong>选项</strong></th><th><strong>功能</strong></th><th><strong>示例</strong></th></tr></thead><tbody><tr><td><code>-I&lt;dir&gt;</code></td><td>添加头文件搜索路径</td><td><code>gcc -Iinclude/ main.c</code></td></tr><tr><td><code>-L&lt;dir&gt;</code></td><td>添加库文件搜索路径</td><td><code>gcc -Llib/ main.o -lmylib</code></td></tr><tr><td><code>-l&lt;库名&gt;</code></td><td>链接指定库</td><td><code>gcc main.c -lm</code>（链接数学库）</td></tr><tr><td><code>-nostdinc</code></td><td>禁止搜索标准头文件目录</td><td><code>gcc -nostdinc -Icustom_include/</code></td></tr></tbody></table><p><strong>预处理选项</strong></p><table><thead><tr><th><strong>选项</strong></th><th><strong>功能</strong></th><th><strong>示例</strong></th></tr></thead><tbody><tr><td><code>-D&lt;宏&gt;[=值]</code></td><td>定义宏</td><td><code>gcc -DDEBUG main.c</code></td></tr><tr><td><code>-U&lt;宏&gt;</code></td><td>取消宏定义</td><td><code>gcc -UDEBUG main.c</code></td></tr><tr><td><code>-include &lt;文件&gt;</code></td><td>强制包含头文件</td><td><code>gcc -include defs.h main.c</code></td></tr><tr><td><code>-M</code> &#x2F; <code>-MM</code></td><td>生成依赖关系（用于Makefile）</td><td><code>gcc -MM main.c</code> → 输出依赖规则</td></tr></tbody></table><p><strong>警告控制选项</strong></p><table><thead><tr><th><strong>选项</strong></th><th><strong>功能</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td><code>-Wall</code></td><td>启用所有常见警告</td><td>包含未使用变量、函数未声明等</td></tr><tr><td><code>-Wextra</code></td><td>启用额外警告</td><td>比 <code>-Wall</code> 更严格（如空循环体）</td></tr><tr><td><code>-Werror</code></td><td>将警告视为错误</td><td>编译失败</td></tr><tr><td><code>-Wno-&lt;警告名&gt;</code></td><td>禁用特定警告</td><td><code>gcc -Wno-unused-variable</code></td></tr><tr><td><code>-pedantic</code></td><td>严格遵循 <code>ISO</code> 标准</td><td>拒绝非标准扩展</td></tr></tbody></table><p><strong>优化选项</strong></p><table><thead><tr><th><strong>选项</strong></th><th><strong>优化级别</strong></th><th><strong>特点</strong></th></tr></thead><tbody><tr><td><code>-O0</code></td><td>无优化</td><td>编译快，调试友好（默认）</td></tr><tr><td><code>-O1</code></td><td>基础优化</td><td>平衡性能与编译速度</td></tr><tr><td><code>-O2</code></td><td>推荐优化</td><td>激进优化（不增加代码大小）</td></tr><tr><td><code>-O3</code></td><td>最高优化</td><td>可能增加代码大小（循环展开等）</td></tr><tr><td><code>-Os</code></td><td>优化代码大小</td><td>适用于嵌入式设备</td></tr><tr><td><code>-Ofast</code></td><td>激进优化</td><td>可能违反标准（如浮点精度）</td></tr></tbody></table><p><strong>调试选项</strong></p><table><thead><tr><th><strong>选项</strong></th><th><strong>功能</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td><code>-g</code></td><td>生成调试信息</td><td>支持 <code>GDB</code> 调试</td></tr><tr><td><code>-ggdb</code></td><td>生成GDB专用调试信息</td><td>比 <code>-g</code> 更详细</td></tr><tr><td><code>-g3</code></td><td>包含宏定义信息</td><td>调试时可展开宏</td></tr><tr><td><code>-s</code></td><td>移除所有符号表</td><td>减小可执行文件大小</td></tr><tr><td><code>-p</code> &#x2F; <code>-pg</code></td><td>生成性能分析数据</td><td>用于 <code>gprof</code> 分析</td></tr></tbody></table><p><strong>七、链接选项</strong></p><table><thead><tr><th><strong>选项</strong></th><th><strong>功能</strong></th><th><strong>示例</strong></th></tr></thead><tbody><tr><td><code>-static</code></td><td>静态链接</td><td><code>gcc -static main.c</code></td></tr><tr><td><code>-shared</code></td><td>生成动态库</td><td><code>gcc -shared -fPIC -o libfoo.so foo.c</code></td></tr><tr><td><code>-fPIC</code></td><td>生成位置无关代码</td><td>编译动态库必备</td></tr><tr><td><code>-pthread</code></td><td>支持多线程</td><td>定义宏并链接线程库</td></tr><tr><td><code>-Wl,&lt;选项&gt;</code></td><td>传递选项给链接器</td><td><code>gcc -Wl,-rpath=/lib main.c</code></td></tr></tbody></table><p><strong>语言标准选项</strong></p><table><thead><tr><th><strong>选项</strong></th><th><strong>标准</strong></th><th><strong>说明</strong></th></tr></thead><tbody><tr><td><code>-std=c89</code> &#x2F; <code>-ansi</code></td><td><code>C89</code> 标准</td><td>传统 <code>C</code> 语言</td></tr><tr><td><code>-std=c99</code></td><td><code>C99</code> 标准</td><td>支持 <code>//</code> 注释、<code>long long</code></td></tr><tr><td><code>-std=c11</code></td><td><code>C11</code> 标准</td><td>现代 <code>C</code> 语言（推荐）</td></tr><tr><td><code>-std=c++11</code></td><td><code>C++11</code> 标准</td><td>智能指针、<code>Lambda</code></td></tr><tr><td><code>-std=c++17</code></td><td><code>C++17</code> 标准</td><td>结构化绑定、<code>std::optional</code></td></tr></tbody></table><h3 id="4-Makefile"><a href="#4-Makefile" class="headerlink" title="4. Makefile"></a>4. Makefile</h3><p><strong>Makefile</strong> 是一个用于自动化软件构建过程的脚本文件，由 <code>make</code> 工具解析执行。它定义了项目中的依赖关系、构建规则和操作指令，主要用于编译源代码、链接目标文件和管理项目构建流程</p><ul><li>一个工程中的源文件不计其数，其类型、功能、模块分别放在若干个目录中，<code>makefile</code> 定义了一系列的规则来指定哪些文件需要先编译，哪些文件需要后编译，甚至是更复杂的操作</li><li><code>makefile</code> 带来的好处就是—自动化编译，一旦写好，只需要一个 <code>make</code> 命令，整个工程就能按照定义的规则自动编译，极大地提高了软件开发的效率</li><li><code>make</code> 是一个工具，具体来说是解释 <code>makefile</code> 中指令的命令工具。一般，大部分的 <code>IDE</code> 都有这个命令，如 <code>Delphi</code> 的 <code>make</code>，<code>Visual C++</code> 中的 <code>namke</code>，<code>Linux</code>下的 <code>GNU</code> 的 <code>make</code></li><li><code>make</code> 是一条命令，<code>makefile</code> 是一个文件，两个搭配使用，完成项目的自动化构建</li></ul><p><strong>核心概念</strong></p><ol><li><strong>目标（Target）</strong><br>需要生成的文件（如可执行文件、目标文件）或伪目标（如 <code>clean</code>）</li><li><strong>依赖（Prerequisites）</strong><br>目标所依赖的文件或其他目标</li><li><strong>命令（Recipe）</strong><br>构建目标时执行的 <code>Shell</code> 命令（<strong>必须用 Tab 缩进</strong>）</li></ol><h4 id="4-1-基本使用"><a href="#4-1-基本使用" class="headerlink" title="4.1 基本使用"></a>4.1 基本使用</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello makefile!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>以单个简单的源文件作为示例</p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">Hello:Hello.c</span></span><br><span class="line">    gcc -o Hello Hello.c</span><br><span class="line"><span class="meta"><span class="keyword">.PHONY</span>: clean</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    rm -f Hello</span><br></pre></td></tr></table></figure><p>上面的 <code>makefile</code> 中，大部分其实都是用我们正常使用 <code>gcc/g++</code> 时的语法，只是放在 <code>makefile</code> 中了而已，执行的时候只需输入 <code>make</code> 即可自动完成 <code>makefile</code> 中的命令<br><strong>依赖关系</strong><br>上面的文件 <code>Hello.c</code>，生成可执行程序<code>Hello</code>(<code>Hello</code> 依赖于 <code>Hello.c</code>)<br><strong>依赖方法</strong><br><code>gcc -o Hello Hello.c</code>，就是上面的依赖关系<br><strong>项目清理</strong></p><ul><li>工程是需要清理的</li><li><code>clean</code>，没有被第一个目标文件直接或间接关联，那么它后面所定义的命令将不会被自动执行，不过，可以通过显示 <code>make</code> 执行，也就是 <code>make clean</code>，以此来清除所有的目标文件，以重新编译</li><li>一般将 <code>clean</code> 这种目标文件，设置为伪目标(不生成实际文件的目标)，用 <code>.PHONY</code> 修饰，伪目标的特性是：<strong>总是被执行</strong></li></ul><p><strong>总是被执行：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">stat</span> ***</span><br><span class="line">  File: ***</span><br><span class="line">  Size: **              Blocks: *          IO Block: *   regular file</span><br><span class="line">Device: 253,1   Inode: 810719      Links: 1</span><br><span class="line">Access: (0664/-rw-rw-r--)  Uid: ( 1000/     wyf)   Gid: ( 1000/     wyf)</span><br><span class="line">Access: 2024-06-05 15:33:54.461535234 +0800</span><br><span class="line">Modify: 2024-06-05 15:33:42.343412262 +0800</span><br><span class="line">Change: 2024-06-05 15:33:42.343412262 +0800</span><br><span class="line"> Birth: 2024-06-05 15:33:42.342412252 +0800 </span><br></pre></td></tr></table></figure><ul><li>文件 &#x3D; 内容 + 属性</li><li><code>Modify</code>: 内容变更，时间更新</li><li><code>Change</code>：属性变更，时间更新</li><li><code>Access</code>：常指的是文件最近一次被访问的时间。在 <code>Linux</code> 的早期版本中，每当文件被访问时，其 <code>atime</code> 都会更新。但这种机制会导致大量的 <code>IO</code> 操作。具体更新原则，此处不做深究</li></ul><!-- ![1749109535572](image/基础开发工具/1749109535572.png) --><img src="/2025/11/19/Linux%E5%9F%BA%E7%A1%80%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/1749109535572.png" class=""><p><code>.PHONY</code> :让 <code>make</code> 忽略源文件和可执行目标文件的 <code>M</code> 时间对比</p><h4 id="4-2-推导过程"><a href="#4-2-推导过程" class="headerlink" title="4.2 推导过程"></a>4.2 推导过程</h4><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">Hello:Hello.o</span></span><br><span class="line">    gcc Hello.o -o Hello</span><br><span class="line"><span class="section">Hello.o:Hello.s</span></span><br><span class="line">    gcc -c Hello.s -o Hello.o</span><br><span class="line"><span class="section">Hello.s:Hello.i</span></span><br><span class="line">    gcc -S Hello.i -o Hello.s</span><br><span class="line"><span class="section">Hello.i:Hello.c</span></span><br><span class="line">    gcc -E Hello.c -o Hello.i</span><br><span class="line"><span class="meta"><span class="keyword">.PHONY</span>:clean</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    rm -f *.i *.s *.o Hello</span><br></pre></td></tr></table></figure><p>编译</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ make</span><br><span class="line">gcc -E Hello.c -o Hello.i</span><br><span class="line">gcc -S Hello.i -o Hello.s</span><br><span class="line">gcc -c Hello.s -o Hello.o</span><br><span class="line">gcc Hello.o -o Hello</span><br><span class="line">$ ./Hello </span><br><span class="line">Hello makefile!</span><br><span class="line">$ make clean</span><br><span class="line"><span class="built_in">rm</span> -f *.i *.s *.o Hello</span><br></pre></td></tr></table></figure><p><code>make</code> 的核心机制是 <strong>基于文件依赖关系和时间戳</strong> 来决定是否需要重建目标。如果依赖文件不存在，且没有规则能创建它，<code>make</code> 会拒绝工作</p><p><code>make</code> 是如何工作的?在只输入 <code>make</code> 命令时：</p><ol><li><code>make</code> 会在当前目录下找名字叫 <code>makefile</code> 或 <code>makefile</code> 的文件</li><li>如果找到，它会找文件中的第一个目标文件(<code>target</code>)，在上面的示例中，会找到 <code>Hello</code>，并将其作为最终的目标文件</li><li>如果 <code>Hello</code> 文件不存在。或是 <code>Hello</code> 所依赖的后面的 <code>Hello.o </code> 文件的修改时间要比 <code>Hello</code> 这个文件新(可以用 <code>touch</code> 测试)，那么，它就会执行后面所定义的命令来生成这个文件</li><li>如果 <code>Hello</code> 所依赖的 <code>Hello.o</code> 文件不存在，那么 <code>make</code> 会在当前文件中找目标为 <code>Hello.o</code> 文件的依赖性，如果找到则再根据对应的规则生成 <code>Hello.o</code> 文件(类似于堆栈的过程)</li></ol><!-- ![1749110542082](image/基础开发工具/1749110542082.png) --><img src="/2025/11/19/Linux%E5%9F%BA%E7%A1%80%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/1749110542082.png" class=""><ol start="5"><li><code>C</code> 文件和 <code>H</code> 文件是存在的，于是 <code>make</code> 就会生成 <code>Hello.o</code> 文件，然后再调用 <code>Hello.o</code> 文件声明的终极任务，也就是生成执行文件 <code>Hello</code></li><li>这就是 <code>make</code> 的依赖性，<code>make</code> 会一层一层的找文件的依赖关系，直到最终编译出目标文件</li><li>在寻找的过程中，如果出现错误，比如依赖的文件找不到，那么 <code>make</code> 就会直接退出，并报错，而对于所定义命令的错误，或是编译不成功，<code>make</code> 不会处理(自己定义的规则出了问题由你承担)</li><li><code>make</code> 只负责文件的依赖性，也就是说：如果找到了依赖关系后，冒号后的文件还是不存在，那么 <code>make</code> 不会工作</li></ol><h4 id="4-3-补充语法"><a href="#4-3-补充语法" class="headerlink" title="4.3 补充语法"></a>4.3 补充语法</h4><ol><li><p><strong>变量定义</strong></p><ul><li><code>BIN = main</code> 最终生成的可执行文件名</li><li><code>SRC = $(wildcard *.c)</code> 获取所有源文件（推荐使用  <code>wildcard</code>）</li><li><code>OBJ = $(SRC:.c=.o)</code> 将 <code>.c</code> 文件列表转为 <code>.o</code> 文件列表</li><li><code>CC = gcc</code> <code>C</code> 编译器（<code>C++</code> 使用 <code>g++</code>）</li></ul></li><li><p><strong>特殊函数</strong></p><ul><li><code>SRC=$(shell ls *.c</code> 采用 <code>shell</code> 命令的方式获取当前所有的 <code>.c</code> 文件</li><li><code>SRC=$(wildcard *.c)</code> 采用 <code>wildcard</code> 函数，获取当前所有 <code>.c</code> 文件</li></ul></li><li><p><strong>编译选项</strong></p><ul><li><code>LDFLAGS=-o </code> 链接选项</li><li><code>CLAGS=-c</code> 编译选项</li><li><code>RM=rm -rf</code> 引入删除命令</li></ul></li><li><p><strong>自动变量</strong></p><ul><li><code>$@</code> 代表目标文件名</li><li><code>$^</code> 代表依赖文件列表</li><li><code>$&lt;</code> 对展开的依赖 <code>.c</code> 文件，一个一个的交给指定的编译工具</li></ul></li><li><p><strong>模式规则</strong> </p><ul><li><code>%.o:%.c</code> 为每个 <code>.c</code> 文件生成对应的 <code>.o</code> 文件</li></ul></li><li><p><strong>特殊符号</strong> </p><ul><li><code>$@</code> 不回显命令</li></ul></li></ol><p>完整 <code>makefile</code></p><figure class="highlight makefile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">BIN = Hello</span><br><span class="line">SRC = <span class="variable">$(<span class="built_in">wildcard</span> *.c)</span></span><br><span class="line">OBJ = $(SRC:.c=.o)</span><br><span class="line">CC = gcc</span><br><span class="line">CFLAGS = -c </span><br><span class="line">LDFLAGES = -o </span><br><span class="line">RM = rm -f</span><br><span class="line"></span><br><span class="line"><span class="variable">$(BIN)</span>:<span class="variable">$(OBJ)</span></span><br><span class="line">    @<span class="variable">$(CC)</span> <span class="variable">$(LDFLAGES)</span> <span class="variable">$@</span> <span class="variable">$^</span></span><br><span class="line">    @echo <span class="string">&quot;Linking……<span class="variable">$^</span> to <span class="variable">$@</span>&quot;</span></span><br><span class="line">%.o : %.c </span><br><span class="line">    @<span class="variable">$(CC)</span> <span class="variable">$(CFLAGS)</span> <span class="variable">$&lt;</span></span><br><span class="line">    @echo <span class="string">&quot;Comling……<span class="variable">$&lt;</span> to <span class="variable">$@</span>&quot;</span></span><br><span class="line"><span class="meta"><span class="keyword">.PHONY</span>:clean</span></span><br><span class="line"><span class="section">clean:</span></span><br><span class="line">    <span class="variable">$(RM)</span> <span class="variable">$(OBJ)</span> <span class="variable">$(BIN)</span></span><br><span class="line"><span class="meta"><span class="keyword">.PHONY</span>:run</span></span><br><span class="line"><span class="section">run:</span></span><br><span class="line">    @./<span class="variable">$(BIN)</span></span><br></pre></td></tr></table></figure><p>使用👇</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ make</span><br><span class="line">Comling……Hello.c to Hello.o</span><br><span class="line">Linking……Hello.o to Hello</span><br><span class="line">$ make run</span><br><span class="line">Hello makefile!</span><br><span class="line">$ make clean</span><br><span class="line"><span class="built_in">rm</span> -f Hello.o Hello</span><br></pre></td></tr></table></figure><h3 id="5-Linux第一个程序—进度条"><a href="#5-Linux第一个程序—进度条" class="headerlink" title="5. Linux第一个程序—进度条"></a>5. Linux第一个程序—进度条</h3><h4 id="5-1-换行与回车"><a href="#5-1-换行与回车" class="headerlink" title="5.1 换行与回车"></a>5.1 换行与回车</h4><p>换行（<code>Line Feed</code>，<code>LF</code>，<code>\n</code>）和回车（<code>Carriage Return</code>，<code>CR</code>，<code>\r</code>）的区别源于计算机历史，在系统中的表现主要取决于操作系统<br><strong>核心区别</strong></p><ol><li><p><strong>回车 (CR, <code>\r</code>)</strong>  </p><ul><li><strong>起源</strong>：机械打字机时代，表示将打印头移回行首（<code>Carriage Return</code>）</li><li><strong>作用</strong>：光标回到当前行的开头，不换行 </li><li><strong>ASCII 码</strong>：<code>0x0D</code>（十进制 <code>13</code>）</li></ul></li><li><p><strong>换行 (LF, <code>\n</code>)</strong>  </p><ul><li><strong>起源</strong>：机械打字机中，表示滚筒下移一行（<code>Line Feed</code>）</li><li><strong>作用</strong>：光标垂直移动到下一行，但水平位置不变 </li><li><strong>ASCII 码</strong>：<code>0x0A</code>（十进制 <code>10</code>）</li></ul></li></ol><p><strong>操作系统中的实现差异</strong></p><table><thead><tr><th>系统</th><th>换行符表示</th><th>行为说明</th></tr></thead><tbody><tr><td><strong>Linux&#x2F;Unix&#x2F;macOS（现代）</strong></td><td><code>\n</code> (<code>LF</code>)</td><td>仅需一个字符表示换行：<br> 1. 移动到下一行<br> 2. 回到行首（隐含回车动作）</td></tr><tr><td><strong>Windows</strong></td><td><code>\r\n</code> (<code>CR+LF</code>)</td><td>需两个字符：<br> 1. <code>\r</code> 回到行首<br> 2. <code>\n</code> 移动到下一行</td></tr></tbody></table><blockquote><p>📌 <strong>关键点</strong>：Linux 的 <code>\n</code> <strong>等价于</strong> Windows 的 <code>\r\n</code>，它同时完成了“回车+换行”两个动作</p></blockquote><p><strong>为什么在 Linux 中单独拎出来说</strong></p><ol><li><p><strong>文件格式问题</strong>  </p><ul><li>若 <code>Windows</code> 文件（含 <code>\r\n</code>）在 <code>Linux</code> 中打开，多余的 <code>\r</code> 会显示为 <code>^M</code>（如 <code>cat -A file</code> 可见），可能导致脚本错误</li><li><strong>示例</strong><code>：Shell</code> 脚本包含 <code>\r</code> 时，会报错 <code>bash: $&#39;\r&#39;: command not found</code></li></ul></li><li><p><strong>工具兼容性</strong>  </p><ul><li><code>Linux</code> 工具（如 <code>grep</code>, <code>sed</code>）默认按 <code>\n</code> 识别行尾。若文件含 <code>\r\n</code>，可能影响文本处理</li></ul></li><li><p><strong>跨平台协作</strong>  </p><ul><li><code>Git</code> 等工具在 <code>Windows</code>&#x2F;<code>Linux</code> 间同步代码时，可能自动转换换行符（通过 <code>core.autocrlf</code> 配置）</li></ul></li></ol><h4 id="5-2-行缓冲区"><a href="#5-2-行缓冲区" class="headerlink" title="5.2 行缓冲区"></a>5.2 行缓冲区</h4><p>在 <code>C</code> 语言中，标准输出流（<code>stdout</code>）默认使用<strong>行缓冲模式</strong>。也就是说输出内容会先存储在内存缓冲区中，直到满足特定条件才实际写入终端，下面具体分析：</p><p><strong>换行符触发刷新（<code>\n</code>）</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello world!\n&quot;</span>);  <span class="comment">// 包含换行符</span></span><br><span class="line">    sleep(<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>结果</strong>：立即输出 “Hello world!”，然后等待 <code>3</code> 秒</li><li><strong>原理</strong>：<code>\n</code>符合行缓冲的刷新条件，触发缓冲区立即刷新</li></ul><p><strong>无刷新导致延迟输出</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello world!&quot;</span>);  <span class="comment">// 无换行符</span></span><br><span class="line">    sleep(<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>结果</strong>：先等待 <code>3</code> 秒，程序结束时才输出 “Hello world!”</li><li><strong>原理</strong>：</li><li>输出内容暂存缓冲区（未达到刷新条件）</li><li><code>sleep(3)</code>期间缓冲区保持未刷新状态</li><li>程序结束时自动刷新所有缓冲区</li></ul><p><strong>手动强制刷新缓冲区（<code>fflush</code>）</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Hello world!&quot;</span>);</span><br><span class="line">    fflush(<span class="built_in">stdout</span>);  <span class="comment">// 强制刷新</span></span><br><span class="line">    sleep(<span class="number">3</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><strong>结果</strong>：立即输出 “Hello world!”，然后等待 <code>3</code> 秒</li><li><strong>原理</strong>：<code>fflush(stdout)</code>强制清空缓冲区</li></ul><p>缓冲区核心作用</p><ol><li><p><strong>减少系统调用</strong><br>每次实际输出（如终端显示）需切换到内核态，频繁操作效率低下。缓冲区积累数据后批量写入，显著提升性能</p></li><li><p><strong>优化I&#x2F;O效率</strong><br>示例中若每秒输出 <code>1</code> 字符：</p><ul><li>无缓冲：触发 <code>100</code> 次系统调用（效率极低）</li><li>有缓冲：单次系统调用写入全部内容</li></ul></li><li><p><strong>刷新触发条件</strong>  </p><table><thead><tr><th>条件</th><th>示例</th></tr></thead><tbody><tr><td>遇到换行符 <code>\n</code></td><td><code>printf(&quot;text\n&quot;)</code></td></tr><tr><td>缓冲区满</td><td>默认大小约4KB</td></tr><tr><td>手动刷新</td><td><code>fflush(stdout)</code></td></tr><tr><td>程序正常终止</td><td><code>return 0</code>&#x2F;<code>exit()</code></td></tr></tbody></table></li></ol><p>缓冲区工作流程</p><!-- ![1752669629256](image/基础开发工具/1752669629256.png) --><img src="/2025/11/19/Linux%E5%9F%BA%E7%A1%80%E5%BC%80%E5%8F%91%E5%B7%A5%E5%85%B7/1752669629256.png" class=""><h4 id="5-3-倒计时程序"><a href="#5-3-倒计时程序" class="headerlink" title="5.3 倒计时程序"></a>5.3 倒计时程序</h4><p>下面基于上面所介绍的内容，实现一个简易的倒计时程序</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// countdown.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> count = <span class="number">10</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;倒计时开始\n&quot;</span>);</span><br><span class="line">    <span class="keyword">while</span>(count)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;\r[ %2d ]&quot;</span>, count);</span><br><span class="line">        fflush(<span class="built_in">stdout</span>);</span><br><span class="line">        sleep(<span class="number">1</span>);</span><br><span class="line">        count--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n倒计时结束!\n&quot;</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>结果</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">$ ./countdown </span><br><span class="line">倒计时开始</span><br><span class="line">[  1 ]</span><br><span class="line">倒计时结束!</span><br><span class="line">$ </span><br></pre></td></tr></table></figure><h4 id="5-4-进度条代码"><a href="#5-4-进度条代码" class="headerlink" title="5.4 进度条代码"></a>5.4 进度条代码</h4><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// progress_bar.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">progress_bar</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// progress_bar.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;progress_bar.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SIZE 100</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TYPE <span class="string">&quot;=&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">progress_bar</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">char</span> labble[<span class="number">4</span>] = &#123;<span class="string">&#x27;|&#x27;</span>, <span class="string">&#x27;/&#x27;</span>, <span class="string">&#x27;-&#x27;</span>, <span class="string">&#x27;\\&#x27;</span>&#125;;</span><br><span class="line">    <span class="type">char</span> buffer[SIZE + <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">memset</span>(buffer, <span class="number">0</span>, <span class="keyword">sizeof</span>(buffer));</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> percent = <span class="number">0</span>; percent &lt;= SIZE; percent++)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="keyword">if</span> (percent &lt; SIZE)</span><br><span class="line">            buffer[percent] = TYPE[<span class="number">0</span>];</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;[%-*s][%3d%%][%c]\r&quot;</span>, SIZE, buffer, percent, labble[percent % <span class="number">4</span>]);</span><br><span class="line">        fflush(<span class="built_in">stdout</span>);</span><br><span class="line">        usleep(<span class="number">30000</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// main.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&quot;progress_bar.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    progress_bar();</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>效果</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ ./progress_bar </span><br><span class="line">[====================================================================================================][100%][|]</span><br><span class="line">$ </span><br></pre></td></tr></table></figure><p><strong>扩展功能</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;progress_bar.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="title function_">void</span><span class="params">(Cal)</span><span class="params">(<span class="type">double</span> total, <span class="type">double</span> current, <span class="type">char</span> *name)</span>;</span><br><span class="line"><span class="type">const</span> <span class="type">double</span> speed[] = &#123;<span class="number">1.23</span>, <span class="number">0.28</span>, <span class="number">1.5</span>, <span class="number">1.1</span>, <span class="number">0.1</span>, <span class="number">2.5</span>&#125;;</span><br><span class="line"><span class="comment">// 模拟因各种原因导致不同的下载速度</span></span><br><span class="line"><span class="type">int</span> len_speed = <span class="keyword">sizeof</span>(speed) / <span class="keyword">sizeof</span>(speed[<span class="number">0</span>]);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 模拟任务</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">upload</span><span class="params">(<span class="type">double</span> total, Cal cal)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">double</span> current = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (current &lt; total)</span><br><span class="line">    &#123;</span><br><span class="line">        usleep(<span class="number">20000</span>);</span><br><span class="line">        current += speed[rand() % len_speed];</span><br><span class="line">        <span class="keyword">if</span> (current &gt; total)</span><br><span class="line">        &#123;</span><br><span class="line">            current = total;</span><br><span class="line">        &#125;</span><br><span class="line">        cal(total, current, <span class="string">&quot;uploading&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (current &gt;= total)</span><br><span class="line">        &#123;</span><br><span class="line">            current = total;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">download</span><span class="params">(<span class="type">double</span> total, Cal cal)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">double</span> current = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (current &lt; total)</span><br><span class="line">    &#123;</span><br><span class="line">        usleep(<span class="number">10000</span>);</span><br><span class="line">        current += speed[rand() % len_speed];</span><br><span class="line">        <span class="keyword">if</span> (current &gt; total)</span><br><span class="line">        &#123;</span><br><span class="line">            current = total;</span><br><span class="line">        &#125;</span><br><span class="line">        cal(total, current, <span class="string">&quot;downloading&quot;</span>);</span><br><span class="line">        <span class="keyword">if</span> (current &gt;= total)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    srand(time(<span class="literal">NULL</span>));</span><br><span class="line">    upload(<span class="number">1024</span>, progress_bar_extend);</span><br><span class="line">    download(<span class="number">4545</span>,progress_bar_extend);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//progress_bar.c</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&quot;progress_bar.h&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> SIZE 100</span></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TYPE <span class="string">&quot;=&quot;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">progress_bar_extend</span><span class="params">(<span class="type">double</span> total, <span class="type">double</span> current, <span class="type">char</span> *name)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">static</span> <span class="type">const</span> <span class="type">char</span> label[<span class="number">4</span>] = &#123;<span class="string">&#x27;|&#x27;</span>, <span class="string">&#x27;/&#x27;</span>, <span class="string">&#x27;-&#x27;</span>, <span class="string">&#x27;\\&#x27;</span>&#125;;</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> len_label = <span class="keyword">sizeof</span>(label) / <span class="keyword">sizeof</span>(label[<span class="number">0</span>]);</span><br><span class="line">    <span class="type">static</span> <span class="type">int</span> index_label = <span class="number">0</span>;</span><br><span class="line">    <span class="type">char</span> buffer[SIZE + <span class="number">1</span>];</span><br><span class="line">    <span class="built_in">memset</span>(buffer, <span class="number">0</span>, <span class="keyword">sizeof</span>(buffer));</span><br><span class="line">    <span class="type">double</span> percent = (current / total) * <span class="number">100</span>;</span><br><span class="line">    percent = percent &lt; <span class="number">0</span> ? <span class="number">0</span> : (percent &gt; <span class="number">100</span> ? <span class="number">100</span> : percent);</span><br><span class="line">    <span class="type">int</span> pos = (<span class="type">int</span>)(percent);</span><br><span class="line">    <span class="keyword">if</span> (pos &gt; <span class="number">0</span>)</span><br><span class="line">        <span class="built_in">memset</span>(buffer, TYPE[<span class="number">0</span>], pos);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;[%-*s][%3.1f%%][%c][%s...]\r&quot;</span>, SIZE, buffer, percent, label[index_label % len_label], name);</span><br><span class="line">    index_label++;</span><br><span class="line">    fflush(<span class="built_in">stdout</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//progress_bar.h</span></span><br><span class="line"><span class="meta">#<span class="keyword">pragma</span> once</span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;unistd.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;time.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span><span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">progress_bar_extend</span><span class="params">(<span class="type">double</span> total, <span class="type">double</span> current, <span class="type">char</span> *name)</span>;</span><br></pre></td></tr></table></figure><p><strong>效果演示</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">$ ./progress_bar </span><br><span class="line">[====================================================================================================][100.0%][|][uploading...]</span><br><span class="line">[====================================================================================================][100.0%][-][downloading...]</span><br><span class="line">$ </span><br></pre></td></tr></table></figure><h3 id="6-版本控制器Git"><a href="#6-版本控制器Git" class="headerlink" title="6. 版本控制器Git"></a>6. 版本控制器Git</h3><h4 id="6-1-问题引入"><a href="#6-1-问题引入" class="headerlink" title="6.1 问题引入"></a>6.1 问题引入</h4><p>想象一下你和同事 <strong>小王</strong> 正在合作撰写一份重要的项目报告（<code>report.docx</code>）。你们需要反复修改和完善这份文档</p><ol><li><strong>第一天：</strong> 你完成了初稿，保存为 <code>report_v1.docx</code>，然后通过邮件发给小王</li><li><strong>第二天：</strong> 小王修改了你的版本，添加了新内容，保存为 <code>report_v2_wang.docx</code>，并邮件发回给你</li><li><strong>第三天：</strong> 你收到小王的版本，发现他修改了某个你很重要的部分，同时你也有新的想法要加入。于是你：<ul><li>基于 <code>report_v1.docx</code> 修改了你认为重要的部分，保存为 <code>report_v1_final_me.docx</code>。</li><li>又基于 <code>report_v2_wang.docx</code> 添加了你的新想法，保存为 <code>report_v2_me_added.docx</code>。</li></ul></li><li><strong>第四天：</strong> 小王又发来一个文件 <code>report_v3_wang_fixed.docx</code>，说在 <code>v2</code> 的基础上修正了一些错误…</li><li><strong>问题爆发：</strong><ul><li>文件夹里堆满了 <code>report_v1.docx</code>, <code>report_v1_final_me.docx</code>, <code>report_v2_wang.docx</code>, <code>report_v2_me_added.docx</code>, <code>report_v3_wang_fixed.docx</code>… 哪个是最新的？哪个包含了你俩都认可的所有修改？哪次修改引入了那个关键错误？</li><li>不小心覆盖了文件怎么办？误删了某个“版本”怎么办？</li><li>如何把你基于 <code>v1</code> 的修改和小王在 <code>v2</code> 上的修改<strong>合并</strong>成一个包含所有内容的新版本？手动复制粘贴？</li><li>某段文字被删了，是谁删的？什么时候删的？为什么删？</li></ul></li></ol><p><strong>这就是“版本控制”要解决的核心问题！</strong></p><p>在没有版本控制系统（如 <code>Git</code>）的情况下，协作修改文件（尤其是代码、配置、设计稿等文本类文件）会变得极其混乱、低效且充满风险</p><h4 id="6-2-Git-登场：优雅的版本控制"><a href="#6-2-Git-登场：优雅的版本控制" class="headerlink" title="6.2 Git 登场：优雅的版本控制"></a>6.2 Git 登场：优雅的版本控制</h4><p>为了方便我们管理不同的文件，便有了<strong>版本控制器</strong>，其能让你了解到一个文件的历史，以及它的发展此过程的系统。通俗的讲就是一个可以记录工程的每一次改动和版本迭代的一个管理系统，同时也方便多人协同作业</p><p><strong>Git 几乎能管理任何文件格式：</strong> <strong>但是，“可以管理”不等于“适合管理”或“管理得好”。</strong> 文件格式对 <code>Git</code> 的效率和实用性有着<strong>巨大影响</strong></p><ol><li><p><strong>文本文件 (Text Files)：Git 的“主战场”</strong></p><ul><li><strong>优势：</strong><ul><li><strong>差异比较 (Diff)：</strong> <code>Git</code> 的核心功能之一是展示文件内容的变化（<code>git diff</code>）。对于文本文件（如 <code>.txt</code>, <code>.py</code>, <code>.java</code>, <code>.c</code>, <code>.html</code>, <code>.css</code>, <code>.js</code>, <code>.json</code>, <code>.xml</code>, <code>.md</code> 等），Git 可以清晰地逐行显示添加、删除或修改了哪些内容</li><li><strong>高效存储：</strong> <code>Git</code> 使用差异算法（基于快照，但存储时复用相同内容）和压缩技术。当文本文件只有小部分修改时，<code>Git</code> 只需要存储变化的部分，非常节省空间</li><li><strong>合并 (Merge)：</strong> <code>Git</code> 最强大的功能之一是自动合并不同分支上的修改。对于文本文件，只要修改发生在不同行，<code>Git</code> 通常能完美地自动合并这些更改。如果修改了同一行（冲突），<code>Git</code> 会明确标记出来让你手动解决</li><li><strong>版本历史可读性：</strong> 查看文本文件的历史版本 (<code>git show</code>) 或比较不同版本 (<code>git diff commit1 commit2 -- file</code>) 非常直观和有价值</li></ul></li></ul></li><li><p><strong>二进制文件 (Binary Files)：Git 的“痛点”</strong></p><ul><li><strong>劣势：</strong><ul><li><strong>无法有效 Diff：</strong> 二进制文件（如图片 <code>.jpg</code>, <code>.png</code>, 视频 <code>.mp4</code>, 音频 <code>.mp3</code>, 压缩包 <code>.zip</code>, 可执行文件 <code>.exe</code>, <code>.dll</code>, Word 文档 <code>.docx</code>, <code>Excel</code> 表格 <code>.xlsx</code>, PDF <code>.pdf</code> 等）内部结构复杂。<code>Git</code> 无法理解其内容，只能将其视为一大块不透明的二进制数据。运行 <code>git diff</code> 时，你只会看到类似 <code>Binary files a/file.jpg and b/file.jpg differ</code> 的信息，完全不知道具体哪里变了</li><li><strong>低效存储：</strong> <code>Git</code> 对二进制文件的处理非常“笨拙”。即使二进制文件只改动了一个像素或一个字节，Git 通常也会存储整个文件的<strong>新副本</strong>。这会导致仓库体积<strong>急剧膨胀</strong>，克隆、拉取、推送操作变得非常<strong>缓慢</strong></li><li><strong>无法自动合并：</strong> 如果两个分支都修改了同一个二进制文件，<code>Git</code> 无法自动合并它们。它只能报告冲突，并让你选择保留其中一个版本（通常是最后修改的那个），或者手动用外部工具合并（对于图片、设计稿等，这通常很困难甚至不可能）</li><li><strong>版本历史价值低：</strong> 查看历史版本的二进制文件需要完整检出该版本的文件并用专用软件打开，无法像文本文件那样快速浏览差异</li></ul></li></ul></li></ol><p><code>Git</code> 是一个<strong>分布式版本控制系统</strong>。它的核心思想是：<strong>记录文件的变化历史，而非保存多个完整的副本</strong></p><p><strong>引入 Git 后的优势总结：</strong></p><ul><li><strong>完整历史记录：</strong> 每个文件如何一步步变成现在的样子，清晰可查</li><li><strong>版本回溯：</strong> 轻松切换到任何一个历史版本（就像游戏读档），不怕改错代码或误删文件</li><li><strong>高效协作：</strong> 多人并行工作，自动合并修改，大幅提升团队效率</li><li><strong>分支管理：</strong> <code>Git</code> 允许创建独立的分支，用于开发新功能、修复 <code>Bug</code> 或做实验，而不会影响主线（<code>main</code>&#x2F;<code>master</code> 分支）。功能完成后可以合并回主线。这解决了“基于 <code>v1</code> 改还是基于 <code>v2</code> 改”的困境</li><li><strong>责任追溯：</strong> 明确知道每行代码是谁、在什么时候、为什么修改</li><li><strong>代码备份：</strong> 本地仓库和远程仓库（如 <code>GitHub</code>）共同构成了天然的备份机制</li></ul><h4 id="6-3-Git发展"><a href="#6-3-Git发展" class="headerlink" title="6.3 Git发展"></a>6.3 Git发展</h4><p><code>Git</code> 的发展史充满了传奇色彩，与 <code>Linux</code> 内核的开发密不可分</p><ol><li><p><strong>背景：Linux 内核的困境 (2005年之前)</strong></p><ul><li><code>Linux</code> 内核是一个庞大且由全球开发者协作的开源项目。</li><li>在 <code>2002</code> 年到 <code>2005</code> 年期间，<code>Linux</code> 开发团队使用一个名为 <strong>BitKeeper</strong> <code>的专有分布式版本控制系统。BitKeeper</code> 的创始人 <code>Larry McVoy</code> 免费授权 <code>Linux</code> 团队使用，条件是不能开发竞争工具</li><li><code>BitKeeper</code> 满足了 <code>Linux</code> 大规模分布式协作的需求，效果不错</li></ul></li><li><p><strong>导火索：BitKeeper 的终结 (2005年4月)</strong></p><ul><li><code>2005</code> 年，<code>Linux</code> 内核社区和 <code>BitKeeper</code> 公司之间的关系破裂。具体原因涉及对 <code>BitKeeper</code> 使用协议条款的争议以及社区中有人尝试对 <code>BitKeeper</code> 协议进行逆向工程</li><li><code>Larry McVoy</code> 收回了 <code>Linux</code> 团队的免费使用授权</li><li><strong>后果：</strong> <code>Linux</code> 开发团队瞬间失去了他们赖以协作的核心工具，面临巨大危机。当时的其他主流版本控制系统（如 <code>CVS</code>, <code>SVN</code>）都是集中式的，无法满足 <code>Linux</code> 分布式、高性能、大规模协作的需求</li></ul></li><li><p><strong>林纳斯的“十日奇迹” (2005年4月)</strong></p><ul><li><code>Linux</code> 的创造者 <code>Linus Torvalds</code> 对当时的替代方案（如 <code>Monotone</code>）都不满意，认为它们太慢、太复杂</li><li><strong>2005年4月3日：</strong> <code>Linus Torvalds</code> 决定自己动手开发一个新的版本控制系统</li><li><strong>核心目标：</strong><ul><li><strong>速度：</strong> 极快的操作（提交、分支切换、合并）</li><li><strong>简单设计：</strong> 核心概念清晰、直接</li><li><strong>强大的非线性分支支持：</strong> 鼓励频繁分支与合并（对内核开发至关重要）</li><li><strong>完全分布式：</strong> 每个开发者都有完整的仓库历史，不依赖中央服务器</li><li><strong>高效处理大型项目：</strong> 能轻松应对 <code>Linux</code> 内核这样超大规模的项目</li><li><strong>强数据完整性：</strong> 使用 <code>SHA-1</code> 哈希（后来是 SHA-256）保证内容不被篡改</li></ul></li><li><strong>2005年4月7日：</strong> <code>Git</code> 实现了自托管（用 <code>Git</code> 来管理 <code>Git</code> 自身的开发）</li><li><strong>2005年4月18日：</strong> 合并多个外部贡献者的分支到 <code>Git</code> 主线</li><li><strong>2005年4月20日：</strong> <code>Linux</code> 内核 <code>2.6.12</code> 版本发布说明中提到了 <code>Git</code></li><li><strong>2005年7月：</strong> <code>Git</code> 已经足够成熟，可以接管 <code>Linux</code> 内核的版本控制工作</li></ul></li><li><p><strong>核心设计</strong></p><ul><li><strong>快照，而非差异：</strong> <code>Git</code> 把每次提交看作项目文件在某个时间点的完整快照（虽然内部存储会复用未修改的文件，实现高效）。这与许多以文件差异为中心的系统不同。</li><li><strong>本地操作：</strong> 几乎所有操作（查看历史、提交、分支、合并）都在本地完成，速度极快</li><li><strong>数据完整性：</strong> 所有数据对象（文件内容、提交、树结构）都用其内容的 <code>SHA-1</code> 哈希值命名。任何微小的改动都会改变哈希值，保证历史不可篡改</li><li><strong>“通常只添加数据”：</strong> 绝大多数 <code>Git</code> 操作只是向数据库添加数据，很难真正丢失数据（直到垃圾回收运行）</li></ul></li><li><p><strong>成长与普及 (2005年至今)</strong></p><ul><li><strong>2005年底：</strong> <code>Junio Hamano</code> 接手成为 <code>Git</code> 的核心维护者，并持续至今，对 <code>Git</code> 的稳定性和功能扩展贡献巨大。</li><li><strong>GitHub 的诞生 (2008年)：</strong> <code>GitHub</code> 提供了一个基于 <code>Git</code> 的代码托管平台，极大地简化了协作流程（<code>Pull Request</code>, <code>Issue Tracking</code>, <code>Web UI</code>），将 <code>Git</code> 的强大功能包装成用户友好的界面，引爆了 <code>Git</code> 的普及。<code>GitHub</code> 成为了开源世界的中心</li><li><strong>竞争对手的出现：</strong> <code>GitLab</code> (<code>2011</code>), <code>Bitbucket</code> (支持 <code>Git</code> 后) 等平台也提供了强大的 <code>Git</code> 托管服务</li><li><strong>工具链完善：</strong> 围绕 <code>Git</code> 开发了大量图形化客户端（如 <code>GitKraken</code>, <code>Sourcetree</code>, <code>Tower</code>）、<code>IDE</code> 集成插件（<code>VS Code</code>, <code>IntelliJ</code> 等都有极佳的 <code>Git</code> 支持）和命令行辅助工具（如 <code>tig</code>），降低了学习曲线</li><li><strong>超越代码：</strong> <code>Git</code> 的核心思想被应用于管理配置文件、文档、书籍、甚至法律合同、设计稿（虽然对二进制文件支持不如文本好）等领域</li></ul></li><li><p><strong>现状</strong></p><ul><li><strong>事实标准：</strong> <code>Git</code> 已成为全球软件开发领域<strong>绝对主导</strong>的版本控制系统。几乎所有大型科技公司、开源项目和个人开发者都在使用 <code>Git</code></li><li><strong>持续活跃：</strong> <code>Git</code> 本身仍在积极开发和维护，不断引入新功能和性能优化（如部分克隆、稀疏检出、新的哈希算法支持 <code>SHA-256</code>）</li><li><strong>生态系统庞大：</strong> 围绕 <code>Git</code> 的托管服务、工具、工作流（<code>Gitflow</code>, <code>GitHub Flow</code>, <code>GitLab Flow</code>）形成了极其庞大的生态系统</li></ul></li></ol><h4 id="6-4-Git的使用"><a href="#6-4-Git的使用" class="headerlink" title="6.4 Git的使用"></a>6.4 Git的使用</h4><h5 id="6-4-1-核心概念"><a href="#6-4-1-核心概念" class="headerlink" title="6.4.1 核心概念"></a>6.4.1 核心概念</h5><ul><li><strong>仓库 (Repository)：</strong> 项目的版本控制数据库，包含所有文件的历史记录和元数据。本地仓库在项目目录下的 <code>.git</code> 文件夹中；远程仓库托管在 <code>GitHub</code>、<code>GitLab</code> 等平台</li><li><strong>工作区 (Working Directory)：</strong> 我们实际看到和编辑的项目文件目录</li><li><strong>暂存区 (Staging Area &#x2F; Index)：</strong> 一个中间区域，用于准备下一次提交的内容。用 <code>git add</code> 将工作区的修改放入这里</li><li><strong>提交 (Commit)：</strong> 一个永久的、带描述的项目状态快照，保存在仓库历史中。由 <code>git commit</code> 创建</li><li><strong>分支 (Branch)：</strong> 指向某个提交的可移动指针。默认分支通常是 <code>main</code> 或 <code>master</code>。允许我们在独立于主线的情况下开发新功能或修复 Bug</li><li><strong>远程 (Remote)：</strong> 指向托管在网络上（如 <code>GitHub</code>）的仓库副本的引用（通常命名为 <code>origin</code>）。用于与他人协作和备份</li></ul><h5 id="6-4-2-创建仓库"><a href="#6-4-2-创建仓库" class="headerlink" title="6.4.2 创建仓库"></a>6.4.2 创建仓库</h5><p>创建一个自己的仓库很简单，步骤如下：</p><ol><li><strong>登录 GitHub</strong>：打开 <a href="https://github.com/">github.com</a> 并登录你的账户</li><li><strong>找到“新建仓库”按钮</strong>：<ul><li>在页面右上角，点击 <strong><code>+</code></strong> 下拉菜单</li><li>选择 <strong><code>New repository</code></strong></li></ul></li><li><strong>填写仓库信息</strong>：<ul><li><strong>Repository name</strong>：输入你的仓库名称（必填）</li><li><strong>Description</strong>：添加一个简短的描述（可选，但推荐）</li><li><strong>Public&#x2F;Private</strong>：选择仓库是公开（所有人可见）还是私有（仅你授权的人可见）</li></ul></li><li><strong>初始化选项</strong>（可选但推荐）：<ul><li>勾选 <strong><code>Add a README file</code></strong>：创建一个初始 <code>README</code> 文件（非常重要，用于介绍项目）</li><li>勾选 <strong><code>.gitignore</code></strong>：选择模板（如 <code>Python</code>、<code>Node</code> 等）忽略不需要跟踪的文件</li><li>勾选 <strong><code>Choose a license</code></strong>：为你的项目选择一个开源许可证(不清楚许可证的可以不用选)</li></ul></li><li><strong>创建仓库</strong>：点击页面底部的绿色按钮 <strong><code>Create repository</code></strong></li></ol><p><strong>完成！</strong> 你已成功创建了一个新的 <code>GitHub</code> 仓库，可以开始上传代码、协作和管理项目了</p><p>创建完成之后，会看到 <code>HTTPS</code> 的链接，这个就是仓库的链接，后面的 <code>git</code> 操作会用到</p><h5 id="6-4-3-git-命令"><a href="#6-4-3-git-命令" class="headerlink" title="6.4.3 git 命令"></a>6.4.3 git 命令</h5><p><strong>1. git clone</strong>  </p><ul><li><strong>作用</strong>：将远程仓库复制到本地</li><li><strong>命令</strong>：  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line">  git <span class="built_in">clone</span> &lt;远程仓库URL&gt;  <span class="comment"># 默认克隆到同名目录</span></span><br><span class="line">  git <span class="built_in">clone</span> &lt;URL&gt; &lt;自定义目录名&gt;  <span class="comment"># 克隆到指定目录</span></span><br><span class="line">  ```  </span><br><span class="line">- **关键点**：  </span><br><span class="line">  - 自动创建远程跟踪分支（如 `origin/main`）</span><br><span class="line">  - 默认检出 `main` 或 `master` 分支</span><br><span class="line"></span><br><span class="line">**2. git pull**  </span><br><span class="line">- **作用**：拉取远程分支最新内容并合并到当前分支（`= git fetch + git merge`）</span><br><span class="line">- **命令**：  </span><br><span class="line">  ```bash</span><br><span class="line">  git pull origin &lt;分支名&gt;  <span class="comment"># 拉取指定分支</span></span><br><span class="line">  git pull  <span class="comment"># 若已设置上游分支（upstream），可省略参数</span></span><br><span class="line">  ```  </span><br><span class="line">- **冲突处理**：  </span><br><span class="line">  - 若拉取时发生冲突，需手动解决冲突后提交</span><br><span class="line">  - 使用 `git status` 查看冲突文件</span><br><span class="line"></span><br><span class="line">**3. git commit**  </span><br><span class="line">- **作用**：将暂存区（`Staging Area`）的修改保存到本地仓库</span><br><span class="line">- **流程**：  </span><br><span class="line">  1. 添加修改到暂存区：  </span><br><span class="line">     ```bash</span><br><span class="line">     git add &lt;文件名&gt;  <span class="comment"># 添加单个文件</span></span><br><span class="line">     git add .        <span class="comment"># 添加所有修改</span></span><br><span class="line">     ```  </span><br><span class="line">  2. 提交到本地仓库：  </span><br><span class="line">     ```bash</span><br><span class="line">     git commit -m <span class="string">&quot;提交描述&quot;</span>  <span class="comment"># 必须填写清晰的描述</span></span><br><span class="line">     ```  </span><br><span class="line">- **修正提交**：  </span><br><span class="line">  - 修改最后一次提交：  </span><br><span class="line">    ```bash</span><br><span class="line">    git commit --amend  <span class="comment"># 可修改描述或追加新更改</span></span><br></pre></td></tr></table></figure></li></ul><p><strong>4. git push</strong>  </p><ul><li><strong>作用</strong>：将本地提交推送到远程仓库</li><li><strong>命令</strong>：  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">  git push origin &lt;分支名&gt;  <span class="comment"># 推送到指定分支</span></span><br><span class="line">  git push -u origin &lt;分支名&gt;  <span class="comment"># 首次推送时设置上游分支（后续可简写为 `git push`）</span></span><br><span class="line">  ```  </span><br><span class="line"></span><br><span class="line">**5. 分支管理**  </span><br><span class="line">- **创建分支**：  </span><br><span class="line">  ```bash</span><br><span class="line">  git branch &lt;新分支名&gt;    <span class="comment"># 创建分支</span></span><br><span class="line">  git checkout -b &lt;新分支名&gt;  <span class="comment"># 创建并切换到该分支</span></span><br><span class="line">  ```  </span><br><span class="line">- **切换分支**：  </span><br><span class="line">  ```bash</span><br><span class="line">  git checkout &lt;分支名&gt;  </span><br><span class="line">  git switch &lt;分支名&gt;      <span class="comment"># Git 2.23+ 推荐方式</span></span><br><span class="line">  ```  </span><br><span class="line">- **合并分支**：  </span><br><span class="line">  ```bash</span><br><span class="line">  git merge &lt;分支名&gt;  <span class="comment"># 将指定分支合并到当前分支</span></span><br></pre></td></tr></table></figure></li></ul><p><strong>6. 撤销操作</strong>  </p><ul><li><strong>撤销工作区修改</strong>：  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">  git restore &lt;文件名&gt;  <span class="comment"># 丢弃未暂存的修改（Git 2.23+）</span></span><br><span class="line">  ```  </span><br><span class="line">- **撤销暂存区文件**：  </span><br><span class="line">  ```bash</span><br><span class="line">  git restore --staged &lt;文件名&gt;  <span class="comment"># 将文件移出暂存区</span></span><br><span class="line">  ```  </span><br><span class="line">- **回退提交**：  </span><br><span class="line">  ```bash</span><br><span class="line">  git reset --soft HEAD~1  <span class="comment"># 撤销提交但保留修改  </span></span><br><span class="line">  git reset --hard HEAD~1  <span class="comment"># 彻底丢弃最近一次提交（谨慎使用！）</span></span><br></pre></td></tr></table></figure></li></ul><p><strong>7. 查看状态与历史</strong>  </p><ul><li><strong>状态检查</strong>：  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">  git status  <span class="comment"># 查看工作区和暂存区状态</span></span><br><span class="line">  ```  </span><br><span class="line">- **提交历史**：  </span><br><span class="line">  ```bash</span><br><span class="line">  git <span class="built_in">log</span> --oneline  <span class="comment"># 简洁版提交历史</span></span><br><span class="line">  git <span class="built_in">log</span> -p         <span class="comment"># 显示详细修改内容</span></span><br></pre></td></tr></table></figure></li></ul><p><strong>8. 冲突解决</strong>  </p><ul><li><strong>触发场景</strong>：<code>git pull</code> 或 <code>git merge</code> 时发生文件冲突</li><li><strong>解决步骤</strong>：  <ol><li>打开冲突文件（搜索 <code>&lt;&lt;&lt;&lt;&lt;&lt;&lt;</code> 标记）  </li><li>手动修改文件，保留所需内容</li><li>标记冲突已解决：  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">git add &lt;冲突文件名&gt;</span><br><span class="line">git commit -m <span class="string">&quot;解决冲突&quot;</span></span><br></pre></td></tr></table></figure></li></ol></li></ul><h3 id="7-调试器-gdb-cgdb"><a href="#7-调试器-gdb-cgdb" class="headerlink" title="7. 调试器 gdb&#x2F;cgdb"></a>7. 调试器 gdb&#x2F;cgdb</h3><p><strong>GDB</strong></p><ul><li><strong>定位：</strong> 命令行调试器，功能极其强大，是 <code>Linux</code>&#x2F;<code>Unix</code> 环境下 <code>C/C++</code> 等程序调试的<strong>核心引擎</strong></li><li><strong>工作模式：</strong> 纯命令行交互。你输入命令，<code>GDB</code> 输出结果</li></ul><p><strong>CGDB (Curses GDB)</strong></p><ul><li><strong>定位：</strong> <code>GDB</code> 的<strong>终端可视化前端</strong>。它不是一个独立的调试器，而是一个封装了 <code>GDB</code> 的<strong>用户界面</strong></li><li><strong>核心思想：</strong> 将终端窗口分成两个主要窗格：<ol><li><strong>上部窗格：</strong> 显示当前正在调试的源代码（类似于 <code>list</code> 命令的输出，但持续可见）</li><li><strong>下部窗格：</strong> 显示 <code>GDB</code> 的命令行界面和输出（就是你直接使用 <code>GDB</code> 时看到的那个界面）</li></ol></li><li><strong>核心能力：</strong> <code>CGDB</code> <strong>完全继承 <code>GDB</code> 的所有调试能力</strong>，因为它只是在 <code>GDB</code> 外面套了一个更友好的 <code>UI</code>。你在 <code>CGDB</code> 的下部窗格中输入的命令，就是原汁原味的 <code>GDB</code> 命令</li></ul><h4 id="7-1-debug和release"><a href="#7-1-debug和release" class="headerlink" title="7.1 debug和release"></a>7.1 debug和release</h4><ul><li>程序的发布方式有两种，<code>debug</code> 和 <code>release</code> 模式，<code>Linux</code> 下 <code>gcc/g++</code> 编译出来的二进制程序默认是 <code>release</code> 模式</li><li>要使用 <code>gdb</code> 调试，<strong>必须</strong>要源代码生成二进制程序的时候，加上 <code>-g</code>(<code>Generate debugging information</code>) 选项，如果没有添加，不能用 <code>gdb</code> 调试</li></ul><p>以下面的代码作为使用示例</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">Sum</span><span class="params">(<span class="type">int</span> start, <span class="type">int</span> end)</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> ret = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = start; i &lt;= end; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        ret += i;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> ret;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span></span><br><span class="line">&#123;</span><br><span class="line">    <span class="type">int</span> s = <span class="number">0</span>;</span><br><span class="line">    <span class="type">int</span> e = <span class="number">100</span>;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Start Calculating\n&quot;</span>);</span><br><span class="line">    <span class="type">int</span> sum = Sum(s,e);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;From %d to %d.Sum is %d\n&quot;</span>,s,e,sum);</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>debug vs release</code></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ gcc sum.c -o s1</span><br><span class="line">$ file s1</span><br><span class="line">s1: ELF 64-bit LSB pie executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=41ec5e3b6e67c06874ac326252d2400c845df920, <span class="keyword">for</span> GNU/Linux 3.2.0, not stripped</span><br><span class="line">$ gcc -g sum.c -o s2</span><br><span class="line">$ file s2</span><br><span class="line">s2: ELF 64-bit LSB pie executable, x86-64, version 1 (SYSV), dynamically linked, interpreter /lib64/ld-linux-x86-64.so.2, BuildID[sha1]=8a2666fe3c73713f8232033ece4dc99edd172dcb, <span class="keyword">for</span> GNU/Linux 3.2.0, with debug_info, not stripped</span><br><span class="line">$ </span><br></pre></td></tr></table></figure><p>在带了 <code>-g</code> 选项的二进制文件中，是明显带有 <code>debug_info</code> 的</p><h4 id="7-2-gdb-使用"><a href="#7-2-gdb-使用" class="headerlink" title="7.2 gdb 使用"></a>7.2 gdb 使用</h4><table><thead><tr><th align="left">命令</th><th align="left">简写</th><th align="left">功能说明</th></tr></thead><tbody><tr><td align="left"><code>list [file:]line/func</code></td><td align="left"><code>l</code></td><td align="left">显示源代码。可指定文件、行号或函数名</td></tr><tr><td align="left"><code>break [file:]line/func</code></td><td align="left"><code>b</code></td><td align="left">设置断点。可指定文件、行号、函数名或地址</td></tr><tr><td align="left"><code>info breakpoints</code></td><td align="left"><code>i b</code></td><td align="left">列出所有断点信息</td></tr><tr><td align="left"><code>delete [breakpoints] [n]</code></td><td align="left"><code>d</code></td><td align="left">删除所有断点或指定编号 <code>n</code> 的断点</td></tr><tr><td align="left"><code>run [arg1 arg2 ...]</code></td><td align="left"><code>r</code></td><td align="left">从头开始运行程序（可带命令行参数）</td></tr><tr><td align="left"><code>continue</code></td><td align="left"><code>c</code></td><td align="left">从当前停止点继续运行程序。</td></tr><tr><td align="left"><code>next</code></td><td align="left"><code>n</code></td><td align="left"><strong>单步执行（不进入函数）</strong>。执行下一行代码，如果遇到函数调用，将其视为一个整体执行</td></tr><tr><td align="left"><code>step</code></td><td align="left"><code>s</code></td><td align="left"><strong>单步执行（进入函数）</strong>。执行下一行代码，如果该行是函数调用，则进入该函数内部</td></tr><tr><td align="left"><code>finish</code></td><td align="left"><code>fin</code></td><td align="left">执行完当前函数，并停在函数返回后的位置</td></tr><tr><td align="left"><code>print expression</code></td><td align="left"><code>p</code></td><td align="left">计算并打印表达式的值（变量、表达式、函数调用结果等）</td></tr><tr><td align="left"><code>display expression</code></td><td align="left"><code>disp</code></td><td align="left">每次程序停止时自动打印表达式的值</td></tr><tr><td align="left"><code>info locals</code></td><td align="left"><code>i lo</code></td><td align="left">显示当前栈帧（函数）的局部变量</td></tr><tr><td align="left"><code>backtrace</code></td><td align="left"><code>bt</code></td><td align="left">显示函数调用栈（栈回溯）</td></tr><tr><td align="left"><code>frame [n]</code></td><td align="left"><code>f</code></td><td align="left">选择栈帧 <code>n</code>（<code>bt</code> 输出中的编号）。<code>f 0</code> 通常是当前正在执行的函数</td></tr><tr><td align="left"><code>watch expression</code></td><td align="left"></td><td align="left">设置<strong>观察点</strong>，当表达式的值被改变时暂停程序</td></tr><tr><td align="left"><strong><code>set var [variable]=[value]</code></strong></td><td align="left">set var</td><td align="left"><strong>运行时修改变量值</strong><br>（例：<code>set var x=10</code> 或 <code>set var ptr=0x7fffffffd</code>）</td></tr><tr><td align="left"><strong><code>disable breakpoints [n]</code></strong></td><td align="left"><code>dis b [n]</code></td><td align="left"><strong>禁用断点</strong><br>禁用指定编号的断点（如 <code>dis b 2</code>），若省略编号则禁用所有断点</td></tr><tr><td align="left"><strong><code>enable breakpoints [n]</code></strong></td><td align="left"><code>ena b [n]</code></td><td align="left"><strong>启用断点</strong><br>启用指定编号的断点（如 <code>ena b 1-3</code>），若省略编号则启用所有断点</td></tr><tr><td align="left"><strong><code>info breakpoints</code></strong></td><td align="left"><code>i b</code></td><td align="left"><strong>扩展说明：列出断点详情</strong><br>显示所有断点的<strong>编号、位置、启用状态、命中次数</strong><br>（例：<code>Num Type Disp Enb Address What</code>）</td></tr><tr><td align="left"><code>quit</code></td><td align="left"><code>q</code></td><td align="left">退出 GDB</td></tr></tbody></table><h4 id="7-3-开始调试"><a href="#7-3-开始调试" class="headerlink" title="7.3 开始调试"></a>7.3 开始调试</h4><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br><span class="line">114</span><br><span class="line">115</span><br><span class="line">116</span><br><span class="line">117</span><br><span class="line">118</span><br><span class="line">119</span><br><span class="line">120</span><br><span class="line">121</span><br><span class="line">122</span><br><span class="line">123</span><br><span class="line">124</span><br><span class="line">125</span><br><span class="line">126</span><br><span class="line">127</span><br><span class="line">128</span><br><span class="line">129</span><br><span class="line">130</span><br><span class="line">131</span><br><span class="line">132</span><br><span class="line">133</span><br><span class="line">134</span><br><span class="line">135</span><br><span class="line">136</span><br><span class="line">137</span><br><span class="line">138</span><br><span class="line">139</span><br></pre></td><td class="code"><pre><span class="line">$ gdb s2</span><br><span class="line">GNU gdb (Ubuntu 15.0.50.20240403-0ubuntu1) 15.0.50.20240403-git</span><br><span class="line">Copyright (C) 2024 Free Software Foundation, Inc.</span><br><span class="line">License GPLv3+: GNU GPL version 3 or later &lt;http://gnu.org/licenses/gpl.html&gt;</span><br><span class="line">This is free software: you are free to change and redistribute it.</span><br><span class="line">There is NO WARRANTY, to the extent permitted by law.</span><br><span class="line">Type <span class="string">&quot;show copying&quot;</span> and <span class="string">&quot;show warranty&quot;</span> <span class="keyword">for</span> details.</span><br><span class="line">This GDB was configured as <span class="string">&quot;x86_64-linux-gnu&quot;</span>.</span><br><span class="line">Type <span class="string">&quot;show configuration&quot;</span> <span class="keyword">for</span> configuration details.</span><br><span class="line">For bug reporting instructions, please see:</span><br><span class="line">&lt;https://www.gnu.org/software/gdb/bugs/&gt;.</span><br><span class="line">Find the GDB manual and other documentation resources online at:</span><br><span class="line">    &lt;http://www.gnu.org/software/gdb/documentation/&gt;.</span><br><span class="line"></span><br><span class="line">For <span class="built_in">help</span>, <span class="built_in">type</span> <span class="string">&quot;help&quot;</span>.</span><br><span class="line">Type <span class="string">&quot;apropos word&quot;</span> to search <span class="keyword">for</span> commands related to <span class="string">&quot;word&quot;</span>...</span><br><span class="line">Reading symbols from s2...</span><br><span class="line">(gdb) l <span class="comment"># 查看源代码</span></span><br><span class="line">1       <span class="comment">#include &lt;stdio.h&gt;</span></span><br><span class="line">2</span><br><span class="line">3       int Sum(int start, int end)</span><br><span class="line">4       &#123;</span><br><span class="line">5           int ret = 0;</span><br><span class="line">6           <span class="keyword">for</span> (int i = start; i &lt;= end; i++)</span><br><span class="line">7           &#123;</span><br><span class="line">8               ret += i;</span><br><span class="line">9           &#125;</span><br><span class="line">10          <span class="built_in">return</span> ret;</span><br><span class="line">(gdb) <span class="comment"># 在gdb中，上一次的命令可以直接通过回车的方式继续使用，而不需要再次输入</span></span><br><span class="line">11      &#125;</span><br><span class="line">12</span><br><span class="line">13      int main()</span><br><span class="line">14      &#123;</span><br><span class="line">15          int s = 0;</span><br><span class="line">16          int e = 100;</span><br><span class="line">17          <span class="built_in">printf</span>(<span class="string">&quot;Start Calculating\n&quot;</span>);</span><br><span class="line">18          int <span class="built_in">sum</span> = Sum(s,e);</span><br><span class="line">19          <span class="built_in">printf</span>(<span class="string">&quot;From %d to %d.Sum is %d\n&quot;</span>,s,e,<span class="built_in">sum</span>);</span><br><span class="line">20          <span class="built_in">return</span> 0;</span><br><span class="line">(gdb) </span><br><span class="line">21      &#125;</span><br><span class="line">(gdb) b 16 <span class="comment"># 创建断点，删除的时候通过断点的编号进行删除</span></span><br><span class="line">Breakpoint 1 at 0x11b0: file sum.c, line 16.</span><br><span class="line">(gdb) r</span><br><span class="line">Starting program: /home/wyf/s2 </span><br><span class="line"></span><br><span class="line">This GDB supports auto-downloading debuginfo from the following URLs:</span><br><span class="line">  &lt;https://debuginfod.ubuntu.com&gt;</span><br><span class="line">Enable debuginfod <span class="keyword">for</span> this session? (y or [n]) y</span><br><span class="line">Debuginfod has been enabled.</span><br><span class="line">To make this setting permanent, add <span class="string">&#x27;set debuginfod enabled on&#x27;</span> to .gdbinit.</span><br><span class="line">[Thread debugging using libthread_db enabled]</span><br><span class="line">Using host libthread_db library <span class="string">&quot;/lib/x86_64-linux-gnu/libthread_db.so.1&quot;</span>.</span><br><span class="line"></span><br><span class="line">Breakpoint 1, main () at sum.c:16</span><br><span class="line">16          int e = 100;</span><br><span class="line">(gdb) i lo <span class="comment"># 显示当前函数内的变量</span></span><br><span class="line">s = 0</span><br><span class="line">e = -8616</span><br><span class="line"><span class="built_in">sum</span> = 32767</span><br><span class="line">(gdb) n</span><br><span class="line">17          <span class="built_in">printf</span>(<span class="string">&quot;Start Calculating\n&quot;</span>);</span><br><span class="line">(gdb) </span><br><span class="line">Start Calculating</span><br><span class="line">18          int <span class="built_in">sum</span> = Sum(s,e);</span><br><span class="line">(gdb) s <span class="comment"># 进入函数内部</span></span><br><span class="line">Sum (start=0, end=100) at sum.c:5</span><br><span class="line">5           int ret = 0;</span><br><span class="line">(gdb) watch ret <span class="comment"># 监视ret的值，每次变换的时候都会停止</span></span><br><span class="line">Hardware watchpoint 2: ret</span><br><span class="line">(gdb) n</span><br><span class="line"></span><br><span class="line">Hardware watchpoint 2: ret</span><br><span class="line"></span><br><span class="line">Old value = -134230016</span><br><span class="line">New value = 0</span><br><span class="line">Sum (start=0, end=100) at sum.c:6</span><br><span class="line">6           <span class="keyword">for</span> (int i = start; i &lt;= end; i++)</span><br><span class="line">(gdb) n</span><br><span class="line">8               ret += i;</span><br><span class="line">(gdb) </span><br><span class="line">6           <span class="keyword">for</span> (int i = start; i &lt;= end; i++)</span><br><span class="line">(gdb) </span><br><span class="line">8               ret += i;</span><br><span class="line">(gdb) </span><br><span class="line"></span><br><span class="line">Hardware watchpoint 2: ret</span><br><span class="line"></span><br><span class="line">Old value = 0</span><br><span class="line">New value = 1</span><br><span class="line">Sum (start=0, end=100) at sum.c:6</span><br><span class="line">6           <span class="keyword">for</span> (int i = start; i &lt;= end; i++)</span><br><span class="line">(gdb) </span><br><span class="line">8               ret += i;</span><br><span class="line">(gdb) </span><br><span class="line"></span><br><span class="line">Hardware watchpoint 2: ret</span><br><span class="line"></span><br><span class="line">Old value = 1</span><br><span class="line">New value = 3</span><br><span class="line">Sum (start=0, end=100) at sum.c:6</span><br><span class="line">6           <span class="keyword">for</span> (int i = start; i &lt;= end; i++)</span><br><span class="line">(gdb)</span><br><span class="line"></span><br><span class="line">Hardware watchpoint 2: ret</span><br><span class="line"></span><br><span class="line">Old value = 3</span><br><span class="line">New value = 6</span><br><span class="line">Sum (start=0, end=100) at sum.c:6</span><br><span class="line">6           <span class="keyword">for</span> (int i = start; i &lt;= end; i++)</span><br><span class="line"></span><br><span class="line">(gdb) <span class="built_in">disable</span> 2 <span class="comment"># 移除当前观察点</span></span><br><span class="line">(gdb) fin <span class="comment"># 跳出当前函数</span></span><br><span class="line">Run till <span class="built_in">exit</span> from <span class="comment">#0  Sum (start=0, end=100) at sum.c:6</span></span><br><span class="line">0x00005555555551d5 <span class="keyword">in</span> main () at sum.c:18</span><br><span class="line">18          int <span class="built_in">sum</span> = Sum(s,e);</span><br><span class="line">Value returned is <span class="variable">$1</span> = 5050</span><br><span class="line">(gdb) n</span><br><span class="line">Watchpoint 2 deleted because the program has left the block</span><br><span class="line"><span class="keyword">in</span> <span class="built_in">which</span> its expression is valid.</span><br><span class="line">19          <span class="built_in">printf</span>(<span class="string">&quot;From %d to %d.Sum is %d\n&quot;</span>,s,e,<span class="built_in">sum</span>);</span><br><span class="line">(gdb) i lo</span><br><span class="line">s = 0</span><br><span class="line">e = 100</span><br><span class="line"><span class="built_in">sum</span> = 5050</span><br><span class="line">(gdb) n</span><br><span class="line">From 0 to 100.Sum is 5050</span><br><span class="line">20          <span class="built_in">return</span> 0;</span><br><span class="line">(gdb) </span><br><span class="line">21      &#125;</span><br><span class="line">(gdb) </span><br><span class="line">Download failed: Invalid argument.  Continuing without <span class="built_in">source</span> file ./csu/../sysdeps/nptl/libc_start_call_main.h.</span><br><span class="line">__libc_start_call_main (main=main@entry=0x55555555519d &lt;main&gt;, argc=argc@entry=1, argv=argv@entry=0x7fffffffde58)</span><br><span class="line">    at ../sysdeps/nptl/libc_start_call_main.h:74</span><br><span class="line">warning: 74     ../sysdeps/nptl/libc_start_call_main.h: No such file or directory</span><br><span class="line">(gdb) </span><br><span class="line">[Inferior 1 (process 1588250) exited normally]</span><br><span class="line">(gdb) q</span><br><span class="line">$</span><br></pre></td></tr></table></figure><h4 id="7-4-补充：设置条件断点（Conditional-Breakpoint）"><a href="#7-4-补充：设置条件断点（Conditional-Breakpoint）" class="headerlink" title="7.4 补充：设置条件断点（Conditional Breakpoint）"></a>7.4 补充：设置条件断点（Conditional Breakpoint）</h4><p>设置条件断点</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">break [位置] if [条件]</span><br></pre></td></tr></table></figure><p>或给已存在的断点添加条件</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">condition [断点编号] [条件]</span><br></pre></td></tr></table></figure><p><strong>具体使用方式</strong></p><table><thead><tr><th>场景</th><th>命令示例</th><th>说明</th></tr></thead><tbody><tr><td><strong>新建条件断点</strong></td><td><code>break main if argc &gt; 1</code></td><td>在 <code>main</code> 函数入口设置断点，仅当命令行参数&gt; <code>1</code> 时触发</td></tr><tr><td></td><td><code>break 18 if s == 0</code></td><td>在源代码 <code>18</code> 行设置断点，仅当变量 <code>s</code> 等于 <code>0</code> 时触发</td></tr><tr><td></td><td><code>break Sum if end &gt; 50</code></td><td>在 <code>Sum</code> 函数入口设置断点，仅当 <code>end</code> 参数 &gt; <code>50</code> 时触发</td></tr><tr><td><strong>修改现有断点</strong></td><td><code>condition 1 i == 50</code></td><td>为 <code>1</code> 号断点添加条件：仅当变量 <code>i</code> 等于 <code>50</code> 时触发</td></tr><tr><td></td><td><code>condition 2 ret % 5 == 0</code></td><td>为 <code>2</code> 号断点添加条件：仅当ret是5的倍数时触发</td></tr><tr><td><strong>删除条件</strong></td><td><code>condition 3</code></td><td>删除 <code>3</code> 号断点的条件（变为普通断点）</td></tr></tbody></table><blockquote><p>小技巧：使用 ignore [断点编号] [次数] 可以忽略断点前N次触发，如 ignore 1 100会跳过1号断点的前100次触发</p></blockquote>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>Linux基础指令</title>
      <link href="/2025/11/18/Linux%E5%9F%BA%E7%A1%80%E6%8C%87%E4%BB%A4/"/>
      <url>/2025/11/18/Linux%E5%9F%BA%E7%A1%80%E6%8C%87%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h1 id="Linux-基础指令大全"><a href="#Linux-基础指令大全" class="headerlink" title="Linux 基础指令大全"></a>Linux 基础指令大全</h1><h2 id="1-文件与目录操作"><a href="#1-文件与目录操作" class="headerlink" title="1. 文件与目录操作"></a>1. 文件与目录操作</h2><h3 id="前导知识"><a href="#前导知识" class="headerlink" title="前导知识"></a>前导知识</h3><h4 id="路径的认识"><a href="#路径的认识" class="headerlink" title="路径的认识"></a>路径的认识</h4><ul><li><code>Linux</code> 系统中，磁盘上的文件和目录被组成一棵目录树，每个节点都是目录或文件</li><li>其中普通文件一定是目录树的叶子节点</li><li>目录可能是叶子(空目录), 也可能是路上节点</li><li>理解路径存在的意义: 树状组织方式，都是为了保证快速定位查找到指定的文件，而定位文件就<br>需要具有唯一性的方案来进行定位文件。其中任何一个节点，都只有一个父节点，所以，从根目<br>录开始，定位指定文件，路径具有唯一性</li><li>绝对路径：一般从&#x2F;开始，不依赖其他目录的定位文件的方式</li><li>相对路径：相对于当前用户所处目录，定位文件的路径方式</li><li>绝对路径一般不会随着用户的路径变化而丧失唯一性，一般在特定服务的配置文件中经常被使用</li><li>相对路径因为它的便捷性，一般在命令行中使用较多</li></ul><!-- ![1744286395406](image/Linux基础指令/1744286395406.png) --><img src="/2025/11/18/Linux%E5%9F%BA%E7%A1%80%E6%8C%87%E4%BB%A4/1744286395406.png" class=""><!-- ![alt text](image/Linux基础指令/目录.png) --><img src="/2025/11/18/Linux%E5%9F%BA%E7%A1%80%E6%8C%87%E4%BB%A4/%E7%9B%AE%E5%BD%95.png" class=""><h4 id="文件的认识"><a href="#文件的认识" class="headerlink" title="文件的认识"></a>文件的认识</h4><p><code>Linux</code> 下的文件一般形式如下</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">-rw-rw-r-- 1 wyf wyf 3709 Apr 11 21:28 file.txt</span><br></pre></td></tr></table></figure><!-- ![alt text](image/Linux基础指令/文件.png) --><img src="/2025/11/18/Linux%E5%9F%BA%E7%A1%80%E6%8C%87%E4%BB%A4/%E6%96%87%E4%BB%B6.png" class=""><h3 id="1-1-ls-——-列出目录内容"><a href="#1-1-ls-——-列出目录内容" class="headerlink" title="1.1 ls —— 列出目录内容"></a>1.1 ls —— 列出目录内容</h3><p><strong>语法：</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">ls</span> [选项] [目录或文件]</span><br></pre></td></tr></table></figure><p><strong>功能：</strong> 显示指定目录下的文件和子目录，对于目录，列出该目录下的所有子目录与文件，对于文件，列出文件名以及其他信息</p><p><strong>常用选项：</strong></p><ul><li><code>-a</code> 列出目录下的所有文件，包括以 . 开头的隐含文件</li><li><code>-d</code> 将目录像文件⼀样显示，而不是显示其下的文件。 如：<code>ls ‒d</code> 指定目录</li><li><code>-i</code> 输出文件的 <code>i</code> 节点的索引信息。 如 <code>ls ‒ai</code> 指定文件</li><li><code>-k</code> 以 <code>k</code> 字节的形式表示文件的大小。<code>ls ‒alk</code> 指定文件</li><li><code>-n</code> 用数字的 <code>UID</code>,<code>GID</code> 代替名称</li><li><code>-F</code> 在每个文件名后附上⼀个字符以说明该文件的类型，“*”表示可执行的普通文件；“&#x2F;”表示<br>目录；“@”表示符号链接；“|”表示 <code>FIFOs</code>；“&#x3D;”表示套接字(<code>sockets</code>)（目录类型识别）</li><li><code>-r</code> 对目录反向排序</li><li><code>-t </code>以时间排序</li><li><code>-s</code> 在l文件名后输出该文件的大小（大小排序，如何找到⽬录下最大的文件）</li><li><code>-R</code> 列出所有子目录下的文件(递归)</li><li><code>-1</code> 一行只输出⼀个文件</li></ul><h4 id="UID和GID"><a href="#UID和GID" class="headerlink" title="UID和GID"></a>UID和GID</h4><p><strong>UID(User ID)</strong></p><ul><li>定义：每个用户账号的唯一数字标识符 </li><li>分类：<ul><li><code>Root</code> 用户：<code>UID</code> 为 <code>0</code>，拥有最高权限</li><li>系统用户：<code>UID</code> 范围通常为 <code>1-999</code>(<code>Debian</code> 系)或 <code>1-499</code>(<code>RHEL</code> 系)</li><li>普通用户：<code>UID</code> 从 <code>1000</code>(旧系统从 <code>500</code>)开始，由管理员创建</li></ul></li><li>作用<ul><li>系统通过 <code>UID</code> 识别用户身份</li><li>文件或进程的所有者信息以 <code>UID</code> 形式存储</li><li>权限检查时，系统将用户名转换为对应的 <code>UID</code></li></ul></li></ul><p><strong>GID(Group ID)</strong><br>每个用户组的唯一标识符</p><ul><li>分类<ul><li>主组(<code>Primary Group</code>)：用户创建文件时默认归属的组（每个用户必须属于一个主组）</li><li>附加组(<code>Supplementary Group</code>)：用户可加入多个附加组，用于获取额外权限</li></ul></li><li>作用<ul><li>控制组成员对资源的共享访问权限</li><li>文件或目录的所属组以 <code>GID</code> 形式存储</li></ul></li></ul><p><strong><code>..</code>和<code>.</code></strong></p><ul><li><code>..</code> 表示上一级路径，类似 <code>于Windows</code> 下的返回上一级文件夹</li><li><code>.</code> 表示当前路径，在 <code>Linux</code> 下，执行某个可执行文件时，需要用到 <code>.</code> 如 <code>./程序名</code></li></ul><p><strong>示例：</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">ls</span></span><br><span class="line">dir1  log.txt  test.txt</span><br><span class="line">$ <span class="built_in">ls</span> -a</span><br><span class="line">.  ..  dir1  log.txt  test.txt</span><br><span class="line">$ <span class="built_in">ls</span> -al</span><br><span class="line">total 16</span><br><span class="line">drwxrwxr-x  3 wyf wyf 4096 Apr 10 19:52 .</span><br><span class="line">drwx------ 15 wyf wyf 4096 Apr 10 19:51 ..</span><br><span class="line">drwxrwxr-x  2 wyf wyf 4096 Apr 10 19:52 dir1</span><br><span class="line">-rw-rw-r--  1 wyf wyf   10 Apr 10 19:52 log.txt</span><br><span class="line">-rw-rw-r--  1 wyf wyf    0 Apr 10 19:52 test.txt</span><br><span class="line">$ <span class="built_in">ls</span> -a -l -F</span><br><span class="line">total 16</span><br><span class="line">drwxrwxr-x  3 wyf wyf 4096 Apr 10 19:52 ./</span><br><span class="line">drwx------ 15 wyf wyf 4096 Apr 10 19:51 ../</span><br><span class="line">drwxrwxr-x  2 wyf wyf 4096 Apr 10 19:52 dir1/</span><br><span class="line">-rw-rw-r--  1 wyf wyf   10 Apr 10 19:52 log.txt</span><br><span class="line">-rw-rw-r--  1 wyf wyf    0 Apr 10 19:52 test.txt</span><br><span class="line">$ <span class="built_in">ls</span> -alFn</span><br><span class="line">total 16</span><br><span class="line">drwxrwxr-x  3 1000 1000 4096 Apr 10 19:52 ./</span><br><span class="line">drwx------ 15 1000 1000 4096 Apr 10 19:51 ../</span><br><span class="line">drwxrwxr-x  2 1000 1000 4096 Apr 10 19:52 dir1/</span><br><span class="line">-rw-rw-r--  1 1000 1000   10 Apr 10 19:52 log.txt</span><br><span class="line">-rw-rw-r--  1 1000 1000    0 Apr 10 19:52 test.txt</span><br></pre></td></tr></table></figure><h3 id="1-2-pwd-——-显示当前目录"><a href="#1-2-pwd-——-显示当前目录" class="headerlink" title="1.2 pwd —— 显示当前目录"></a>1.2 pwd —— 显示当前目录</h3><p><strong>语法：</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">pwd</span></span><br></pre></td></tr></table></figure><p><strong>功能：</strong> 显示当前所在的绝对路径</p><p><strong>示例：</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">pwd</span></span><br><span class="line">/home/wyf/test</span><br></pre></td></tr></table></figure><h3 id="1-3-cd-——-切换目录"><a href="#1-3-cd-——-切换目录" class="headerlink" title="1.3 cd —— 切换目录"></a>1.3 cd —— 切换目录</h3><p><strong>语法：</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cd</span> [目录]</span><br></pre></td></tr></table></figure><p><strong>功能：</strong> 切换到指定目录<br><strong>常用选项：</strong></p><ul><li><code>cd ..</code>  返回上一级目录</li><li><code>cd ~</code>  回到当前用户的主目录</li><li><code>cd -</code>  返回上一次所在的目录<br><strong>示例：</strong></li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">pwd</span></span><br><span class="line">/home/wyf/test</span><br><span class="line">$ <span class="built_in">cd</span> ..</span><br><span class="line">$ <span class="built_in">pwd</span></span><br><span class="line">/home/wyf</span><br><span class="line">$ <span class="built_in">cd</span></span><br><span class="line">$ <span class="built_in">pwd</span></span><br><span class="line">/home/wyf</span><br><span class="line">$ <span class="built_in">cd</span> /</span><br><span class="line">$ <span class="built_in">ls</span></span><br><span class="line">bin                  dev   lib         media  proc  sbin  tmp</span><br><span class="line">boot                 etc   lib64       mnt    root  srv   usr</span><br><span class="line">CloudrResetPwdAgent  home  lost+found  opt    run   sys   var</span><br></pre></td></tr></table></figure><h3 id="1-4-stat-——-查看文件详细属性"><a href="#1-4-stat-——-查看文件详细属性" class="headerlink" title="1.4 stat —— 查看文件详细属性"></a>1.4 stat —— 查看文件详细属性</h3><p><strong>语法</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">file 文件名</span><br></pre></td></tr></table></figure><p><strong>功能</strong> 显示文件详细属性(创建、修改时间等)<br><strong>示例</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">stat</span> test.txt </span><br><span class="line">  File: ‘test.txt’</span><br><span class="line">  Size: 40        Blocks: 8          IO Block: 4096   regular file</span><br><span class="line">Device: fd01h/64769dInode: 666552      Links: 1</span><br><span class="line">Access: (0664/-rw-rw-r--)  Uid: ( 1000/     wyf)   Gid: ( 1000/     wyf)</span><br><span class="line">Access: 2025-04-11 21:08:48.117273895 +0800</span><br><span class="line">Modify: 2025-04-11 20:51:27.045964812 +0800</span><br><span class="line">Change: 2025-04-11 20:57:28.980548460 +0800</span><br><span class="line"> Birth: 2025-04-11 15:12:08.209514658 +0800</span><br><span class="line">$ </span><br></pre></td></tr></table></figure><h3 id="1-5-file-——-检测文件类型"><a href="#1-5-file-——-检测文件类型" class="headerlink" title="1.5  file —— 检测文件类型"></a>1.5  file —— 检测文件类型</h3><p><strong>语法</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">file 文件名</span><br></pre></td></tr></table></figure><p><strong>功能</strong> 检测文件类型(如二进制、文本、目录等)<br><strong>示例</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ file file.txt </span><br><span class="line">file.txt: ASCII text</span><br><span class="line">$ file <span class="built_in">dir</span>/</span><br><span class="line"><span class="built_in">dir</span>/: directory</span><br><span class="line">$ file a.out </span><br><span class="line">a.out: ELF 64-bit LSB executable, x86-64, version 1 (SYSV), dynamically linked (uses shared libs), <span class="keyword">for</span> GNU/Linux 2.6.32, BuildID[sha1]=241baf96d17e6e4644f4acb5dcbee88d768eca65, not stripped</span><br><span class="line">$ </span><br></pre></td></tr></table></figure><h3 id="1-6-wc-——-统计行数、字数"><a href="#1-6-wc-——-统计行数、字数" class="headerlink" title="1.6 wc —— 统计行数、字数"></a>1.6 wc —— 统计行数、字数</h3><p><strong>语法</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">wc</span> [选项] 文件名</span><br></pre></td></tr></table></figure><p><strong>功能</strong> 统计文件行数、字数、字节数<br><strong>常用选项</strong></p><ul><li><code>-l</code>统计行数</li><li><code>-w</code>统计单词数</li><li><code>-c</code>统计字节数</li><li><code>-m</code>统计字符数<br><strong>示例</strong></li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">wc</span> -wl log.txt</span><br><span class="line"> 6 12 log.txt</span><br><span class="line">$ <span class="built_in">wc</span> -c log.txt</span><br><span class="line"> 72 log.txt</span><br><span class="line">$ <span class="built_in">wc</span> -m log.txt</span><br><span class="line"> 72 log.txt</span><br><span class="line">$ </span><br></pre></td></tr></table></figure><h3 id="1-7-touch-——-创建空文件"><a href="#1-7-touch-——-创建空文件" class="headerlink" title="1.7 touch —— 创建空文件"></a>1.7 touch —— 创建空文件</h3><p><strong>语法：</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">touch</span> [文件名]</span><br></pre></td></tr></table></figure><p><strong>功能：</strong> 创建一个新的空文件，也可以更改文档或目录的日期时间，包括存取时间和更改时间</p><p><strong>常用选项：</strong></p><ul><li><code>-a</code>  改变存取时间</li><li><code>-m</code>  仅修改修改时间</li><li><code>-c</code>  改变更改时间</li></ul><h4 id="Linux-文件的三种时间"><a href="#Linux-文件的三种时间" class="headerlink" title="Linux 文件的三种时间"></a>Linux 文件的三种时间</h4><table><thead><tr><th>时间字段</th><th>英文全称</th><th>含义</th><th>修改行为</th></tr></thead><tbody><tr><td><code>atime</code></td><td><strong>Access Time</strong></td><td>最近一次访问文件的时间（读）</td><td>被读取时自动更新</td></tr><tr><td><code>mtime</code></td><td><strong>Modify Time</strong></td><td>最近一次<strong>修改内容</strong>的时间</td><td>内容变化时更新</td></tr><tr><td><code>ctime</code></td><td><strong>Change Time</strong></td><td>最近一次<strong>元数据变化</strong>的时间（权限&#x2F;所有者&#x2F;链接数）</td><td><code>chmod</code>、<code>chown</code> 等操作更新</td></tr></tbody></table><h5 id="ls-显示不同时间的方式"><a href="#ls-显示不同时间的方式" class="headerlink" title="ls 显示不同时间的方式"></a>ls 显示不同时间的方式</h5><table><thead><tr><th>命令</th><th>显示哪个时间</th></tr></thead><tbody><tr><td><code>ls -l</code></td><td>默认显示 <strong>mtime</strong></td></tr><tr><td><code>ls -lu</code></td><td>显示 <strong>atime</strong></td></tr><tr><td><code>ls -lc</code></td><td>显示 <strong>ctime</strong></td></tr></tbody></table><h5 id="atime-有时不更新？"><a href="#atime-有时不更新？" class="headerlink" title="atime 有时不更新？"></a>atime 有时不更新？</h5><p>现代 <code>Linux</code> 出于性能考虑，很多系统挂载时带了 <code>relatime</code> 或 <code>noatime</code> 选项，不再频繁写磁盘更新 <code>atime</code>，可以查看当前挂载策略：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ mount | grep <span class="string">&#x27; / &#x27;</span></span><br></pre></td></tr></table></figure><p>看到有 <code>relatime</code> 或 <code>noatime</code> 的话，就说明访问时间不会每次都改，节省 <code>I</code>&#x2F;<code>O</code></p><p><strong>示例：</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">touch</span> file.txt</span><br><span class="line">$ <span class="built_in">ls</span></span><br><span class="line">dir1  file.txt  log.txt  test.txt</span><br><span class="line">$ <span class="built_in">stat</span> file.txt</span><br><span class="line">  File: ‘file.txt’</span><br><span class="line">  Size: 0         Blocks: 0          IO Block: 4096   regular empty file</span><br><span class="line">Device: fd01h/64769dInode: 666553      Links: 1</span><br><span class="line">Access: (0664/-rw-rw-r--)  Uid: ( 1000/     wyf)   Gid: ( 1000/     wyf)</span><br><span class="line">Access: 2025-04-10 21:22:15.526617258 +0800</span><br><span class="line">Modify: 2025-04-10 21:22:15.526617258 +0800</span><br><span class="line">Change: 2025-04-10 21:22:15.526617258 +0800</span><br><span class="line"> Birth: -</span><br><span class="line">$ <span class="built_in">touch</span> -a file.txt </span><br><span class="line">$ <span class="built_in">stat</span> file.txt</span><br><span class="line">  File: ‘file.txt’</span><br><span class="line">  Size: 0         Blocks: 0          IO Block: 4096   regular empty file</span><br><span class="line">Device: fd01h/64769dInode: 666553      Links: 1</span><br><span class="line">Access: (0664/-rw-rw-r--)  Uid: ( 1000/     wyf)   Gid: ( 1000/     wyf)</span><br><span class="line">Access: 2025-04-10 21:27:11.015538537 +0800 <span class="comment"># 访问时间发生变化</span></span><br><span class="line">Modify: 2025-04-10 21:22:15.526617258 +0800</span><br><span class="line">Change: 2025-04-10 21:27:11.015538537 +0800</span><br><span class="line"> Birth: -</span><br><span class="line">$ <span class="built_in">touch</span> -m file.txt </span><br><span class="line">$ <span class="built_in">stat</span> file.txt </span><br><span class="line">  File: ‘file.txt’</span><br><span class="line">  Size: 0         Blocks: 0          IO Block: 4096   regular empty file</span><br><span class="line">Device: fd01h/64769dInode: 666553      Links: 1</span><br><span class="line">Access: (0664/-rw-rw-r--)  Uid: ( 1000/     wyf)   Gid: ( 1000/     wyf)</span><br><span class="line">Access: 2025-04-10 21:27:11.015538537 +0800</span><br><span class="line">Modify: 2025-04-10 21:34:50.408080619 +0800 <span class="comment"># 修改时间发生变化</span></span><br><span class="line">Change: 2025-04-10 21:34:50.408080619 +0800</span><br><span class="line"> Birth: -</span><br></pre></td></tr></table></figure><h3 id="1-8-mkdir-——-创建目录"><a href="#1-8-mkdir-——-创建目录" class="headerlink" title="1.8 mkdir —— 创建目录"></a>1.8 mkdir —— 创建目录</h3><p><strong>语法：</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mkdir</span> [选项] 目录名</span><br></pre></td></tr></table></figure><p><strong>功能：</strong> 创建新的目录</p><p><strong>常用选项：</strong></p><ul><li><code>-p</code>  递归创建多级目录，就是一次创建多个目录</li></ul><p><strong>示例：</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">mkdir</span> mydir</span><br><span class="line">$ <span class="built_in">mkdir</span> -p mmmmmydir/mmmmydir/mmmdir/mmdir/mydir</span><br><span class="line">$ <span class="built_in">ls</span> -l</span><br><span class="line">total 16</span><br><span class="line">drwxrwxr-x 2 wyf wyf 4096 Apr 10 19:52 dir1</span><br><span class="line">-rw-rw-r-- 1 wyf wyf    0 Apr 10 21:34 file.txt</span><br><span class="line">-rw-rw-r-- 1 wyf wyf   10 Apr 10 19:52 log.txt</span><br><span class="line">drwxrwxr-x 3 wyf wyf 4096 Apr 10 21:38 mmmmmydir</span><br><span class="line">drwxrwxr-x 2 wyf wyf 4096 Apr 10 21:38 mydir</span><br><span class="line">-rw-rw-r-- 1 wyf wyf    0 Apr 10 19:52 test.txt</span><br><span class="line">$ tree mmmmmydir</span><br><span class="line">mmmmmydir</span><br><span class="line">└── mmmmydir</span><br><span class="line">    └── mmmdir</span><br><span class="line">        └── mmdir</span><br><span class="line">            └── mydir</span><br><span class="line"></span><br><span class="line">4 directories, 0 files</span><br><span class="line">$ </span><br><span class="line"><span class="comment"># tree 命令需要安装</span></span><br><span class="line"><span class="comment"># centos下安装命令为 yum -y install tree</span></span><br></pre></td></tr></table></figure><h3 id="1-9-diff-——-比较文件差异"><a href="#1-9-diff-——-比较文件差异" class="headerlink" title="1.9 diff —— 比较文件差异"></a>1.9 diff —— 比较文件差异</h3><p><strong>语法</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">diff 文件名1 文件名2</span><br></pre></td></tr></table></figure><p><strong>功能</strong> 比较文件差异<br><strong>常用选项</strong></p><ul><li><code>-u</code>以合并格式显示差异</li><li><code>-r</code>递归比较目录内容</li><li><code>-i</code>忽略大小写差异<br><strong>示例</strong></li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">$ diff a <span class="built_in">dir</span></span><br><span class="line">Only <span class="keyword">in</span> <span class="built_in">dir</span>: a.out</span><br><span class="line">Only <span class="keyword">in</span> a: b</span><br><span class="line">Only <span class="keyword">in</span> <span class="built_in">dir</span>: file.txt</span><br><span class="line">Only <span class="keyword">in</span> <span class="built_in">dir</span>: log.txt</span><br><span class="line">Only <span class="keyword">in</span> <span class="built_in">dir</span>: test.c</span><br><span class="line">Only <span class="keyword">in</span> <span class="built_in">dir</span>: test.txt</span><br><span class="line">$ diff -r a <span class="built_in">dir</span></span><br><span class="line">Only <span class="keyword">in</span> <span class="built_in">dir</span>: a.out</span><br><span class="line">Only <span class="keyword">in</span> a: b</span><br><span class="line">Only <span class="keyword">in</span> <span class="built_in">dir</span>: file.txt</span><br><span class="line">Only <span class="keyword">in</span> <span class="built_in">dir</span>: log.txt</span><br><span class="line">Only <span class="keyword">in</span> <span class="built_in">dir</span>: test.c</span><br><span class="line">Only <span class="keyword">in</span> <span class="built_in">dir</span>: test.txt</span><br><span class="line">$ diff -i a <span class="built_in">dir</span></span><br><span class="line">Only <span class="keyword">in</span> <span class="built_in">dir</span>: a.out</span><br><span class="line">Only <span class="keyword">in</span> a: b</span><br><span class="line">Only <span class="keyword">in</span> <span class="built_in">dir</span>: file.txt</span><br><span class="line">Only <span class="keyword">in</span> <span class="built_in">dir</span>: log.txt</span><br><span class="line">Only <span class="keyword">in</span> <span class="built_in">dir</span>: test.c</span><br><span class="line">Only <span class="keyword">in</span> <span class="built_in">dir</span>: test.txt</span><br><span class="line">$ </span><br></pre></td></tr></table></figure><h3 id="1-10-rmdir-和-rm-——-删除目录或文件"><a href="#1-10-rmdir-和-rm-——-删除目录或文件" class="headerlink" title="1.10 rmdir 和 rm —— 删除目录或文件"></a>1.10 rmdir 和 rm —— 删除目录或文件</h3><p><strong>语法：</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">rmdir</span> [目录名]  <span class="comment"># 仅删除空目录</span></span><br><span class="line"><span class="built_in">rm</span> [选项] [文件或目录]</span><br></pre></td></tr></table></figure><p><strong>功能：</strong> 删除文件或目录</p><p><strong>常用选项：</strong></p><ul><li>rmidr<ul><li><code>-p</code>   当子目录被删除后如果父目录也变成空目录的话，就连带父目录⼀起删除</li></ul></li><li>rm<ul><li><code>-r</code>  递归删除目录及其内容</li><li><code>-f</code>  强制删除</li><li><code>-i</code>  删除前逐一询问</li></ul></li></ul><p><strong>示例：</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">ls</span> -al</span><br><span class="line">total 24</span><br><span class="line">drwxrwxr-x  5 wyf wyf 4096 Apr 10 21:38 .</span><br><span class="line">drwx------ 15 wyf wyf 4096 Apr 10 19:51 ..</span><br><span class="line">drwxrwxr-x  2 wyf wyf 4096 Apr 10 19:52 dir1</span><br><span class="line">-rw-rw-r--  1 wyf wyf    0 Apr 10 21:34 file.txt</span><br><span class="line">-rw-rw-r--  1 wyf wyf   10 Apr 10 19:52 log.txt</span><br><span class="line">drwxrwxr-x  3 wyf wyf 4096 Apr 10 21:38 mmmmmydir</span><br><span class="line">drwxrwxr-x  2 wyf wyf 4096 Apr 10 21:38 mydir</span><br><span class="line">-rw-rw-r--  1 wyf wyf    0 Apr 10 19:52 test.txt</span><br><span class="line">$ <span class="built_in">rm</span> file.txt </span><br><span class="line">$ <span class="built_in">rm</span> mydir</span><br><span class="line"><span class="built_in">rm</span>: cannot remove ‘mydir’: Is a directory</span><br><span class="line">$ <span class="built_in">rm</span> -r mydir</span><br><span class="line">$ <span class="built_in">ls</span> -al</span><br><span class="line">total 20</span><br><span class="line">drwxrwxr-x  4 wyf wyf 4096 Apr 10 21:42 .</span><br><span class="line">drwx------ 15 wyf wyf 4096 Apr 10 19:51 ..</span><br><span class="line">drwxrwxr-x  2 wyf wyf 4096 Apr 10 19:52 dir1</span><br><span class="line">-rw-rw-r--  1 wyf wyf   10 Apr 10 19:52 log.txt</span><br><span class="line">drwxrwxr-x  3 wyf wyf 4096 Apr 10 21:38 mmmmmydir</span><br><span class="line">-rw-rw-r--  1 wyf wyf    0 Apr 10 19:52 test.txt</span><br><span class="line"><span class="comment"># 删除普通文件前询问</span></span><br><span class="line">$ <span class="built_in">rm</span> -i log.txt</span><br><span class="line"><span class="built_in">rm</span>: remove regular file ‘log.txt’? y</span><br><span class="line">$ <span class="built_in">ls</span> -al</span><br><span class="line">total 16</span><br><span class="line">drwxrwxr-x  4 wyf wyf 4096 Apr 10 21:43 .</span><br><span class="line">drwx------ 15 wyf wyf 4096 Apr 10 19:51 ..</span><br><span class="line">drwxrwxr-x  2 wyf wyf 4096 Apr 10 19:52 dir1</span><br><span class="line">drwxrwxr-x  3 wyf wyf 4096 Apr 10 21:38 mmmmmydir</span><br><span class="line">-rw-rw-r--  1 wyf wyf    0 Apr 10 19:52 test.txt</span><br><span class="line"><span class="comment"># 删除目录前逐一询问</span></span><br><span class="line">$ <span class="built_in">rm</span> -ri mmmmmydir/</span><br><span class="line"><span class="built_in">rm</span>: descend into directory ‘mmmmmydir/’? n</span><br><span class="line"><span class="comment"># 递归强制删除非空目录</span></span><br><span class="line">$ <span class="built_in">rm</span> -rf mmmmmydir</span><br><span class="line">$ <span class="built_in">ls</span> -al</span><br><span class="line">total 12</span><br><span class="line">drwxrwxr-x  3 wyf wyf 4096 Apr 10 21:44 .</span><br><span class="line">drwx------ 15 wyf wyf 4096 Apr 10 19:51 ..</span><br><span class="line">drwxrwxr-x  2 wyf wyf 4096 Apr 10 19:52 dir1</span><br><span class="line">-rw-rw-r--  1 wyf wyf    0 Apr 10 19:52 test.txt</span><br></pre></td></tr></table></figure><h2 id="2-文件操作"><a href="#2-文件操作" class="headerlink" title="2. 文件操作"></a>2. 文件操作</h2><h3 id="2-1-cp-——-复制文件或目录"><a href="#2-1-cp-——-复制文件或目录" class="headerlink" title="2.1 cp —— 复制文件或目录"></a>2.1 cp —— 复制文件或目录</h3><p><strong>语法：</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cp</span> [选项] 源文件 目标文件</span><br></pre></td></tr></table></figure><p><strong>功能：</strong> 复制文件或目录</p><p><strong>注意</strong></p><ul><li>如果同时指定两个以上的文件或目录，并且最后一个目的目录是一个已经存在的目录，则会把前面指定的所有文件或目录复制到此目录中</li></ul><p><strong>常用选项：</strong></p><ul><li><code>-f</code> 强行复制文件或目录， 不论目的文件或目录是否已经存在</li><li><code>-r</code>  递归复制目录，将指定目录下的文件与子目录一并处理</li><li><code>-p</code>  保持文件属性</li><li><code>-i</code>  覆盖文件前提示确认</li></ul><p><strong>示例：</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">ls</span> -al</span><br><span class="line">total 12</span><br><span class="line">drwxrwxr-x  3 wyf wyf 4096 Apr 10 21:44 .</span><br><span class="line">drwx------ 15 wyf wyf 4096 Apr 10 19:51 ..</span><br><span class="line">drwxrwxr-x  2 wyf wyf 4096 Apr 10 19:52 dir1</span><br><span class="line">-rw-rw-r--  1 wyf wyf    0 Apr 10 19:52 test.txt</span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">&quot;Hello World&quot;</span> &gt; test.txt</span><br><span class="line"><span class="comment"># echo命令是</span></span><br><span class="line">$ <span class="built_in">ls</span> -al</span><br><span class="line">total 16</span><br><span class="line">drwxrwxr-x  3 wyf wyf 4096 Apr 10 21:44 .</span><br><span class="line">drwx------ 15 wyf wyf 4096 Apr 10 19:51 ..</span><br><span class="line">drwxrwxr-x  2 wyf wyf 4096 Apr 10 19:52 dir1</span><br><span class="line">-rw-rw-r--  1 wyf wyf   12 Apr 10 21:47 test.txt</span><br><span class="line">$ <span class="built_in">cat</span> test.txt </span><br><span class="line">Hello World</span><br><span class="line">$ <span class="built_in">cp</span> test.txt dir1/</span><br><span class="line">$ <span class="built_in">cat</span> dir1/test.txt </span><br><span class="line">Hello World</span><br><span class="line">$ <span class="built_in">mkdir</span> log.txt</span><br><span class="line">$ <span class="built_in">ls</span> -al &gt; log.txt</span><br><span class="line"><span class="comment"># &gt; 是重定向符号，可以将原本输出到显示器的内容重定向到指定文件中，&gt; h会清空文件，文件不存在就新建；&gt;&gt; 追加重定向，是在文件中追加，不会清空文件</span></span><br><span class="line">$ <span class="built_in">ls</span> -al</span><br><span class="line">total 20</span><br><span class="line">drwxrwxr-x  3 wyf wyf 4096 Apr 10 21:49 .</span><br><span class="line">drwx------ 15 wyf wyf 4096 Apr 10 19:51 ..</span><br><span class="line">drwxrwxr-x  2 wyf wyf 4096 Apr 10 21:48 dir1</span><br><span class="line">-rw-rw-r--  1 wyf wyf  236 Apr 10 21:49 log.txt</span><br><span class="line">-rw-rw-r--  1 wyf wyf   12 Apr 10 21:47 test.txt</span><br><span class="line">$ <span class="built_in">cp</span> *.txt dir1/</span><br><span class="line"><span class="comment"># * 表示通配符，匹配所有以 .txt结尾的文件</span></span><br><span class="line">$ <span class="built_in">cd</span> dir1/</span><br><span class="line">$ <span class="built_in">ls</span> -al</span><br><span class="line">total 16</span><br><span class="line">drwxrwxr-x 2 wyf wyf 4096 Apr 10 21:49 .</span><br><span class="line">drwxrwxr-x 3 wyf wyf 4096 Apr 10 21:49 ..</span><br><span class="line">-rw-rw-r-- 1 wyf wyf  236 Apr 10 21:49 log.txt</span><br><span class="line">-rw-rw-r-- 1 wyf wyf   12 Apr 10 21:49 test.txt</span><br><span class="line">$ <span class="built_in">cat</span> log.txt</span><br><span class="line">total 16</span><br><span class="line">drwxrwxr-x  3 wyf wyf 4096 Apr 10 21:49 .</span><br><span class="line">drwx------ 15 wyf wyf 4096 Apr 10 19:51 ..</span><br><span class="line">drwxrwxr-x  2 wyf wyf 4096 Apr 10 21:48 dir1</span><br><span class="line">-rw-rw-r--  1 wyf wyf    0 Apr 10 21:49 log.txt</span><br><span class="line">-rw-rw-r--  1 wyf wyf   12 Apr 10 21:47 test.txt</span><br><span class="line">$ <span class="built_in">cp</span> log.txt test.txt</span><br><span class="line"><span class="comment"># cp 命令遇到目标文件存在的情况，不会询问是否覆盖，而是直接覆盖</span></span><br><span class="line">$ <span class="built_in">ls</span> -al</span><br><span class="line">total 16</span><br><span class="line">drwxrwxr-x 2 wyf wyf 4096 Apr 10 21:49 .</span><br><span class="line">drwxrwxr-x 3 wyf wyf 4096 Apr 10 21:49 ..</span><br><span class="line">-rw-rw-r-- 1 wyf wyf  236 Apr 10 21:49 log.txt</span><br><span class="line">-rw-rw-r-- 1 wyf wyf  236 Apr 10 21:50 test.txt</span><br><span class="line">$ <span class="built_in">cat</span> log.txt</span><br><span class="line">total 16</span><br><span class="line">drwxrwxr-x  3 wyf wyf 4096 Apr 10 21:49 .</span><br><span class="line">drwx------ 15 wyf wyf 4096 Apr 10 19:51 ..</span><br><span class="line">drwxrwxr-x  2 wyf wyf 4096 Apr 10 21:48 dir1</span><br><span class="line">-rw-rw-r--  1 wyf wyf    0 Apr 10 21:49 log.txt</span><br><span class="line">-rw-rw-r--  1 wyf wyf   12 Apr 10 21:47 test.txt</span><br></pre></td></tr></table></figure><h3 id="2-2-mv-——-移动或重命名文件"><a href="#2-2-mv-——-移动或重命名文件" class="headerlink" title="2.2 mv —— 移动或重命名文件"></a>2.2 mv —— 移动或重命名文件</h3><p><strong>语法：</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">mv</span> [选项] 源文件 目标文件</span><br></pre></td></tr></table></figure><p><strong>功能：</strong> 移动或重命名文件</p><p><strong>常用选项：</strong></p><ul><li><code>-f</code>  如果目标文件已经存在，不会询问而直接覆盖</li><li><code>-i</code>  覆盖前提示(如果目标文件已经存在，就会询问是否覆盖)</li><li><code>-u</code>  仅移动更新的文件</li></ul><p><strong>示例：</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">ls</span> -al</span><br><span class="line">total 12</span><br><span class="line">drwxrwxr-x  3 wyf wyf 4096 Apr 11 20:06 .</span><br><span class="line">drwx------ 15 wyf wyf 4096 Apr 10 19:51 ..</span><br><span class="line">drwxrwxr-x  2 wyf wyf 4096 Apr 11 20:05 mydir</span><br><span class="line">-rw-rw-r--  1 wyf wyf    0 Apr 11 20:05 myfile.txt</span><br><span class="line">$ <span class="built_in">ls</span> -al &gt; myfile.txt</span><br><span class="line">$ <span class="built_in">mv</span> myfile.txt mydir/</span><br><span class="line">$ <span class="built_in">ls</span> -al</span><br><span class="line">total 12</span><br><span class="line">drwxrwxr-x  3 wyf wyf 4096 Apr 11 20:07 .</span><br><span class="line">drwx------ 15 wyf wyf 4096 Apr 10 19:51 ..</span><br><span class="line">drwxrwxr-x  2 wyf wyf 4096 Apr 11 20:07 mydir</span><br><span class="line">$ <span class="built_in">cd</span> mydir</span><br><span class="line">$ <span class="built_in">ls</span> -al</span><br><span class="line">total 12</span><br><span class="line">drwxrwxr-x 2 wyf wyf 4096 Apr 11 20:07 .</span><br><span class="line">drwxrwxr-x 3 wyf wyf 4096 Apr 11 20:07 ..</span><br><span class="line">-rw-rw-r-- 1 wyf wyf  191 Apr 11 20:06 myfile.txt</span><br><span class="line">$ <span class="built_in">touch</span> mmfile.txt</span><br><span class="line">$ <span class="built_in">ls</span> -al</span><br><span class="line">total 12</span><br><span class="line">drwxrwxr-x 2 wyf wyf 4096 Apr 11 20:07 .</span><br><span class="line">drwxrwxr-x 3 wyf wyf 4096 Apr 11 20:07 ..</span><br><span class="line">-rw-rw-r-- 1 wyf wyf    0 Apr 11 20:07 mmfile.txt</span><br><span class="line">-rw-rw-r-- 1 wyf wyf  191 Apr 11 20:06 myfile.txt</span><br><span class="line">$ <span class="built_in">mv</span> myfile.txt mmfile.txt</span><br><span class="line"><span class="comment"># 如果当前路径存在同名文件，重命名就会覆盖，并且没有提示 </span></span><br><span class="line">$ <span class="built_in">ls</span> -al</span><br><span class="line">total 12</span><br><span class="line">drwxrwxr-x 2 wyf wyf 4096 Apr 11 20:08 .</span><br><span class="line">drwxrwxr-x 3 wyf wyf 4096 Apr 11 20:07 ..</span><br><span class="line">-rw-rw-r-- 1 wyf wyf  191 Apr 11 20:06 mmfile.txt</span><br><span class="line">$ <span class="built_in">touch</span> myfile.txt</span><br><span class="line"><span class="comment"># 添加询问选项，让用户做出选择</span></span><br><span class="line">$ <span class="built_in">mv</span> -i mmfile.txt  myfile.txt</span><br><span class="line"><span class="built_in">mv</span>: overwrite ‘myfile.txt’? y</span><br><span class="line">$ <span class="built_in">ls</span> -al</span><br><span class="line">total 12</span><br><span class="line">drwxrwxr-x 2 wyf wyf 4096 Apr 11 20:08 .</span><br><span class="line">drwxrwxr-x 3 wyf wyf 4096 Apr 11 20:07 ..</span><br><span class="line">-rw-rw-r-- 1 wyf wyf  191 Apr 11 20:06 myfile.txt</span><br></pre></td></tr></table></figure><h3 id="2-3-cat-——-查看文件内容"><a href="#2-3-cat-——-查看文件内容" class="headerlink" title="2.3 cat —— 查看文件内容"></a>2.3 cat —— 查看文件内容</h3><p><strong>语法：</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">cat</span> [选项] 文件名</span><br></pre></td></tr></table></figure><p><strong>功能：</strong> 查看目标文件内容</p><p><strong>常用选项：</strong></p><ul><li><code>-b</code> 对⾮空输出⾏编号</li><li><code>-n</code> 对输出的所有⾏编号</li><li><code>-s</code> 不输出多⾏空⾏</li><li><code>-n</code>  显示行号</li><li><code>-E</code>  显示行尾的 <code>$</code></li></ul><p><strong>示例：</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">ls</span> -al</span><br><span class="line">total 12</span><br><span class="line">drwxrwxr-x 2 wyf wyf 4096 Apr 11 20:13 .</span><br><span class="line">drwxrwxr-x 3 wyf wyf 4096 Apr 11 20:07 ..</span><br><span class="line">-rw-rw-r-- 1 wyf wyf  103 Apr 11 20:15 test.txt</span><br><span class="line">$ <span class="built_in">cat</span> test.txt </span><br><span class="line">Hello World</span><br><span class="line">Hello World</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Hello World</span><br><span class="line"></span><br><span class="line">Hello World</span><br><span class="line"></span><br><span class="line">Hello World</span><br><span class="line"></span><br><span class="line">Hello World</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">Hello World</span><br><span class="line">Hello World</span><br><span class="line"><span class="comment"># 对输出所有行编号</span></span><br><span class="line">$ <span class="built_in">cat</span> -n test.txt </span><br><span class="line">     1Hello World</span><br><span class="line">     2Hello World</span><br><span class="line">     3</span><br><span class="line">     4</span><br><span class="line">     5Hello World</span><br><span class="line">     6</span><br><span class="line">     7Hello World</span><br><span class="line">     8</span><br><span class="line">     9Hello World</span><br><span class="line">    10</span><br><span class="line">    11Hello World</span><br><span class="line">    12</span><br><span class="line">    13</span><br><span class="line">    14Hello World</span><br><span class="line">    15Hello World</span><br><span class="line"><span class="comment"># 不输出多行空行，多行空行压缩为一行</span></span><br><span class="line">$ <span class="built_in">cat</span> -s test.txt </span><br><span class="line">Hello World</span><br><span class="line">Hello World</span><br><span class="line"></span><br><span class="line">Hello World</span><br><span class="line"></span><br><span class="line">Hello World</span><br><span class="line"></span><br><span class="line">Hello World</span><br><span class="line"></span><br><span class="line">Hello World</span><br><span class="line"></span><br><span class="line">Hello World</span><br><span class="line">Hello World</span><br><span class="line"><span class="comment"># 对非空输出行编号</span></span><br><span class="line">$ <span class="built_in">cat</span> -b test.txt </span><br><span class="line">     1Hello World</span><br><span class="line">     2Hello World</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">     3Hello World</span><br><span class="line"></span><br><span class="line">     4Hello World</span><br><span class="line"></span><br><span class="line">     5Hello World</span><br><span class="line"></span><br><span class="line">     6Hello World</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">     7Hello World</span><br><span class="line">     8Hello World</span><br></pre></td></tr></table></figure><h3 id="2-4-more-less-——-分页查看文件内容"><a href="#2-4-more-less-——-分页查看文件内容" class="headerlink" title="2.4 more &#x2F; less —— 分页查看文件内容"></a>2.4 more &#x2F; less —— 分页查看文件内容</h3><p><strong>语法：</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">more 文件名</span><br><span class="line">less 文件名</span><br></pre></td></tr></table></figure><p><strong>功能：</strong> </p><ul><li><code>more</code><ul><li><code>more</code> 类似于 <code>cat</code>，直接全部输出</li></ul></li><li><code>less</code><ul><li><code>less</code> 的功能比 <code>more</code> 强大(<strong>less is more</strong>)</li><li><code>less</code> 可以前后翻阅，而不是一次性全部打印出来</li><li><code>less</code> 还具有搜索功能，既可以向上搜，也可以向下搜<br><strong>常用选项：</strong></li></ul></li><li><code>-i</code>  忽略搜索时的⼤⼩写</li><li><code>-N</code>  显⽰每⾏的⾏号</li><li><code>/字符串</code> 向下搜索“字符串”的功能</li><li><code>?字符串</code> 向上搜索“字符串”的功能</li><li><code>n</code>   重复前⼀个搜索（与 <code>/</code> 或 <code>?</code> 有关）</li><li><code>N</code>   反向重复前⼀个搜索（与 <code>/</code> 或 <code>?</code> 有关）</li><li><code>q</code>   退出<br><strong>示例：</strong></li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># more</span></span><br><span class="line">$ <span class="built_in">ls</span> -al</span><br><span class="line">total 12</span><br><span class="line">drwxrwxr-x 2 wyf wyf 4096 Apr 11 20:13 .</span><br><span class="line">drwxrwxr-x 3 wyf wyf 4096 Apr 11 20:07 ..</span><br><span class="line">-rw-rw-r-- 1 wyf wyf 3709 Apr 11 20:19 test.txt</span><br><span class="line">$ more test.txt </span><br><span class="line">Hello World -&gt; 0</span><br><span class="line">Hello World -&gt; 1</span><br><span class="line">Hello World -&gt; 2</span><br><span class="line">Hello World -&gt; 3</span><br><span class="line">Hello World -&gt; 4</span><br><span class="line">Hello World -&gt; 5</span><br><span class="line">Hello World -&gt; 6</span><br><span class="line">Hello World -&gt; 7</span><br><span class="line">Hello World -&gt; 8</span><br><span class="line">Hello World -&gt; 9</span><br><span class="line">Hello World -&gt; 10</span><br><span class="line">Hello World -&gt; 11</span><br><span class="line">Hello World -&gt; 12</span><br><span class="line">Hello World -&gt; 13</span><br><span class="line">Hello World -&gt; 14</span><br><span class="line">Hello World -&gt; 15</span><br><span class="line">Hello World -&gt; 16</span><br><span class="line">Hello World -&gt; 17</span><br><span class="line">Hello World -&gt; 18</span><br><span class="line">Hello World -&gt; 19</span><br><span class="line">Hello World -&gt; 20</span><br><span class="line">Hello World -&gt; 21</span><br><span class="line">Hello World -&gt; 22</span><br><span class="line">Hello World -&gt; 23</span><br><span class="line">Hello World -&gt; 24</span><br><span class="line">Hello World -&gt; 25</span><br><span class="line">Hello World -&gt; 26</span><br><span class="line">Hello World -&gt; 27</span><br><span class="line">Hello World -&gt; 28</span><br><span class="line">Hello World -&gt; 29</span><br><span class="line">Hello World -&gt; 30</span><br><span class="line">Hello World -&gt; 31</span><br><span class="line">Hello World -&gt; 32</span><br><span class="line">Hello World -&gt; 33</span><br><span class="line">Hello World -&gt; 34</span><br><span class="line">Hello World -&gt; 35</span><br><span class="line">Hello World -&gt; 36</span><br><span class="line">Hello World -&gt; 37</span><br><span class="line">Hello World -&gt; 38</span><br><span class="line">--More--(18%)</span><br><span class="line">$ </span><br><span class="line"><span class="comment"># less</span></span><br><span class="line">$ less -N test.txt </span><br><span class="line">      1 Hello World -&gt; 0</span><br><span class="line">      2 Hello World -&gt; 1</span><br><span class="line">      3 Hello World -&gt; 2</span><br><span class="line">      4 Hello World -&gt; 3</span><br><span class="line">      5 Hello World -&gt; 4</span><br><span class="line">      6 Hello World -&gt; 5</span><br><span class="line">      7 Hello World -&gt; 6</span><br><span class="line">      8 Hello World -&gt; 7</span><br><span class="line">      9 Hello World -&gt; 8</span><br><span class="line">     10 Hello World -&gt; 9</span><br><span class="line">     11 Hello World -&gt; 10</span><br><span class="line">     12 Hello World -&gt; 11</span><br><span class="line">     13 Hello World -&gt; 12</span><br><span class="line">     14 Hello World -&gt; 13</span><br><span class="line">     15 Hello World -&gt; 14</span><br><span class="line">     16 Hello World -&gt; 15</span><br><span class="line">     17 Hello World -&gt; 16</span><br><span class="line">     18 Hello World -&gt; 17</span><br><span class="line">     19 Hello World -&gt; 18</span><br><span class="line">     20 Hello World -&gt; 19</span><br><span class="line">     21 Hello World -&gt; 20</span><br><span class="line">     22 Hello World -&gt; 21</span><br><span class="line">     23 Hello World -&gt; 22</span><br><span class="line">     24 Hello World -&gt; 23</span><br><span class="line">     25 Hello World -&gt; 24</span><br><span class="line">     26 Hello World -&gt; 25</span><br><span class="line">     27 Hello World -&gt; 26</span><br><span class="line">     28 Hello World -&gt; 27</span><br><span class="line">     29 Hello World -&gt; 28</span><br><span class="line">     30 Hello World -&gt; 29</span><br><span class="line">     31 Hello World -&gt; 30</span><br><span class="line">     32 Hello World -&gt; 31</span><br><span class="line">     33 Hello World -&gt; 32</span><br><span class="line">     34 Hello World -&gt; 33</span><br><span class="line">     35 Hello World -&gt; 34</span><br><span class="line">     36 Hello World -&gt; 35</span><br><span class="line">     37 Hello World -&gt; 36</span><br><span class="line">     38 Hello World -&gt; 37</span><br><span class="line">     39 Hello World -&gt; 38</span><br><span class="line">     40 Hello World -&gt; 39</span><br><span class="line">     41 Hello World -&gt; 40</span><br><span class="line">     42 Hello World -&gt; 41</span><br><span class="line">     43 Hello World -&gt; 42</span><br><span class="line">     44 Hello World -&gt; 43</span><br><span class="line">:</span><br><span class="line">$ </span><br></pre></td></tr></table></figure><h3 id="2-5-head-tail-——-查看文件头部-尾部内容"><a href="#2-5-head-tail-——-查看文件头部-尾部内容" class="headerlink" title="2.5 head &#x2F; tail —— 查看文件头部&#x2F;尾部内容"></a>2.5 head &#x2F; tail —— 查看文件头部&#x2F;尾部内容</h3><p><strong>语法：</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">head</span> -n 行数 文件名</span><br><span class="line"><span class="built_in">tail</span> -n 行数 文件名</span><br></pre></td></tr></table></figure><p><strong>功能：</strong> 显示文件的开头或结尾</p><p><strong>常用选项：</strong></p><ul><li><code>-n 行数</code> 显示指定行数</li></ul><p><strong>示例：</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># head</span></span><br><span class="line">$ <span class="built_in">head</span> test.txt </span><br><span class="line">Hello World -&gt; 0</span><br><span class="line">Hello World -&gt; 1</span><br><span class="line">Hello World -&gt; 2</span><br><span class="line">Hello World -&gt; 3</span><br><span class="line">Hello World -&gt; 4</span><br><span class="line">Hello World -&gt; 5</span><br><span class="line">Hello World -&gt; 6</span><br><span class="line">Hello World -&gt; 7</span><br><span class="line">Hello World -&gt; 8</span><br><span class="line">Hello World -&gt; 9</span><br><span class="line">$ <span class="built_in">head</span> -5 test.txt </span><br><span class="line">Hello World -&gt; 0</span><br><span class="line">Hello World -&gt; 1</span><br><span class="line">Hello World -&gt; 2</span><br><span class="line">Hello World -&gt; 3</span><br><span class="line">Hello World -&gt; 4</span><br><span class="line">$ </span><br><span class="line"></span><br><span class="line"><span class="comment">#tail</span></span><br><span class="line">$ <span class="built_in">tail</span> test.txt </span><br><span class="line">Hello World -&gt; 191</span><br><span class="line">Hello World -&gt; 192</span><br><span class="line">Hello World -&gt; 193</span><br><span class="line">Hello World -&gt; 194</span><br><span class="line">Hello World -&gt; 195</span><br><span class="line">Hello World -&gt; 196</span><br><span class="line">Hello World -&gt; 197</span><br><span class="line">Hello World -&gt; 198</span><br><span class="line">Hello World -&gt; 199</span><br><span class="line">Hello World -&gt; 200</span><br><span class="line">$ <span class="built_in">tail</span> -5 test.txt </span><br><span class="line">Hello World -&gt; 196</span><br><span class="line">Hello World -&gt; 197</span><br><span class="line">Hello World -&gt; 198</span><br><span class="line">Hello World -&gt; 199</span><br><span class="line">Hello World -&gt; 200</span><br><span class="line">$ </span><br><span class="line"></span><br><span class="line"><span class="comment"># 查看文件的[180,200]行的内容</span></span><br><span class="line">Hello World -&gt; 180</span><br><span class="line">Hello World -&gt; 181</span><br><span class="line">Hello World -&gt; 182</span><br><span class="line">Hello World -&gt; 183</span><br><span class="line">Hello World -&gt; 184</span><br><span class="line">Hello World -&gt; 185</span><br><span class="line">Hello World -&gt; 186</span><br><span class="line">Hello World -&gt; 187</span><br><span class="line">Hello World -&gt; 188</span><br><span class="line">Hello World -&gt; 189</span><br><span class="line">Hello World -&gt; 190</span><br><span class="line">Hello World -&gt; 191</span><br><span class="line">Hello World -&gt; 192</span><br><span class="line">Hello World -&gt; 193</span><br><span class="line">Hello World -&gt; 194</span><br><span class="line">Hello World -&gt; 195</span><br><span class="line">Hello World -&gt; 196</span><br><span class="line">Hello World -&gt; 197</span><br><span class="line">Hello World -&gt; 198</span><br><span class="line">Hello World -&gt; 199</span><br><span class="line">$ </span><br></pre></td></tr></table></figure><h2 id="3-查找操作"><a href="#3-查找操作" class="headerlink" title="3. 查找操作"></a>3. 查找操作</h2><h3 id="3-1-find-——-在文件树中查找文件"><a href="#3-1-find-——-在文件树中查找文件" class="headerlink" title="3.1 find —— 在文件树中查找文件"></a>3.1 find —— 在文件树中查找文件</h3><p><strong>语法</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">find [查找路径] []</span><br></pre></td></tr></table></figure><p><strong>功能</strong>  在文件树中查找文件，并作出相应处理(如访问磁盘)</p><p><strong>常用选项</strong></p><ul><li><code>-name</code> 按照文件查找文件(区分大小写)</li><li><code>-iname</code> 按文件名搜索(不区分大小写) </li><li><code>-type</code><ul><li><code>f</code> 普通文件</li><li><code>d</code> 目录</li><li><code>l</code> 符号链接</li><li>示例：<code>find /var/log -type f</code>(搜索 <code>/var/log</code> 下的所有文件)</li></ul></li><li><code>-mtime n</code><ul><li><code>+n</code> <code>n</code> 天前修改</li><li><code>-n</code> <code>n</code> 天内修改</li><li><code>find /tmp -mtime +7</code>(搜索 <code>7</code> 天前修改的文件)</li></ul></li><li><code>-atime n</code> 按访问时间(<code>Access Time</code>)过滤，用法同 <code>-mtime</code></li><li><code>-size n</code><ul><li><code>+n</code> 大于 <code>n</code></li><li><code>-n</code> 小于 <code>n</code></li><li>单位：<code>c</code>(字节)、<code>k</code>(<code>KB</code>)、<code>M</code>(<code>MB</code>)、<code>G</code>(<code>GB</code>)</li><li><code>find / -size +100M</code>(搜索大于 <code>100MB</code> 的文件)</li></ul></li><li><code>-perm</code> 权限 -&gt; 按文件权限搜索(八进制或符号格式)<ul><li>示例：<code>find . -perm 644</code>(搜索权限为 <code>644</code> 的文件)</li></ul></li><li><code>-user</code> 用户名 -&gt; 按文件所有者搜索<ul><li>示例：<code>find /home -user alice</code></li></ul></li><li><code>-group</code> 组名 -&gt; 按文件所属组搜索</li></ul><p><strong>示例</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">ls</span> -n</span><br><span class="line">total 28</span><br><span class="line">drwxrwxr-x  8 1000 1000 4096 Apr  8 16:24 code</span><br><span class="line">drwxrwxr-x 18 1000 1000 4096 Mar 30 13:16 learning-c</span><br><span class="line">-rw-rw-r--  1 1000 1000  677 Mar 17 16:31 makefile</span><br><span class="line">drwxrwxr-x  2 1000 1000 4096 Feb 26 13:26 process</span><br><span class="line">drwxrwxr-x  3 1000 1000 4096 Mar  3 15:05 project</span><br><span class="line">drwxrwxr-x  3 1000 1000 4096 Apr 11 20:07 <span class="built_in">test</span></span><br><span class="line">drwxrwxr-x  2 1000 1000 4096 Mar 23 21:34 tmp</span><br><span class="line">$ find <span class="built_in">test</span> <span class="built_in">test</span></span><br><span class="line"><span class="built_in">test</span></span><br><span class="line"><span class="built_in">test</span>/mydir</span><br><span class="line"><span class="built_in">test</span>/mydir/test.txt</span><br><span class="line"><span class="built_in">test</span>/mydir/log.txt</span><br><span class="line"><span class="built_in">test</span></span><br><span class="line"><span class="built_in">test</span>/mydir</span><br><span class="line"><span class="built_in">test</span>/mydir/test.txt</span><br><span class="line"><span class="built_in">test</span>/mydir/log.txt</span><br><span class="line">$ </span><br></pre></td></tr></table></figure><h3 id="3-2-grep-——-在文件中搜索-字符串-文件"><a href="#3-2-grep-——-在文件中搜索-字符串-文件" class="headerlink" title="3.2 grep —— 在文件中搜索 字符串 文件"></a>3.2 grep —— 在文件中搜索 字符串 文件</h3><p><strong>语法</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">grep [选项] [搜索字符串 文件]</span><br></pre></td></tr></table></figure><p><strong>功能</strong> 在文件中搜索字符串，将找到的行打印出来<br><strong>常用选项</strong></p><ul><li><code>-i</code> 忽略⼤⼩写的不同，所以⼤⼩写视为相同</li><li><code>-n</code> 顺便输出⾏号</li><li><code>-v</code> 反向选择，亦即显⽰出没有 ‘搜寻字符串’ 内容的那⼀⾏<br><strong>示例</strong></li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">cat</span> -n test.txt </span><br><span class="line">     1abcd</span><br><span class="line">     2ABCD</span><br><span class="line">     3what</span><br><span class="line">     4why</span><br><span class="line">     5when</span><br><span class="line">     6<span class="built_in">where</span></span><br><span class="line">     7<span class="built_in">who</span></span><br><span class="line">     81234</span><br><span class="line">     9</span><br><span class="line"></span><br><span class="line">$ grep <span class="string">&quot;abcd&quot;</span> test.txt </span><br><span class="line">abcd</span><br><span class="line"><span class="comment"># 忽略大小写的不同</span></span><br><span class="line">$ grep -i <span class="string">&quot;abcd&quot;</span> test.txt </span><br><span class="line">abcd</span><br><span class="line">ABCD</span><br><span class="line"><span class="comment"># 输出行号</span></span><br><span class="line">$ grep -<span class="keyword">in</span> <span class="string">&quot;abcd&quot;</span> test.txt </span><br><span class="line">1:abcd</span><br><span class="line">2:ABCD</span><br><span class="line"><span class="comment"># 反向选择，除了指定字符串不输出，其他全输出</span></span><br><span class="line">$ grep -v <span class="string">&quot;abcd&quot;</span> test.txt </span><br><span class="line">ABCD</span><br><span class="line">what</span><br><span class="line">why</span><br><span class="line">when</span><br><span class="line"><span class="built_in">where</span></span><br><span class="line"><span class="built_in">who</span></span><br><span class="line">1234</span><br><span class="line"></span><br><span class="line">$ grep -vni <span class="string">&quot;abcd&quot;</span> test.txt </span><br><span class="line">3:what</span><br><span class="line">4:why</span><br><span class="line">5:when</span><br><span class="line">6:<span class="built_in">where</span></span><br><span class="line">7:<span class="built_in">who</span></span><br><span class="line">8:1234</span><br><span class="line">9:</span><br><span class="line">$ </span><br></pre></td></tr></table></figure><h3 id="3-3-which-——-搜索命令"><a href="#3-3-which-——-搜索命令" class="headerlink" title="3.3 which —— 搜索命令"></a>3.3 which —— 搜索命令</h3><p><strong>语法</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">which</span> 命令</span><br></pre></td></tr></table></figure><p><strong>功能</strong>  查找可执行文件的绝对路径</p><p><strong>示例</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">which</span> <span class="built_in">ls</span></span><br><span class="line"><span class="built_in">alias</span> <span class="built_in">ls</span>=<span class="string">&#x27;ls --color=auto&#x27;</span></span><br><span class="line">    /usr/bin/ls</span><br><span class="line">$ <span class="built_in">which</span> <span class="built_in">pwd</span></span><br><span class="line">/usr/bin/pwd</span><br><span class="line">$ <span class="built_in">which</span> gcc</span><br><span class="line">/usr/bin/gcc</span><br><span class="line">$ </span><br></pre></td></tr></table></figure><h3 id="3-4-whereis-——-查找程序的源文件"><a href="#3-4-whereis-——-查找程序的源文件" class="headerlink" title="3.4 whereis —— 查找程序的源文件"></a>3.4 whereis —— 查找程序的源文件</h3><p><strong>语法</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">whereis 命令</span><br></pre></td></tr></table></figure><p><strong>功能</strong> 查找程序的源、二进制文件或手册的位置</p><p><strong>示例</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">$ whereis <span class="built_in">ls</span></span><br><span class="line"><span class="built_in">ls</span>: /usr/bin/ls /usr/share/man/man1/ls.1.gz /usr/share/man/man1p/ls.1p.gz</span><br><span class="line">$ whereis stdio.h</span><br><span class="line">stdio: /usr/include/stdio.h /usr/share/man/man3/stdio.3.gz</span><br><span class="line">$ whereis libc.so</span><br><span class="line">libc: /usr/lib64/libc.so /usr/share/man/man7/libc.7.gz</span><br><span class="line">$ whereis <span class="built_in">dir</span></span><br><span class="line"><span class="built_in">dir</span>: /usr/bin/dir /usr/share/man/man1/dir.1.gz</span><br><span class="line">$ </span><br></pre></td></tr></table></figure><h2 id="4-压缩"><a href="#4-压缩" class="headerlink" title="4.压缩"></a>4.压缩</h2><h3 id="4-1-zip-unzip"><a href="#4-1-zip-unzip" class="headerlink" title="4.1 zip&#x2F;unzip"></a>4.1 zip&#x2F;unzip</h3><p><strong>语法</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">zip 要压缩的文件.zip 目录或文件</span><br></pre></td></tr></table></figure><p><strong>功能</strong> 将目录或文件压缩为 <code>zip</code> 格式<br><strong>常用选项</strong></p><ul><li>基础压缩<ul><li><code>-r</code> 递归处理，将指定目录下的所有文件和子目录一并处理</li><li><code>-q</code> 静默模式(不显示压缩过程输出)</li><li><code>-e</code> 加密压缩文件（设置密码）</li><li><code>-s</code> 大小</li></ul></li><li>基础解压  <ul><li><code>-d 目录</code> 指定解压目标目录</li><li><code>-l</code> 列出压缩包内容(不解压)</li><li><code>-o</code> 覆盖已存在的文件(无需确认)</li><li><code>-n</code> 不覆盖已存在的文件</li><li><code>-P 密码</code> 直接提供密码(避免交互式输入)</li><li><code>-q</code> 静默模式(不显示解压过程)</li></ul></li></ul><p><strong>示例</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">$ tree mydir/</span><br><span class="line">mydir/</span><br><span class="line">├── log.txt</span><br><span class="line">└── test.txt</span><br><span class="line"></span><br><span class="line">0 directories, 2 files</span><br><span class="line">$ zip -r test.zip mydir</span><br><span class="line">  adding: mydir/ (stored 0%)</span><br><span class="line">  adding: mydir/test.txt (deflated 13%)</span><br><span class="line">  adding: mydir/log.txt (deflated 76%)</span><br><span class="line">$ <span class="built_in">ls</span> -al</span><br><span class="line">total 16</span><br><span class="line">drwxrwxr-x  3 wyf wyf 4096 Apr 11 21:08 .</span><br><span class="line">drwx------ 15 wyf wyf 4096 Apr 11 20:52 ..</span><br><span class="line">drwxrwxr-x  2 wyf wyf 4096 Apr 11 20:57 mydir</span><br><span class="line">-rw-rw-r--  1 wyf wyf  524 Apr 11 21:08 test.zip</span><br><span class="line">$ <span class="built_in">mkdir</span> zip</span><br><span class="line">$ unzip test.zip zip/</span><br><span class="line">Archive:  test.zip</span><br><span class="line">caution: filename not matched:  zip/</span><br><span class="line">$ unzip test.zip -d zip/</span><br><span class="line">Archive:  test.zip</span><br><span class="line">   creating: zip/mydir/</span><br><span class="line">  inflating: zip/mydir/test.txt      </span><br><span class="line">  inflating: zip/mydir/log.txt       </span><br><span class="line">$ <span class="built_in">cd</span> zip</span><br><span class="line">$ tree mydir/</span><br><span class="line">mydir/</span><br><span class="line">├── log.txt</span><br><span class="line">└── test.txt</span><br><span class="line"></span><br><span class="line">0 directories, 2 files</span><br><span class="line">$ </span><br></pre></td></tr></table></figure><h3 id="4-2-tar"><a href="#4-2-tar" class="headerlink" title="4.2 tar"></a>4.2 tar</h3><p><strong>语法</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar [选项] 文件/目录</span><br></pre></td></tr></table></figure><p><strong>常用选项</strong></p><ul><li><strong><code>-c</code></strong> 创建新的归档文件(<code>Create</code>)<br>示例：<code>tar -cvf archive.tar /path/to/dir</code>(将目录打包为 <code>archive.tar</code>，<code>-v</code> 显示过程)</li><li><strong><code>-x</code></strong> 提取归档文件(<code>Extract</code>)<br>示例：<code>tar -xvf archive.tar</code>(解压到当前目录)</li><li><strong><code>-t</code></strong> 列出归档文件内容(List)<br>示例：<code>tar -tvf archive.tar</code>(显示归档中的文件列表及详细信息)</li><li><strong><code>-z</code></strong> 使用 <strong><code>gzip</code></strong> 压缩(后缀 <code>.tar.gz</code> 或 <code>.tgz</code>)<br>示例：  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tar -czvf backup.tar.gz /path/to/dir   <span class="comment"># 压缩</span></span><br><span class="line">tar -xzvf backup.tar.gz               <span class="comment"># 解压</span></span><br></pre></td></tr></table></figure></li><li><strong><code>-j</code></strong> 使用 <strong><code>bzip2</code></strong> 压缩(后缀 <code>.tar.bz2</code>)<br>示例：  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tar -cjvf backup.tar.bz2 /path/to/dir  <span class="comment"># 压缩</span></span><br><span class="line">tar -xjvf backup.tar.bz2              <span class="comment"># 解压</span></span><br></pre></td></tr></table></figure></li><li><strong><code>-J</code></strong> 使用 <strong><code>xz</code></strong> 压缩(后缀 <code>.tar.xz</code>，高压缩率)<br>示例：  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">tar -cJvf backup.tar.xz /path/to/dir   <span class="comment"># 压缩</span></span><br><span class="line">tar -xJvf backup.tar.xz               <span class="comment"># 解压</span></span><br></pre></td></tr></table></figure></li><li><strong><code>-f</code></strong> 指定归档文件名(必须放在选项末尾)<br>示例：<code>tar -cvf myfiles.tar /path/to/files</code></li><li><strong><code>-v</code></strong> 显示详细操作过程（Verbose）</li><li><strong><code>-C</code></strong> 指定解压目标目录<br>示例：<code>tar -xvf archive.tar -C /target/dir</code></li><li><strong><code>--exclude=&quot;模式&quot;</code></strong> 排除指定文件或目录<br>示例：  <figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">tar -czvf backup.tar.gz --exclude=<span class="string">&quot;*.log&quot;</span> /path/to/dir  <span class="comment"># 排除 .log 文件</span></span><br></pre></td></tr></table></figure></li><li><strong><code>-r</code></strong> 向归档中追加文件(仅对未压缩的 <code>.tar</code> 文件有效)<br>示例：<code>tar -rvf archive.tar newfile.txt</code></li><li><strong><code>-p</code></strong> 保留文件权限(常用于备份系统文件)<br>示例：<code>tar -czvpf backup.tar.gz /etc</code></li><li><strong><code>--wildcards</code></strong> 解压时使用通配符匹配文件<br>示例：<code>tar -xzvf backup.tar.gz --wildcards &quot;*.conf&quot;</code></li></ul><p><strong>示例</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">ls</span> -l </span><br><span class="line">total 4</span><br><span class="line">drwxrwxr-x 2 wyf wyf 4096 Apr 11 21:27 mydir</span><br><span class="line"><span class="comment"># 仅打包，不压缩</span></span><br><span class="line">$ tar -cvf dir.tar mydir</span><br><span class="line">mydir/</span><br><span class="line">mydir/test.txt</span><br><span class="line">mydir/log.txt</span><br><span class="line">mydir/file.txt</span><br><span class="line"><span class="comment"># 打包后，以gzip压缩</span></span><br><span class="line">$ tar -zcvf dir.tar.gz mydir/</span><br><span class="line">mydir/</span><br><span class="line">mydir/test.txt</span><br><span class="line">mydir/log.txt</span><br><span class="line">mydir/file.txt</span><br><span class="line"><span class="comment"># 打包后，以bzip2压缩</span></span><br><span class="line">$ tar -jcvf dir.tar.bz2 mydir</span><br><span class="line">mydir/</span><br><span class="line">mydir/test.txt</span><br><span class="line">mydir/log.txt</span><br><span class="line">mydir/file.txt</span><br><span class="line">$ <span class="built_in">ls</span> -l</span><br><span class="line">total 24</span><br><span class="line">-rw-rw-r-- 1 wyf wyf 10240 Apr 11 21:29 dir.tar</span><br><span class="line">-rw-rw-r-- 1 wyf wyf   585 Apr 11 21:31 dir.tar.bz2</span><br><span class="line">-rw-rw-r-- 1 wyf wyf   714 Apr 11 21:30 dir.tar.gz</span><br><span class="line">drwxrwxr-x 2 wyf wyf  4096 Apr 11 21:27 mydir</span><br><span class="line"><span class="comment"># 查看压缩文件中有哪些文件</span></span><br><span class="line">$ tar -ztvf dir.tar.gz</span><br><span class="line">drwxrwxr-x wyf/wyf           0 2025-04-11 21:27 mydir/</span><br><span class="line">-rw-rw-r-- wyf/wyf          40 2025-04-11 20:51 mydir/test.txt</span><br><span class="line">-rw-rw-r-- wyf/wyf          72 2025-04-11 20:26 mydir/log.txt</span><br><span class="line">-rw-rw-r-- wyf/wyf        3709 2025-04-11 21:28 mydir/file.txt</span><br><span class="line">$ <span class="built_in">mkdir</span> tar</span><br><span class="line"><span class="comment"># 解压到指定目录</span></span><br><span class="line">$ tar -zxvf dir.tar.gz -C tar</span><br><span class="line">mydir/</span><br><span class="line">mydir/test.txt</span><br><span class="line">mydir/log.txt</span><br><span class="line">mydir/file.txt</span><br><span class="line">$ tree tar</span><br><span class="line">tar</span><br><span class="line">└── mydir</span><br><span class="line">    ├── file.txt</span><br><span class="line">    ├── log.txt</span><br><span class="line">    └── test.txt</span><br><span class="line"></span><br><span class="line">1 directory, 3 files</span><br><span class="line">$ </span><br></pre></td></tr></table></figure><h2 id="5-日期时间"><a href="#5-日期时间" class="headerlink" title="5. 日期时间"></a>5. 日期时间</h2><h3 id="5-1-date-——-显示时间"><a href="#5-1-date-——-显示时间" class="headerlink" title="5.1 date —— 显示时间"></a>5.1 date —— 显示时间</h3><p><strong>语法</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">date</span> [选项]…… [格式]</span><br></pre></td></tr></table></figure><p><strong>功能</strong>  指定格式显示时间</p><ol><li><strong>显示时间的时候</strong>，可以设定显示的格式，格式设定为一个+后加数个标记，其中常用的标记如下：</li></ol><ul><li><code>%H</code> ⼩时(<code>00..23</code>)</li><li><code>%M</code> 分钟(<code>00..59</code>)</li><li><code>%S</code> 秒(<code>00..61</code>)</li><li><code>%X</code> 相当于 <code>%H:%M:%S</code></li><li><code>%d</code> ⽇ (<code>01..31</code>)</li><li><code>%m</code> ⽉份 (<code>01..12</code>)</li><li><code>%Y</code> 完整年份 (<code>0000..9999</code>)</li><li><code>%F</code> 相当于 <code>%Y-%m-%d</code></li></ul><ol start="2"><li><strong>设定时间的时候</strong></li></ol><ul><li><code>date -s</code> &#x2F;&#x2F;设置当前时间，只有root权限才能设置，其他只能查看。</li><li><code>date -s</code> 20080523 &#x2F;&#x2F;设置成20080523，这样会把具体时间设置成空00:00:00</li><li><code>date -s 01:01:01</code> &#x2F;&#x2F;设置具体时间，不会对日期做更改</li><li><code>date -s</code> “01:01:01 2008-05-23″ &#x2F;&#x2F;这样可以设置全部时间</li><li><code>date -s</code> “01:01:01 20080523″ &#x2F;&#x2F;这样可以设置全部时间</li><li><code>date -s</code> “2008-05-23 01:01:01″ &#x2F;&#x2F;这样可以设置全部时间</li><li><code>date -s</code> “20080523 01:01:01″ &#x2F;&#x2F;这样可以设置全部时间</li></ul><ol start="3"><li><strong>时间戳</strong></li></ol><ul><li>时间-&gt;时间戳：<code>date +%s</code></li><li>时间戳-&gt;时间：<code>date -d@1508749502</code></li><li><code>Unix</code> 时间戳(英文为 <code>Unix epoch</code>, <code>Unix time</code>, <code>POSIX time</code> 或 <code>Unix timestamp</code>)是从 <code>1970</code> 年 <code>1</code> 月 <code>1</code><br>日(<code>UTC</code>&#x2F;<code>GMT</code> 的午夜)开始所经过的秒数，不考虑闰秒</li></ul><p><strong>指定格式显示时间</strong></p><p><strong>示例</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">date</span></span><br><span class="line">Fri Apr 11 21:44:04 CST 2025</span><br><span class="line">$ <span class="built_in">date</span> +%Y/%m/%d</span><br><span class="line">2025/04/11</span><br><span class="line">$ <span class="built_in">date</span> +%Y/%m/%d-%H:%M:%S</span><br><span class="line">2025/04/11-21:44:56</span><br><span class="line"><span class="comment"># 显示时间戳</span></span><br><span class="line">$ <span class="built_in">date</span> +%s</span><br><span class="line">1744379107</span><br><span class="line"><span class="comment"># 时间戳转换为正常时间</span></span><br><span class="line">$ <span class="built_in">date</span> +%Y/%m/%d-%H:%M:%S -d @0</span><br><span class="line">1970/01/01-08:00:00</span><br><span class="line">$ <span class="built_in">date</span> +%Y/%m/%d-%H:%M:%S -d @1744379190</span><br><span class="line">2025/04/11-21:46:30</span><br><span class="line">$ </span><br></pre></td></tr></table></figure><h3 id="5-2-cal-——-查看日历"><a href="#5-2-cal-——-查看日历" class="headerlink" title="5.2 cal —— 查看日历"></a>5.2 cal —— 查看日历</h3><p><strong>语法</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cal [选项] [年份]</span><br></pre></td></tr></table></figure><p><strong>功能</strong> 查看日历等时间信息，如只有一个选项，则表示年份(<code>1-9999</code>)，如有两个参数，则表示月份和年份<br><strong>常用选项</strong></p><ul><li><code>-3</code> 显示系统前一个月，当前月，下一个月的月历</li><li><code>-j</code> 显示在当年中的第几天（一年日期按天算，从 <code>1</code> 月 <code>1</code> 号算起，默认显示当前月在⼀年中的天数）</li><li><code>-y</code> 显示当前年份的日历<br><strong>示例</strong></li></ul><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line">$ cal</span><br><span class="line">     April 2025     </span><br><span class="line">Su Mo Tu We Th Fr Sa</span><br><span class="line">       1  2  3  4  5</span><br><span class="line"> 6  7  8  9 10 11 12</span><br><span class="line">13 14 15 16 17 18 19</span><br><span class="line">20 21 22 23 24 25 26</span><br><span class="line">27 28 29 30</span><br><span class="line"></span><br><span class="line">$ cal 1999</span><br><span class="line">                               1999                               </span><br><span class="line"></span><br><span class="line">       January               February                 March       </span><br><span class="line">Su Mo Tu We Th Fr Sa   Su Mo Tu We Th Fr Sa   Su Mo Tu We Th Fr Sa</span><br><span class="line">                1  2       1  2  3  4  5  6       1  2  3  4  5  6</span><br><span class="line"> 3  4  5  6  7  8  9    7  8  9 10 11 12 13    7  8  9 10 11 12 13</span><br><span class="line">10 11 12 13 14 15 16   14 15 16 17 18 19 20   14 15 16 17 18 19 20</span><br><span class="line">17 18 19 20 21 22 23   21 22 23 24 25 26 27   21 22 23 24 25 26 27</span><br><span class="line">24 25 26 27 28 29 30   28                     28 29 30 31</span><br><span class="line">31</span><br><span class="line">        April                   May                   June        </span><br><span class="line">Su Mo Tu We Th Fr Sa   Su Mo Tu We Th Fr Sa   Su Mo Tu We Th Fr Sa</span><br><span class="line">             1  2  3                      1          1  2  3  4  5</span><br><span class="line"> 4  5  6  7  8  9 10    2  3  4  5  6  7  8    6  7  8  9 10 11 12</span><br><span class="line">11 12 13 14 15 16 17    9 10 11 12 13 14 15   13 14 15 16 17 18 19</span><br><span class="line">18 19 20 21 22 23 24   16 17 18 19 20 21 22   20 21 22 23 24 25 26</span><br><span class="line">25 26 27 28 29 30      23 24 25 26 27 28 29   27 28 29 30</span><br><span class="line">                       30 31</span><br><span class="line">        July                  August                September     </span><br><span class="line">Su Mo Tu We Th Fr Sa   Su Mo Tu We Th Fr Sa   Su Mo Tu We Th Fr Sa</span><br><span class="line">             1  2  3    1  2  3  4  5  6  7             1  2  3  4</span><br><span class="line"> 4  5  6  7  8  9 10    8  9 10 11 12 13 14    5  6  7  8  9 10 11</span><br><span class="line">11 12 13 14 15 16 17   15 16 17 18 19 20 21   12 13 14 15 16 17 18</span><br><span class="line">18 19 20 21 22 23 24   22 23 24 25 26 27 28   19 20 21 22 23 24 25</span><br><span class="line">25 26 27 28 29 30 31   29 30 31               26 27 28 29 30</span><br><span class="line"></span><br><span class="line">       October               November               December      </span><br><span class="line">Su Mo Tu We Th Fr Sa   Su Mo Tu We Th Fr Sa   Su Mo Tu We Th Fr Sa</span><br><span class="line">                1  2       1  2  3  4  5  6             1  2  3  4</span><br><span class="line"> 3  4  5  6  7  8  9    7  8  9 10 11 12 13    5  6  7  8  9 10 11</span><br><span class="line">10 11 12 13 14 15 16   14 15 16 17 18 19 20   12 13 14 15 16 17 18</span><br><span class="line">17 18 19 20 21 22 23   21 22 23 24 25 26 27   19 20 21 22 23 24 25</span><br><span class="line">24 25 26 27 28 29 30   28 29 30               26 27 28 29 30 31</span><br><span class="line">31</span><br><span class="line"></span><br><span class="line">$ cal  -3</span><br><span class="line">     March 2025            April 2025             May 2025      </span><br><span class="line">Su Mo Tu We Th Fr Sa  Su Mo Tu We Th Fr Sa  Su Mo Tu We Th Fr Sa</span><br><span class="line">                   1         1  2  3  4  5               1  2  3</span><br><span class="line"> 2  3  4  5  6  7  8   6  7  8  9 10 11 12   4  5  6  7  8  9 10</span><br><span class="line"> 9 10 11 12 13 14 15  13 14 15 16 17 18 19  11 12 13 14 15 16 17</span><br><span class="line">16 17 18 19 20 21 22  20 21 22 23 24 25 26  18 19 20 21 22 23 24</span><br><span class="line">23 24 25 26 27 28 29  27 28 29 30           25 26 27 28 29 30 31</span><br><span class="line">30 31                                                           </span><br><span class="line">$ </span><br></pre></td></tr></table></figure><h2 id="6-关机与重启"><a href="#6-关机与重启" class="headerlink" title="6. 关机与重启"></a>6. 关机与重启</h2><h3 id="6-1-shutdown-——-关机命令"><a href="#6-1-shutdown-——-关机命令" class="headerlink" title="6.1 shutdown —— 关机命令"></a>6.1 shutdown —— 关机命令</h3><p><strong>语法：</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shutdown [选项] [时间]</span><br></pre></td></tr></table></figure><p><strong>功能：</strong> 关闭或重启系统。</p><p><strong>常用选项：</strong></p><ul><li><code>-h now</code>  立即关机</li><li><code>-r now</code>  立即重启</li></ul><p><strong>示例：</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">shutdown -h now</span><br></pre></td></tr></table></figure><h2 id="7-其他命令"><a href="#7-其他命令" class="headerlink" title="7. 其他命令"></a>7. 其他命令</h2><h3 id="7-1-uname"><a href="#7-1-uname" class="headerlink" title="7.1 uname"></a>7.1 uname</h3><p><strong>语法</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">uname</span> [选项]</span><br></pre></td></tr></table></figure><p><strong>功能</strong> <code>uname</code> 用于获取电脑和操作系统的相关信息，可以显示 <code>Linux</code> 主机所用的操作系统版本、硬件名称等基本信息<br><strong>常用选项</strong></p><ul><li><code>-a</code> 详细输出所有信息，依次为内核名称，主机名，内核版本号，内核版本，硬件名，处理<br>器类型，硬件平台类型，操作系统名称</li><li><code>-s</code><code>--kernel-name</code>显示内核名称（默认行为）</li><li><code>-n</code><code>--nodename</code>显示网络节点主机名</li><li><code>-r</code><code>--kernel-release</code>显示内核版本号</li><li><code>-v</code><code>--kernel-version</code>显示内核构建版本和时间</li><li><code>-m</code><code>--machine</code>显示硬件架构（<code>CPU</code> 类型）</li></ul><p><strong>示例</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">$ clear </span><br><span class="line">$ <span class="built_in">uname</span> -s</span><br><span class="line">Linux</span><br><span class="line">$ <span class="built_in">uname</span> -n</span><br><span class="line">hcss-ecs-0be3</span><br><span class="line">$ <span class="built_in">uname</span> -r</span><br><span class="line">3.10.0-1160.119.1.el7.x86_64</span><br><span class="line">$ <span class="built_in">uname</span> -a</span><br><span class="line">Linux hcss-ecs-0be3 3.10.0-1160.119.1.el7.x86_64 <span class="comment">#1 SMP Tue Jun 4 14:43:51 UTC 2024 x86_64 x86_64 x86_64 GNU/Linux</span></span><br><span class="line">$ </span><br></pre></td></tr></table></figure><h3 id="7-2-alias"><a href="#7-2-alias" class="headerlink" title="7.2 alias"></a>7.2 alias</h3><p><strong>语法</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">alian 别名=<span class="string">&#x27;原始命令&#x27;</span></span><br></pre></td></tr></table></figure><p><strong>功能</strong> 设置命令的别名，将长命令或复杂命令创建快捷别名</p><p><strong>示例</strong></p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">alias</span> ..=<span class="string">&#x27;cd ..&#x27;</span></span><br><span class="line">$ <span class="built_in">pwd</span></span><br><span class="line">/home/wyf/test/mydir</span><br><span class="line">$ ..</span><br><span class="line">$ <span class="built_in">pwd</span></span><br><span class="line">/home/wyf/test</span><br><span class="line">$ ..</span><br><span class="line">$ <span class="built_in">pwd</span></span><br><span class="line">/home/wyf</span><br><span class="line">$ una</span><br><span class="line"><span class="built_in">unalias</span>  <span class="built_in">uname</span>    </span><br><span class="line"><span class="comment"># 查看所有别名</span></span><br><span class="line">$ <span class="built_in">alias</span></span><br><span class="line"><span class="built_in">alias</span> ..=<span class="string">&#x27;cd ..&#x27;</span></span><br><span class="line"><span class="built_in">alias</span> egrep=<span class="string">&#x27;egrep --color=auto&#x27;</span></span><br><span class="line"><span class="built_in">alias</span> fgrep=<span class="string">&#x27;fgrep --color=auto&#x27;</span></span><br><span class="line"><span class="built_in">alias</span> grep=<span class="string">&#x27;grep --color=auto&#x27;</span></span><br><span class="line"><span class="built_in">alias</span> l.=<span class="string">&#x27;ls -d .* --color=auto&#x27;</span></span><br><span class="line"><span class="built_in">alias</span> ll=<span class="string">&#x27;ls -l --color=auto&#x27;</span></span><br><span class="line"><span class="built_in">alias</span> <span class="built_in">ls</span>=<span class="string">&#x27;ls --color=auto&#x27;</span></span><br><span class="line"><span class="built_in">alias</span> updatetags=<span class="string">&#x27;ctags -R -f ~/.vim/tags --languages=C,C++ --exclude=.git --exclude=node_modules --exclude=build --exclude=.config --exclude=.VimForCpp  ~/code&#x27;</span></span><br><span class="line"><span class="built_in">alias</span> vi=<span class="string">&#x27;vim&#x27;</span></span><br><span class="line"><span class="built_in">alias</span> vim=<span class="string">&#x27;/home/wyf/.VimForCpp/nvim&#x27;</span></span><br><span class="line"><span class="built_in">alias</span> <span class="built_in">which</span>=<span class="string">&#x27;alias | /usr/bin/which --tty-only --read-alias --show-dot --show-tilde&#x27;</span></span><br><span class="line"><span class="comment"># 删除别名</span></span><br><span class="line">$ <span class="built_in">unalias</span> ..</span><br><span class="line">$ </span><br></pre></td></tr></table></figure><h3 id="7-3-clear-——-清屏"><a href="#7-3-clear-——-清屏" class="headerlink" title="7.3 clear —— 清屏"></a>7.3 clear —— 清屏</h3><p><strong>功能</strong> 当屏幕敲满命令时，使用<code>clear</code>可以清除屏幕上的命令</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">clear</span><br></pre></td></tr></table></figure><h3 id="7-4-man"><a href="#7-4-man" class="headerlink" title="7.4 man"></a>7.4 man</h3><p><strong>功能</strong> 查看手册页（<code>manual pages</code>）的核心工具，提供了系统命令、函数、配置文件等的详细文档</p><p><strong>手册页的章节</strong><br>手册页按内容分为多个章节（默认按顺序查找）：</p><ol><li><strong>用户命令（如 <code>ls</code>, <code>cp</code>）</strong></li><li><strong>系统调用（如 <code>open</code>, <code>read</code>）</strong></li><li><strong>库函数（如 <code>printf</code>, <code>malloc</code>）</strong></li><li>设备文件（如 <code>/dev/tty</code>）</li><li>文件格式（如 <code>/etc/passwd</code>）</li><li>游戏和屏保</li><li>杂项（如 <code>man</code>, <code>groff</code>）</li><li>系统管理命令（如 <code>ifconfig</code>, <code>mount</code>）</li><li>内核例程（非标准）</li></ol><p><strong>常用选项</strong></p><ul><li><code>f</code>显示命令的简短描述（等价于 <code>whatis</code>）</li><li><code>k</code>按关键字搜索手册页（等价于 <code>apropos</code>）</li><li><code>a</code>显示所有匹配的手册页（按章节顺序）</li><li><code>w</code>显示手册页的物理路径（如 <code>man -w ls</code>）</li><li><code>K</code>全局搜索手册页内容（全文检索，较慢）</li></ul><p><strong>手册页结构</strong><br>一个典型的手册页包含以下部分：</p><ul><li><code>NAME</code>：名称及简要功能</li><li><code>SYNOPSIS</code>：命令语法或函数原型</li><li><code>DESCRIPTION</code>：详细描述</li><li><code>OPTIONS</code>：命令行选项解释</li><li><code>EXAMPLES</code>（可选）：使用示例</li><li><code>SEE ALSO</code>：相关参考内容</li><li><code>BUGS</code>（可选）：已知问题</li></ul><p><strong>示例</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">man 2 open    <span class="comment"># 查看系统调用 open 的文档</span></span><br><span class="line">man 3 <span class="built_in">printf</span>  <span class="comment"># 查看 C 库函数 printf 的文档</span></span><br><span class="line">man <span class="built_in">ls</span></span><br><span class="line">man -f <span class="built_in">printf</span>  <span class="comment"># 显示所有章节的 &quot;printf&quot;（如 printf(1), printf(3)）</span></span><br></pre></td></tr></table></figure><h3 id="7-5-uname-——-显示系统信息"><a href="#7-5-uname-——-显示系统信息" class="headerlink" title="7.5 uname —— 显示系统信息"></a>7.5 uname —— 显示系统信息</h3><p><strong>1. <code>uname</code> 命令</strong><br><strong>功能</strong>：显示系统信息（内核版本、操作系统名称、硬件架构等）<br> <strong>常用选项</strong></p><table><thead><tr><th>选项</th><th>作用</th></tr></thead><tbody><tr><td><code>-a</code></td><td>显示所有信息（等价于 <code>-snrvm</code>）</td></tr><tr><td><code>-s</code></td><td>显示内核名称（如 <code>Linux</code>）</td></tr><tr><td><code>-n</code></td><td>显示网络节点主机名（等同于 <code>hostname</code>）</td></tr><tr><td><code>-r</code></td><td>显示内核版本（如 <code>5.15.0-86-generic</code>）</td></tr><tr><td><code>-v</code></td><td>显示内核编译时间&#x2F;版本详细信息</td></tr><tr><td><code>-m</code></td><td>显示硬件架构（如 <code>x86_64</code>）</td></tr><tr><td><code>-o</code></td><td>显示操作系统名称（如 <code>GNU/Linux</code>）</td></tr></tbody></table><p><strong>示例</strong></p><ol><li><strong>显示所有系统信息</strong>：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">uname</span> -a</span><br><span class="line"><span class="comment"># Linux mypc 5.15.0-86-generic #96-Ubuntu SMP Wed Oct 11 08:15:58 UTC 2023 x86_64 GNU/Linux</span></span><br></pre></td></tr></table></figure><ol start="2"><li><strong>仅查看内核版本</strong>：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">uname</span> -r</span><br><span class="line"><span class="comment"># 5.15.0-86-generic</span></span><br></pre></td></tr></table></figure><ol start="3"><li><strong>查看硬件架构</strong>：</li></ol><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">uname</span> -m</span><br><span class="line"><span class="comment"># x86_64</span></span><br></pre></td></tr></table></figure><h3 id="7-6-bc-——-计算器"><a href="#7-6-bc-——-计算器" class="headerlink" title="7.6 bc —— 计算器"></a>7.6 bc —— 计算器</h3><p><strong>功能</strong>：高精度数学计算器工具，支持交互式或脚本中的数学运算（包括进制转换、函数计算等）<br><strong>常用选项</strong></p><table><thead><tr><th>选项</th><th>作用</th></tr></thead><tbody><tr><td><code>-l</code></td><td>加载数学库（支持 <code>sin</code>, <code>cos</code>, <code>log</code> 等函数）</td></tr><tr><td><code>-i</code></td><td>强制进入交互模式</td></tr><tr><td><code>-q</code></td><td>静默模式（不显示欢迎信息）</td></tr></tbody></table><p><strong>基本用法</strong><br><strong>直接计算表达式</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">echo</span> <span class="string">&quot;5 + 3 * 2&quot;</span> | bc</span><br><span class="line">11</span><br></pre></td></tr></table></figure><p><strong>设置小数精度</strong><br>通过 <code>scale</code> 变量控制小数位数：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;scale=3; 10/3&quot;</span> | bc</span><br><span class="line">3.333</span><br></pre></td></tr></table></figure><p><strong>进制转换</strong><br><strong>十进制转二进制</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># outbase 设置输出结果的进制</span></span><br><span class="line">$ <span class="built_in">echo</span> <span class="string">&quot;obase=2; 42&quot;</span> | bc</span><br><span class="line">101010</span><br></pre></td></tr></table></figure><p><strong>二进制转十进制</strong>：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># input base 设置输入数值的进制</span></span><br><span class="line"><span class="built_in">echo</span> <span class="string">&quot;ibase=2; 101010&quot;</span> | bc</span><br><span class="line">42</span><br></pre></td></tr></table></figure><p><strong>高级功能</strong><br><strong>使用数学库（-l 选项）</strong></p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span> <span class="string">&quot;s(3.14159/2)&quot;</span> | bc -l   <span class="comment"># 计算 sin(π/2)</span></span><br><span class="line">.99999999999911980765</span><br></pre></td></tr></table></figure><p><strong>定义自定义函数</strong><br>在交互模式中定义函数：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">bc -l</span><br><span class="line">define add(a, b) &#123; <span class="built_in">return</span> a + b &#125;</span><br><span class="line">add(5, 7)</span><br><span class="line">12</span><br></pre></td></tr></table></figure><h2 id="8-重要快捷键"><a href="#8-重要快捷键" class="headerlink" title="8. 重要快捷键"></a>8. 重要快捷键</h2><ul><li><code>Ctrl + C</code>  终止当前进程</li><li><code>Ctrl + Z</code>  挂起当前进程</li><li><code>Ctrl + D</code>  退出终端</li><li><code>Ctrl + R</code>  搜索命令历史</li><li><code>Tab</code> 具有命令补全的功能</li></ul>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>初识Linux</title>
      <link href="/2025/11/18/%E5%88%9D%E8%AF%86Linux/"/>
      <url>/2025/11/18/%E5%88%9D%E8%AF%86Linux/</url>
      
        <content type="html"><![CDATA[<meta name="referrer" content="no-referrer"/><h1 id="Linux-发展史与体系"><a href="#Linux-发展史与体系" class="headerlink" title="Linux 发展史与体系"></a>Linux 发展史与体系</h1><h2 id="Linux-背景"><a href="#Linux-背景" class="headerlink" title="Linux 背景"></a>Linux 背景</h2><h3 id="1-什么是开源？"><a href="#1-什么是开源？" class="headerlink" title="1. 什么是开源？"></a>1. 什么是开源？</h3><p>开源（<code>Open Source</code>）指的是软件的源代码可以被公开、自由访问、修改和分发。开源软件通常遵循一定的许可证，如 <code>GPL</code>（<code>GNU General Public License</code>）或 <code>MIT</code> 许可证，以确保其自由使用、修改和共享的权利</p><p>开源的优势包括：</p><ul><li>透明性：任何人都可以查看代码，减少安全隐患</li><li>协作性：全球开发者可以贡献代码，共同改进软件</li><li>可定制性：用户可以根据需求修改代码</li></ul><h3 id="2-什么是-GNU？"><a href="#2-什么是-GNU？" class="headerlink" title="2. 什么是 GNU？"></a>2. 什么是 GNU？</h3><p><code>GNU</code>（<code>GNU&#39;s Not Unix</code>）是理查德·斯托曼（<code>Richard Stallman</code>）于 <code>1983</code> 年发起的自由软件项目，目标是创建一个完全自由的、与 <code>Unix</code> 兼容的操作系统</p><p><code>GNU</code> 项目的主要组成部分：</p><ul><li><strong>GNU 工具链（GNU Toolchain）</strong>：包括 <code>GCC</code>（编译器）、<code>GDB</code>（调试器）、<code>Make</code>（构建工具）等</li><li><strong>GNU C 库（glibc）</strong>：<code>Linux</code> 主要使用的标准 C 语言库</li><li><strong>GNU Bash</strong>：<code>Linux</code> 系统中最常用的 <code>Shell</code>（命令行解释器）</li><li><strong>GNU Emacs</strong>：一款功能强大的文本编辑器</li></ul><p>尽管 <code>GNU</code> 项目开发了大量关键组件，但其内核 <code>GNU Hurd</code> 进展缓慢，最终 <code>Linux</code> 内核填补了这一空白，形成了“GNU&#x2F;Linux”操作系统</p><!-- ![alt text](/初识Linux/image.png) --><img src="/2025/11/18/%E5%88%9D%E8%AF%86Linux/Linux.png" class=""><h2 id="Unix-的起源与发展"><a href="#Unix-的起源与发展" class="headerlink" title="Unix 的起源与发展"></a>Unix 的起源与发展</h2><h3 id="1-Unix-的诞生"><a href="#1-Unix-的诞生" class="headerlink" title="1. Unix 的诞生"></a>1. Unix 的诞生</h3><ul><li><strong>Multics 项目（1960 年代）</strong>：麻省理工学院、通用电气和 <code>AT&amp;T</code> 贝尔实验室合作开发的多任务分时操作系统，因过于复杂，<code>AT&amp;T</code> 于 <code>1969</code> 年退出</li><li><strong>Unix 诞生（1969 年）</strong>：贝尔实验室的肯·汤普逊（<code>Ken Thompson</code>）和丹尼斯·里奇（<code>Dennis Ritchie</code>）基于 <code>Multics</code> 经验，在 <code>DEC PDP-7</code> 计算机上开发出 <code>Unix</code></li><li><strong>C 语言重写（1973 年）</strong>：<code>Unix</code> 最初使用汇编语言开发，后来里奇用 <code>C</code> 语言重写，提高了可移植性</li><li><strong>BSD Unix（1977 年）</strong>：加州大学伯克利分校（<code>UCB</code>）基于 <code>Unix</code> 开发 <code>BSD</code>（<code>Berkeley Software Distribution</code>），为现代 <code>Unix</code> 和 <code>Linux</code> 贡献了 <code>TCP</code>&#x2F;<code>IP</code> 协议栈等关键技术</li></ul><h2 id="Linux-的诞生与发展"><a href="#Linux-的诞生与发展" class="headerlink" title="Linux 的诞生与发展"></a>Linux 的诞生与发展</h2><h3 id="1-Linux-诞生（1991-年）"><a href="#1-Linux-诞生（1991-年）" class="headerlink" title="1. Linux 诞生（1991 年）"></a>1. Linux 诞生（1991 年）</h3><ul><li><strong>创始人</strong>：芬兰赫尔辛基大学学生林纳斯·托瓦兹（<code>Linus Torvalds</code>）</li><li><strong>目标</strong>：起初是为了替代 <code>MINIX</code>，专为 <code>Intel 80386</code> 处理器开发</li><li><strong>首次公开</strong>：<code>1991</code> 年 <code>8</code> 月 <code>25</code> 日，托瓦兹在 <code>Usenet</code> 论坛 <code>comp.os.minix</code> 发布 <code>Linux</code> 早期版本</li><li><strong>开源化</strong>：<code>1992</code> 年 <code>Linux</code> 采用 <code>GNU GPL</code> 许可证，结合 <code>GNU</code> 软件形成完整的自由操作系统</li></ul><h3 id="2-Linux-发展历程"><a href="#2-Linux-发展历程" class="headerlink" title="2. Linux 发展历程"></a>2. Linux 发展历程</h3><ul><li><strong>Linux 1.0（1994 年）</strong>：首次正式发布，支持多个硬件架构</li><li><strong>Linux 2.0（1996 年）</strong>：增加对多处理器（<code>SMP</code>）的支持，提高性能</li><li><strong>Linux 2.6（2003 年）</strong>：大幅优化内存管理、文件系统和网络</li><li><strong>Linux 3.x - 6.x（2011 年 - 至今）</strong>：持续优化性能、安全性，增强对云计算、容器化和 <code>AI</code> 计算的支持</li></ul><h2 id="Linux-发行版体系"><a href="#Linux-发行版体系" class="headerlink" title="Linux 发行版体系"></a>Linux 发行版体系</h2><h3 id="1-主流-Linux-发行版分类"><a href="#1-主流-Linux-发行版分类" class="headerlink" title="1. 主流 Linux 发行版分类"></a>1. 主流 Linux 发行版分类</h3><p><code>Linux</code> 发行版是基于 <code>Linux</code> 内核和 <code>GNU</code> 工具集构建的完整操作系统，各发行版根据不同需求优化</p><h4 id="1-1-社区驱动的发行版"><a href="#1-1-社区驱动的发行版" class="headerlink" title="1.1 社区驱动的发行版"></a>1.1 社区驱动的发行版</h4><ul><li><strong>Debian</strong>（<code>1993</code> 年）：以稳定著称，广泛用于服务器</li><li><strong>Arch Linux</strong>（<code>2002</code> 年）：滚动更新、极简设计，适合高级用户</li><li><strong>Gentoo</strong>（<code>1999</code> 年）：源代码编译安装，灵活但复杂</li></ul><h4 id="1-2-商业公司支持的发行版"><a href="#1-2-商业公司支持的发行版" class="headerlink" title="1.2 商业公司支持的发行版"></a>1.2 商业公司支持的发行版</h4><ul><li><strong>Red Hat Enterprise Linux（RHEL，2000 年）</strong>：由 <code>Red Hat</code> 开发，主要面向企业级服务器市场</li><li><strong>Ubuntu（2004 年）</strong>：基于 <code>Debian</code>，友好易用，广泛用于桌面和服务器</li><li><strong>SUSE Linux Enterprise（SLES，2000 年）</strong>：德国 <code>SUSE</code> 公司开发，主要面向企业市场</li></ul><h4 id="1-3-安全与渗透测试发行版"><a href="#1-3-安全与渗透测试发行版" class="headerlink" title="1.3 安全与渗透测试发行版"></a>1.3 安全与渗透测试发行版</h4><ul><li><strong>Kali Linux（2013 年）</strong>：由 <code>Offensive Security</code> 维护，专门用于渗透测试和网络安全审计，内置大量安全工具</li></ul><!-- ![alt text](/初识Linux/image.png) --><img src="/2025/11/18/%E5%88%9D%E8%AF%86Linux/image.png" class=""><h3 id="2-Linux-内核官网"><a href="#2-Linux-内核官网" class="headerlink" title="2. Linux 内核官网"></a>2. Linux 内核官网</h3><ul><li><strong>Linux Kernel 官方网站</strong>：<a href="https://www.kernel.org/">https://www.kernel.org</a></li></ul><h3 id="3-各大-Linux-发行版官网"><a href="#3-各大-Linux-发行版官网" class="headerlink" title="3. 各大 Linux 发行版官网"></a>3. 各大 Linux 发行版官网</h3><table><thead><tr><th>发行版</th><th>官网</th></tr></thead><tbody><tr><td>Debian</td><td><a href="https://www.debian.org/">https://www.debian.org</a></td></tr><tr><td>Ubuntu</td><td><a href="https://ubuntu.com/">https://ubuntu.com</a></td></tr><tr><td>Arch Linux</td><td><a href="https://archlinux.org/">https://archlinux.org</a></td></tr><tr><td>Fedora</td><td><a href="https://getfedora.org/">https://getfedora.org</a></td></tr><tr><td>CentOS</td><td><a href="https://www.centos.org/">https://www.centos.org</a></td></tr><tr><td>openSUSE</td><td><a href="https://www.opensuse.org/">https://www.opensuse.org</a></td></tr><tr><td>RHEL</td><td><a href="https://www.redhat.com/">https://www.redhat.com</a></td></tr><tr><td>SUSE</td><td><a href="https://www.suse.com/">https://www.suse.com</a></td></tr><tr><td>Kali Linux</td><td><a href="https://www.kali.org/">https://www.kali.org</a></td></tr></tbody></table><h2 id="Linux-在现代计算领域的应用"><a href="#Linux-在现代计算领域的应用" class="headerlink" title="Linux 在现代计算领域的应用"></a>Linux 在现代计算领域的应用</h2><h3 id="1-社区与企业的力量"><a href="#1-社区与企业的力量" class="headerlink" title="1. 社区与企业的力量"></a>1. 社区与企业的力量</h3><ul><li><strong>全球协作</strong><code>：Linux</code> 的成功离不开全球各地开发者的自发贡献。通过邮件列表、补丁提交和版本控制系统（如 <code>Git</code>），<code>Linux</code> 内核及相关软件得以不断改进和扩展。与此同时，许多公司（如 <code>IBM</code>、<code>Red Hat</code>、<code>Inte</code>l、<code>HP</code> 等）也投入大量资源支持 <code>Linux</code> 开发，使其在性能、稳定性和安全性上不断提升</li><li><strong>Linux 基金会</strong>：<code>2007</code> 年，开放源代码发展实验室（<code>OSDL</code>）与自由标准组织合并成立了 <code>Linux</code> 基金会，进一步促进了 <code>Linux</code> 技术的普及和标准化，为 <code>Linux</code> 在服务器、数据中心、超级计算机等领域的发展提供了重要支持</li></ul><h3 id="2-广泛应用"><a href="#2-广泛应用" class="headerlink" title="2. 广泛应用"></a>2. 广泛应用</h3><ul><li><strong>服务器和超级计算机</strong>：如今全球 <code>500</code> 强超级计算机中 <code>100%</code> 使用 <code>Linux</code>。在互联网时代，许多网站、云服务和数据中心都依赖 <code>Linux</code> 系统来保障高并发和高可用性</li><li><strong>嵌入式与移动设备</strong>：除了传统的桌面和服务器，<code>Linux</code> 内核同样应用于嵌入式系统。<code>Android</code> 操作系统便是以 <code>Linux</code> 内核为基础构建的，广泛应用于智能手机、平板电脑、智能电视、路由器、机顶盒等众多领域</li><li><strong>桌面环境</strong>：虽然在桌面市场 <code>Linux</code> 面临着 <code>Windows</code> 和 <code>macOS</code> 的竞争，但诸如<code>Ubuntu</code>、F<code>edora</code>、<code>Debian</code> 等发行版凭借着稳定性和安全性，也拥有不少忠实用户和特定领域的应用场景</li></ul><h1 id="2-搭建Linux环境"><a href="#2-搭建Linux环境" class="headerlink" title="2 搭建Linux环境"></a>2 搭建Linux环境</h1><h2 id="1-Linux环境搭建方式"><a href="#1-Linux环境搭建方式" class="headerlink" title="1. Linux环境搭建方式"></a>1. Linux环境搭建方式</h2><p>在搭建 <code>Linux</code> 环境时，可以选择以下几种方式，每种方式各有优缺点，适合不同的使用场景：  </p><ol><li><p><strong>直接安装在物理机上</strong><br>这是最原生的方式，适用于希望深度体验 <code>Linux</code> 系统的用户。然而，对于习惯了 <code>Windows</code> 的新手来说，可能会在日常操作中遇到一些不便，例如软件兼容性、驱动适配等问题。因此，如果没有特别的需求，直接在物理机上安装 <code>Linux</code> 可能不是最优解</p></li><li><p><strong>使用虚拟机</strong><br>通过虚拟机软件（如 <code>VMware</code>、<code>VirtualBox</code>）在 <code>Windows</code> 或 <code>macOS</code> 上运行 <code>Linux</code>，可以在不影响原系统的情况下体验 <code>Linux</code> 环境。这种方式适合希望灵活切换操作系统的用户。然而，虚拟机可能会遇到一些兼容性问题，如网络配置、硬件加速等，对于新手来说可能会带来额外的技术挑战，因此不太推荐  </p></li><li><p><strong>使用云服务器</strong><br>直接购买云服务器（如腾讯云、阿里云、华为云等）是一种简单高效的方式。云服务器无需繁琐的安装与配置，只需远程连接即可使用，几乎是“无脑操作”，特别适合初学者。此外，在云服务器上部署项目后，可以直接通过公网访问，这与企业级的服务器部署方式类似，使你的程序能够真正面向外部用户提供服务。如果你是学生，可以先进行学生认证，以获得云厂商提供的专属优惠，大幅降低成本</p></li></ol><h2 id="2-云服务器搭建Linux环境"><a href="#2-云服务器搭建Linux环境" class="headerlink" title="2. 云服务器搭建Linux环境"></a>2. 云服务器搭建Linux环境</h2><p>这里以华为云为例，其他厂商类似</p><ol><li>进入官网，<a href="https://www.huaweicloud.com/s/JUZsZXh1c-S6keacjeWKoeWZqFjlrp7kvosl">华为云-Flexus云服务器X实例</a></li></ol> <!-- ![alt text](/初识Linux/1743421299975.png) --> <img src="/2025/11/18/%E5%88%9D%E8%AF%86Linux/1743421299975.png" class=""> <!-- ![alt text](/初识Linux/1743421327200.png) --> <img src="/2025/11/18/%E5%88%9D%E8%AF%86Linux/1743421327200.png" class=""><p> 学生可以在个人中心进学生认证<br> <!-- ![alt text](/初识Linux/1743421431557.png) --><br> <img src="/2025/11/18/%E5%88%9D%E8%AF%86Linux/1743421431557.png" class=""><br> 也可以在官网搜索包含校园的关键词，看看有没有活动<br><a href="https://activity.huaweicloud.com/discount_area_v5/index.html?fromacct=2a6390b0d917492c8f446df8c5efd02f&utm_source=eWl0aWFuXzVzYWQ==&utm_medium=cps&utm_campaign=201905">推广一下</a></p><ol><li>开始购买</li></ol> <!-- ![alt text](/初识Linux/1743422095825.png) -->  <img src="/2025/11/18/%E5%88%9D%E8%AF%86Linux/1743422095825.png" class=""><ol start="2"><li>购买完成之后，进入控制台</li></ol> <!-- ![alt text](/初识Linux/1743422272316.png) -->  <img src="/2025/11/18/%E5%88%9D%E8%AF%86Linux/1743422272316.png" class=""><p> 就能看到购买的Flexus云服务器X实例了<br> <!-- ![alt text](/初识Linux/1743422363346.png) --><br>  <img src="/2025/11/18/%E5%88%9D%E8%AF%86Linux/1743422363346.png" class=""><br> <!-- ![alt text](/初识Linux/1743422607123.png) --><br> <img src="/2025/11/18/%E5%88%9D%E8%AF%86Linux/1743422607123.png" class=""><br> 3. 重置 <code>root</code> 密码，稍后远程登录的时候会用到密码，建议将这个密码设置的稍微复杂一些<br> <!-- ![alt text](/初识Linux/1743422784943.png) --><br>  <img src="/2025/11/18/%E5%88%9D%E8%AF%86Linux/1743422784943.png" class=""></p><p> 上述工作完成之后，就只差远程登录了</p><h1 id="3-使用XShell-远程登录到Linux"><a href="#3-使用XShell-远程登录到Linux" class="headerlink" title="3 使用XShell 远程登录到Linux"></a>3 使用XShell 远程登录到Linux</h1><h2 id="1-下载安装XShell"><a href="#1-下载安装XShell" class="headerlink" title="1. 下载安装XShell"></a>1. 下载安装XShell</h2><ol><li><code>XShell</code> 是一个远程终端软件，下载官网<a href="https://www.xshell.com/zh/free-for-home-school/">XShell</a></li></ol><h2 id="2查看Linux主机IP"><a href="#2查看Linux主机IP" class="headerlink" title="2查看Linux主机IP"></a>2查看Linux主机IP</h2><p> 主机 <code>IP</code> 就是上面说的公网 <code>IP</code></p><h2 id="3-使用XShell登录主机"><a href="#3-使用XShell登录主机" class="headerlink" title="3 使用XShell登录主机"></a>3 使用XShell登录主机</h2><p>  在 <code>XShell</code> 下输入<code>ssh root@IP</code>,初次登陆时候，使用 <code>root</code> 登录，后面会切换用户，输入前面设置过的密码，就可以了<br>  <!-- ![alt text](/初识Linux/1743423314889.png) --><br>   <img src="/2025/11/18/%E5%88%9D%E8%AF%86Linux/1743423314889.png" class=""><br>  显示下面信息，就成功了，<br>  <!-- ![alt text](/初识Linux/1743423529165.png) --><br>   <img src="/2025/11/18/%E5%88%9D%E8%AF%86Linux/1743423529165.png" class=""></p><h3 id="3-1-XShell免密登录"><a href="#3-1-XShell免密登录" class="headerlink" title="3.1 XShell免密登录"></a>3.1 XShell免密登录</h3><p>打开 <code>Xshell</code> 点击新建会话</p><!-- ![1744284842586](/初识Linux/1744284842586.png) --><img src="/2025/11/18/%E5%88%9D%E8%AF%86Linux/1744284842586.png" class=""><p>设置好名字和公网 <code>IP</code></p><!-- ![1744284978030](/初识Linux/1744284978030.png) --><img src="/2025/11/18/%E5%88%9D%E8%AF%86Linux/1744284978030.png" class=""><p>关闭 <code>XShell</code> 之后再打开，就会看到设置的会话名称，点进去，输入登录名(默认是 <code>root</code>)，输入密码就可以进行登录(输入的时候选择记住账号和密码就可以直接登录云服务器了)，以后使用的时候直接点击就可以了</p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
